// Code generated by "core generate"; DO NOT EDIT.

package tensor

import (
	"cogentcore.org/core/types"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/tensor.Indexed", IDName: "indexed", Doc: "Indexed is a wrapper around another [Tensor] that provides a\nindexed view onto the Tensor provided by an [Int] tensor with\nindex coordinates into the source tensor. The innermost dimension\nsize of the indexes is equal to the number of dimensions in\nthe source tensor, and the remaining outer dimensions provide the\nshape for the [Indexed] tensor view.\nTo produce a new concrete [Values] that has raw data actually organized according\nto the indexed order (i.e., the copy function of numpy), call [Indexed.AsValues].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Sequential", Doc: "Sequential sets all Indexes to nil, resulting in full sequential access into tensor.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Fields: []types.Field{{Name: "Tensor", Doc: "Tensor that we are an indexed view onto."}, {Name: "Indexes", Doc: "Indexes are the indexes for each dimension, with dimensions as the outer\nslice (enforced to be the same length as the NumDims of the source Tensor),\nand a list of dimension index values (within range of DimSize(d)).\nA nil list of indexes automatically provides a full, sequential view of that\ndimension."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/tensor.Masked", IDName: "masked", Doc: "Masked is a wrapper around another [Tensor] that provides a\nbit-masked view onto the Tensor defined by a [Bool] [Values]\ntensor with a matching shape. If the bool mask has a 'false'\nthen the corresponding value cannot be set and Float access returns\nNaN indicating missing data.\nTo produce a new [Values] tensor with only the 'true' cases,\n(i.e., the copy function of numpy), call [Masked.AsValues].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Fields: []types.Field{{Name: "Tensor", Doc: "Tensor that we are a masked view onto."}, {Name: "Mask", Doc: "Bool tensor with same shape as source tensor, providing mask."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/tensor.Rows", IDName: "rows", Doc: "Rows is a row-indexed wrapper around a [Values] [Tensor] that provides a\nspecific view onto the Tensor defined by the set of [Rows.Indexes],\nwhich apply to the outermost row dimension (with default row-major indexing).\nSorting and filtering a tensor only requires updating the indexes while\nleaving the underlying Tensor alone.\nUse [AsValues] to obtain a concrete [Values] representation with the current row\nsorting. Use the [Set]FloatRow[Cell] methods wherever possible,\nfor the most efficient and natural indirection through the indexes.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Sequential", Doc: "Sequential sets Indexes to nil, resulting in sequential row-wise access into tensor.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "ExcludeMissing", Doc: "ExcludeMissing deletes indexes where the values are missing, as indicated by NaN.\nUses first cell of higher dimensional data.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}, {Name: "FilterString", Doc: "FilterString filters the indexes using string values compared to given\nstring. Includes rows with matching values unless exclude is set.\nIf contains, only checks if row contains string; if ignoreCase, ignores case.\nUse the named const args [Include], [Exclude], [Contains], [Equals],\n[IgnoreCase], [UseCase] for greater clarity.\nUses first cell of higher dimensional data.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"str", "exclude", "contains", "ignoreCase"}}, {Name: "AddRows", Doc: "AddRows adds n rows to end of underlying Tensor, and to the indexes in this view", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"n"}}}, Fields: []types.Field{{Name: "Tensor", Doc: "Tensor that we are an indexed view onto."}, {Name: "Indexes", Doc: "Indexes are the indexes into Tensor rows, with nil = sequential.\nOnly set if order is different from default sequential order.\nUse the Index() method for nil-aware logic."}}})

var _ = types.AddType(&types.Type{Name: "cogentcore.org/core/tensor.Sliced", IDName: "sliced", Doc: "Sliced is a fully indexed wrapper around another [Tensor] that provides a\nre-sliced view onto the Tensor defined by the set of [Sliced.Indexes],\nfor each dimension (must have at least 1 per dimension).\nThus, every dimension can be transformed in arbitrary ways relative\nto the original tensor. There is some additional cost for every\naccess operation associated with the additional indexed indirection.\nSee also [Rows] for a version that only indexes the outermost row dimension,\nwhich is much more efficient for this common use-case.\nTo produce a new concrete [Values] that has raw data actually organized according\nto the indexed order (i.e., the copy function of numpy), call [Sliced.AsValues].", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Methods: []types.Method{{Name: "Sequential", Doc: "Sequential sets all Indexes to nil, resulting in full sequential access into tensor.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}}}, Fields: []types.Field{{Name: "Tensor", Doc: "Tensor that we are an indexed view onto."}, {Name: "Indexes", Doc: "Indexes are the indexes for each dimension, with dimensions as the outer\nslice (enforced to be the same length as the NumDims of the source Tensor),\nand a list of dimension index values (within range of DimSize(d)).\nA nil list of indexes automatically provides a full, sequential view of that\ndimension."}}})
