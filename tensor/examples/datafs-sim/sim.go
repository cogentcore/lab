// Code generated by "goal build"; DO NOT EDIT.
//line sim.goal:1
// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

//go:generate core generate

import (
	"math/rand/v2"

	"cogentcore.org/core/core"
	"cogentcore.org/core/plot"
	"cogentcore.org/core/tensor"
	"cogentcore.org/core/tensor/databrowser"
	"cogentcore.org/core/tensor/datafs"
	"cogentcore.org/core/tensor/stats/stats"
)

// Times are the looping time levels for running and statistics.
type Times int32 //enums:enum

const (
	Trial Times = iota
	Epoch
	Run
)

// LoopPhase is the phase of loop processing for given time.
type LoopPhase int32 //enums:enum

const (
	// Start is the start of the loop: resets accumulated stats, initializes.
	Start LoopPhase = iota

	// Step is each iteration of the loop.
	Step
)

type Sim struct {
	// Root is the root data dir.
	Root *datafs.Data

	// Config has config data.
	Config *datafs.Data

	// Stats has all stats data.
	Stats *datafs.Data

	// Current has current value of all stats
	Current *datafs.Data

	// StatFuncs are statistics functions, per stat, handles everything.
	StatFuncs []func(ltime Times, lphase LoopPhase)

	// Counters are current values of counters: normally in looper.
	Counters [TimesN]int
}

// ConfigAll configures the sim
func (ss *Sim) ConfigAll() {
	ss.Root, _ = datafs.NewDir("Root")
	ss.Config, _ = ss.Root.Mkdir("Config")
	mx := datafs.Value[int](ss.Config, "Max", int(TimesN)).(*tensor.Int)
	mx.Set1D(5, int(Trial))
	mx.Set1D(4, int(Epoch))
	mx.Set1D(3, int(Run))
	// todo: failing - assigns 3 to all
	// # mx[Trial] = 5
	// # mx[Epoch] = 4
	// # mx[Run] = 3
	ss.ConfigStats()
}

func (ss *Sim) AddStat(f func(ltime Times, lphase LoopPhase)) {
	ss.StatFuncs = append(ss.StatFuncs, f)
}

func (ss *Sim) RunStats(ltime Times, lphase LoopPhase) {
	for _, sf := range ss.StatFuncs {
		sf(ltime, lphase)
	}
}

func (ss *Sim) ConfigStats() {
	ss.Stats, _ = ss.Root.Mkdir("Stats")
	ss.Current, _ = ss.Stats.Mkdir("Current")
	ctrs := []Times{Run, Epoch, Trial}
	for _, ctr := range ctrs {
		ss.AddStat(func(ltime Times, lphase LoopPhase) {
			if ltime > ctr { // don't record counter for time above it
				return
			}
			name := ctr.String() // name of stat = counter
			timeDir := ss.Stats.RecycleDir(ltime.String())
			tsr := datafs.Value[int](timeDir, name)
			if lphase == Start {
				tsr.SetNumRows(0)
				if ps := plot.GetStylersFrom(tsr); ps == nil {
					ps.Add(func(s *plot.Style) {
						s.Range.SetMin(0)
					})
					plot.SetStylersTo(tsr, ps)
				}
				return
			}
			ctv := ss.Counters[ctr]
			datafs.Scalar[int](ss.Current, name).SetInt1D(ctv, 0)
			tsr.AppendRowInt(ctv)
		})
	}
	// note: it is essential to only have 1 per func
	// so generic names can be used for everything.
	ss.AddStat(func(ltime Times, lphase LoopPhase) {
		name := "SSE"
		timeDir := ss.Stats.RecycleDir(ltime.String())
		tsr := datafs.Value[float64](timeDir, name)
		if lphase == Start {
			tsr.SetNumRows(0)
			if ps := plot.GetStylersFrom(tsr); ps == nil {
				ps.Add(func(s *plot.Style) {
					s.Range.SetMin(0).SetMax(1)
					s.On = true
				})
				plot.SetStylersTo(tsr, ps)
			}
			return
		}
		switch ltime {
		case Trial:
			stat := rand.Float64()
			datafs.Scalar[float64](ss.Current, name).SetFloat(stat, 0)
			tsr.AppendRowFloat(stat)
		case Epoch:
			subd := ss.Stats.RecycleDir((ltime - 1).String())
			stat := stats.StatMean.Call(subd.Value(name))
			tsr.AppendRow(stat)
		case Run:
			subd := ss.Stats.RecycleDir((ltime - 1).String())
			stat := stats.StatMean.Call(subd.Value(name))
			tsr.AppendRow(stat)
		}
	})
	ss.AddStat(func(ltime Times, lphase LoopPhase) {
		name := "Err"
		timeDir := ss.Stats.RecycleDir(ltime.String())
		tsr := datafs.Value[float64](timeDir, name)
		if lphase == Start {
			tsr.SetNumRows(0)
			if ps := plot.GetStylersFrom(tsr); ps == nil {
				ps.Add(func(s *plot.Style) {
					s.Range.SetMin(0).SetMax(1)
					s.On = true
				})
				plot.SetStylersTo(tsr, ps)
			}
			return
		}
		switch ltime {
		case Trial:
			sse := ss.Current.Item("SSE").AsFloat64()
			stat := 1.0
			if sse < 0.5 {
				stat = 0
			}
			datafs.Scalar[float64](ss.Current, name).SetFloat(stat, 0)
			tsr.AppendRowFloat(stat)
		case Epoch:
			subd := ss.Stats.RecycleDir((ltime - 1).String())
			stat := stats.StatMean.Call(subd.Value(name))
			tsr.AppendRow(stat)
		case Run:
			subd := ss.Stats.RecycleDir((ltime - 1).String())
			stat := stats.StatMean.Call(subd.Value(name))
			tsr.AppendRow(stat)
		}
	})
}

func (ss *Sim) Run() {
	mx := ss.Config.Value("Max").(*tensor.Int)
	nrun := mx.Value1D(int(Run))
	nepc := mx.Value1D(int(Epoch))
	ntrl := mx.Value1D(int(Trial))
	ss.RunStats(Run, Start)
	for run := range nrun {
		ss.Counters[Run] = run
		ss.RunStats(Epoch, Start)
		for epc := range nepc {
			ss.Counters[Epoch] = epc
			ss.RunStats(Trial, Start)
			for trl := range ntrl {
				ss.Counters[Trial] = trl
				ss.RunStats(Trial, Step)
			}
			ss.RunStats(Epoch, Step)
		}
		ss.RunStats(Run, Step)
	}
	// todo: could do final analysis here
	// alldt := ss.Logs.Item("AllTrials").GetDirTable(nil)
	// dir, _ := ss.Logs.Mkdir("Stats")
	// stats.TableGroups(dir, alldt, "Run", "Epoch", "Trial")
	// sts := []string{"SSE", "AvgSSE", "TrlErr"}
	// stats.TableGroupStats(dir, stats.StatMean, alldt, sts...)
	// stats.TableGroupStats(dir, stats.StatSem, alldt, sts...)
}

func main() {
	ss := &Sim{}
	ss.ConfigAll()
	ss.Run()

	databrowser.NewBrowserWindow(ss.Root, "Root")
	core.Wait()
}
