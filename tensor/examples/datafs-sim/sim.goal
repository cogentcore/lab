// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

//go:generate core generate

import (
	"math/rand/v2"

	"cogentcore.org/core/core"
	"cogentcore.org/core/plot"
	"cogentcore.org/core/tensor"
	"cogentcore.org/core/tensor/databrowser"
	"cogentcore.org/core/tensor/datafs"
	"cogentcore.org/core/tensor/stats/stats"
)

type Times int32 //enums:enum

const (
	Trial Times = iota
	Epoch
	Run
)

// LoopPhase is the phase of loop processing for given time.
type LoopPhase int32 //enums:enum

const (
	// Start is the start of the loop.
	Start LoopPhase = iota

	// Step is at each iteration of the loop.
	Step

	// End is at the end of the loop, after all iterations.
	// This is only called for the outer-most loop, because all others
	// are synonymous with Step at the next higher level.
	End
)

type Sim struct {
	// Root is the root data dir.
	Root *datafs.Data

	// Config has config data.
	Config *datafs.Data

	// Stats has all stats data.
	Stats *datafs.Data

	// Current has current value of all stats
	Current *datafs.Data

	// StatFuncs are statistics functions, per stat, handles everything.
	StatFuncs []func(tm Times, lp LoopPhase)

	// Counters are current values of counters: normally in looper.
	Counters [TimesN]int
}

// ConfigAll configures the sim
func (ss *Sim) ConfigAll() {
	ss.Root, _ = datafs.NewDir("Root")
	ss.Config, _ = ss.Root.Mkdir("Config")
	mx := datafs.Value[int](ss.Config, "Max", int(TimesN)).(*tensor.Int)
	mx.Set1D(5, int(Trial))
	mx.Set1D(4, int(Epoch))
	mx.Set1D(3, int(Run))
	// todo: failing - assigns 3 to all
	// # mx[Trial] = 5
	// # mx[Epoch] = 4
	// # mx[Run] = 3
	ss.ConfigStats()
}

func (ss *Sim) AddStat(f func(tm Times, lp LoopPhase)) {
	ss.StatFuncs = append(ss.StatFuncs, f)
}

func (ss *Sim) RunStats(tm Times, lp LoopPhase) {
	for _, sf := range ss.StatFuncs {
		sf(tm, lp)
	}
}

func (ss *Sim) ConfigStats() {
	ss.Stats, _ = ss.Root.Mkdir("Stats")
	ss.Current, _ = ss.Stats.Mkdir("Current")
	ctrs := []Times{Run, Epoch, Trial}
	for _, ctr := range ctrs {
		ss.AddStat(func(tm Times, lp LoopPhase) {
			if lp == End || tm > ctr { // don't record counter for time above it
				return
			}
			name := ctr.String()                   // name of stat = counter
			td := ss.Stats.RecycleDir(tm.String()) // log for tm time
			tv := datafs.Value[int](td, name)
			if lp == Start {
				tv.SetNumRows(0)
				if ps := plot.GetStylersFrom(tv); ps == nil {
					ps.Add(func(s *plot.Style) {
						s.Range.SetMin(0)
					})
					plot.SetStylersTo(tv, ps)
				}
				return
			}
			ctv := ss.Counters[ctr]
			datafs.Scalar[int](ss.Current, name).SetInt1D(ctv, 0)
			tv.AppendRow(tensor.NewIntScalar(ctv))
		})
	}
	// note: it is essential to only have 1 per func
	// so generic names can be used for everything.
	ss.AddStat(func(tm Times, lp LoopPhase) {
		if lp == End { // only called for Run; we ignore
			return
		}
		name := "SSE"
		td := ss.Stats.RecycleDir(tm.String())
		tv := datafs.Value[float64](td, name)
		if lp == Start {
			tv.SetNumRows(0)
			if ps := plot.GetStylersFrom(tv); ps == nil {
				ps.Add(func(s *plot.Style) {
					s.Range.SetMin(0).SetMax(1)
					s.On = true
				})
				plot.SetStylersTo(tv, ps)
			}
			return
		}
		switch tm {
		case Trial:
			sv := rand.Float64()
			datafs.Scalar[float64](ss.Current, name).SetFloat(sv, 0)
			tv.AppendRow(tensor.NewFloat64Scalar(sv))
		case Epoch:
			subd := ss.Stats.RecycleDir((tm - 1).String())
			sv := stats.StatMean.Call(subd.Value(name))
			tv.AppendRow(sv)
		case Run:
			subd := ss.Stats.RecycleDir((tm - 1).String())
			sv := stats.StatMean.Call(subd.Value(name))
			tv.AppendRow(sv)
		}
	})
	ss.AddStat(func(tm Times, lp LoopPhase) {
		if lp == End { // only called for Run; we ignore
			return
		}
		name := "Err"
		td := ss.Stats.RecycleDir(tm.String())
		tv := datafs.Value[float64](td, name)
		if lp == Start {
			tv.SetNumRows(0)
			if ps := plot.GetStylersFrom(tv); ps == nil {
				ps.Add(func(s *plot.Style) {
					s.Range.SetMin(0).SetMax(1)
					s.On = true
				})
				plot.SetStylersTo(tv, ps)
			}
			return
		}
		switch tm {
		case Trial:
			sse := ss.Current.Item("SSE").AsFloat64()
			sv := 1.0
			if sse < 0.5 {
				sv = 0
			}
			datafs.Scalar[float64](ss.Current, name).SetFloat(sv, 0)
			tv.AppendRow(tensor.NewFloat64Scalar(sv))
		case Epoch:
			subd := ss.Stats.RecycleDir((tm - 1).String())
			sv := stats.StatMean.Call(subd.Value(name))
			tv.AppendRow(sv)
		case Run:
			subd := ss.Stats.RecycleDir((tm - 1).String())
			sv := stats.StatMean.Call(subd.Value(name))
			tv.AppendRow(sv)
		}
	})
}

func (ss *Sim) Run() {
	mx := ss.Config.Value("Max").(*tensor.Int)
	nrun := mx.Value1D(int(Run))
	nepc := mx.Value1D(int(Epoch))
	ntrl := mx.Value1D(int(Trial))
	ss.RunStats(Run, Start)
	for run := range nrun {
		ss.Counters[Run] = run
		ss.RunStats(Epoch, Start)
		for epc := range nepc {
			ss.Counters[Epoch] = epc
			ss.RunStats(Trial, Start)
			for trl := range ntrl {
				ss.Counters[Trial] = trl
				ss.RunStats(Trial, Step)
			}
			ss.RunStats(Epoch, Step)
		}
		ss.RunStats(Run, Step)
	}
	ss.RunStats(Run, End)
	// alldt := ss.Logs.Item("AllTrials").GetDirTable(nil)
	// dir, _ := ss.Logs.Mkdir("Stats")
	// stats.TableGroups(dir, alldt, "Run", "Epoch", "Trial")
	// sts := []string{"SSE", "AvgSSE", "TrlErr"}
	// stats.TableGroupStats(dir, stats.StatMean, alldt, sts...)
	// stats.TableGroupStats(dir, stats.StatSem, alldt, sts...)
}

func main() {
	ss := &Sim{}
	ss.ConfigAll()
	ss.Run()

	databrowser.NewBrowserWindow(ss.Root, "Root")
	core.Wait()
}
