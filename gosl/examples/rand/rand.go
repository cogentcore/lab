// Code generated by "goal build"; DO NOT EDIT.
//
//line rand.goal:1
package main

import (
	"fmt"

	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slrand"
	"cogentcore.org/lab/tensor"
)

//gosl:start

//gosl:vars
var (
	//gosl:read-only
	Seed []Seeds

	// Floats has random float values: [idx][6]
	//
	//gosl:dims 2
	Floats *tensor.Float32

	// Uints has random uint32 values: [idx][2]
	//
	//gosl:dims 2
	Uints *tensor.Uint32
)

type Seeds struct {
	Seed      uint64
	pad, pad1 int32
}

const (
	FloatX int = iota
	FloatY
	Float11X
	Float11Y
	GaussX
	GaussY
	NVars
)

// RndGen calls random function calls to test generator.
// Note that the counter to the outer-most computation function
// is passed by *value*, so the same counter goes to each element
// as it is computed, but within this scope, counter is passed by
// reference (as a pointer) so subsequent calls get a new counter value.
// The counter should be incremented by the number of random calls
// outside of the overall update function.
func RndGen(counter uint64, idx uint32) {
	uints := slrand.Uint32Vec2(counter, uint32(0), idx)
	floats := slrand.Float32Vec2(counter, uint32(1), idx)
	floats11 := slrand.Float32Range11Vec2(counter, uint32(2), idx)
	gauss := slrand.Float32NormVec2(counter, uint32(3), idx)
	Uints.Set(uints.X, int(idx), int(0))
	Uints.Set(uints.Y, int(idx), int(1))
	Floats.Set(floats.X, int(idx), int(FloatX))
	Floats.Set(floats.Y, int(idx), int(FloatY))
	Floats.Set(floats11.X, int(idx), int(Float11X))
	Floats.Set(floats11.Y, int(idx), int(Float11Y))
	Floats.Set(gauss.X, int(idx), int(GaussX))
	Floats.Set(gauss.Y, int(idx), int(GaussY))
}

func Compute(i uint32) { //gosl:kernel
	// note: this should have a bounds check here on i -- can be larger than Floats
	RndGen(Seed[0].Seed, i)
}

//gosl:end

const Tol = 1.0e-4 // fails at lower tol eventually -- -6 works for many

func FloatSame(f1, f2 float32) (exact, tol bool) {
	exact = f1 == f2
	tol = math32.Abs(f1-f2) < Tol
	return
}

func Float32Vec2Same(ax, bx, ay, by float32) (exact, tol bool) {
	e1, t1 := FloatSame(ax, bx)
	e2, t2 := FloatSame(ay, by)
	exact = e1 && e2
	tol = t1 && t2
	return
}

// IsSame compares values at two levels: exact and with Tol
func IsSame(au, bu *tensor.Uint32, af, bf *tensor.Float32, idx int) (exact, tol bool) {
	e1 := au.Value(int(idx), int(0)) == bu.Value(int(idx), int(0)) && au.Value(int(idx), int(1)) == bu.Value(int(idx), int(1))
	e2, t2 := Float32Vec2Same(af.Value(int(idx), int(FloatX)), bf.Value(int(idx), int(FloatX)), af.Value(int(idx), int(FloatY)), bf.Value(int(idx), int(FloatY)))
	e3, t3 := Float32Vec2Same(af.Value(int(idx), int(Float11X)), bf.Value(int(idx), int(Float11X)), af.Value(int(idx), int(Float11Y)), bf.Value(int(idx), int(Float11Y)))
	_, t4 := Float32Vec2Same(af.Value(int(idx), int(GaussX)), bf.Value(int(idx), int(GaussX)), af.Value(int(idx), int(GaussY)), bf.Value(int(idx), int(GaussY)))
	exact = e1 && e2 && e3 // skip e4 -- know it isn't
	tol = t2 && t3 && t4
	return
}

func String(u *tensor.Uint32, f *tensor.Float32, idx int) string {
	return fmt.Sprintf("U: %x\t%x\tF: %g\t%g\tF11: %g\t%g\tG: %g\t%g", u.Value(int(idx), int(0)), u.Value(int(idx), int(1)), f.Value(int(idx), int(FloatX)), f.Value(int(idx), int(FloatY)), f.Value(int(idx), int(Float11X)), f.Value(int(idx), int(Float11Y)), f.Value(int(idx), int(GaussX)), f.Value(int(idx), int(GaussY)))
}
