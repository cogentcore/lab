// Code generated by "gosl"; DO NOT EDIT
// kernel: Atomic

// // Params are the parameters for the computation. // 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<ParamStruct>;
// // Data is the data on which the computation operates. // 2D: outer index is data, inner index is: Raw, Integ, Exp vars. // 
@group(1) @binding(0)
var<storage, read_write> Data0: array<f32>;
@group(1) @binding(1)
var<storage, read_write> Data1: array<f32>;
@group(1) @binding(2)
var<storage, read_write> Data2: array<f32>;
@group(1) @binding(3)
var<storage, read_write> Data3: array<f32>;
@group(1) @binding(4)
var<storage, read_write> Data4: array<f32>;
@group(1) @binding(5)
var<storage, read_write> Data5: array<f32>;
@group(1) @binding(6)
var<storage, read_write> Data6: array<f32>;
@group(1) @binding(7)
var<storage, read_write> Data7: array<f32>;
@group(1) @binding(8)
var<storage, read_write> IntData: array<atomic<i32>>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	Atomic(idx);
}

fn DataGet(ix: u32) -> f32 {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		return Data0[ix];
	}
	case u32(1): {
		return Data1[ix - 536870912];
	}
	case u32(2): {
		return Data2[ix - 1073741824];
	}
	case u32(3): {
		return Data3[ix - 1610612736];
	}
	case u32(4): {
		return Data4[ix - 2147483648];
	}
	case u32(5): {
		return Data5[ix - 2684354560];
	}
	case u32(6): {
		return Data6[ix - 3221225472];
	}
	default: {
		return Data7[ix - 3758096384];
	}
	}
}

fn DataSet(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] = vl;
	}
	case u32(1): {
		Data1[ix - 536870912] = vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] = vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] = vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] = vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] = vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] = vl;
	}
	default: {
		Data7[ix - 3758096384] = vl;
	}
	}
}

fn DataSetAdd(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] += vl;
	}
	case u32(1): {
		Data1[ix - 536870912] += vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] += vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] += vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] += vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] += vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] += vl;
	}
	default: {
		Data7[ix - 3758096384] += vl;
	}
	}
}

fn DataSetSub(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] -= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] -= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] -= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] -= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] -= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] -= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] -= vl;
	}
	default: {
		Data7[ix - 3758096384] -= vl;
	}
	}
}

fn DataSetMul(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] *= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] *= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] *= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] *= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] *= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] *= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] *= vl;
	}
	default: {
		Data7[ix - 3758096384] *= vl;
	}
	}
}

fn DataSetDiv(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] /= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] /= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] /= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] /= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] /= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] /= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] /= vl;
	}
	default: {
		Data7[ix - 3758096384] /= vl;
	}
	}
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "compute.go"
const  Raw: i32   = 0;
const  Integ: i32 = 1;
const  Exp: i32 = 2;
const  NVars: i32 = 3;
struct SubStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
}
struct ParamStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
	Sub: SubStruct,
}

//////// import: "atomic.go"
fn Atomic(i: u32) { //gosl:kernel
	atomicAdd(&IntData[Index2D(TensorStrides[10], TensorStrides[11], u32(i), u32(Integ))], 1);
}

//////// import: "math32-fastexp.go"