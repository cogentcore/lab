// Code generated by "gosl"; DO NOT EDIT
// kernel: Compute

// // Params are the parameters for the computation. // 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<ParamStruct>;
// // Data is the data on which the computation operates. // 2D: outer index is data, inner index is: Raw, Integ, Exp vars. // 
@group(1) @binding(0)
var<storage, read_write> Data0: array<f32>;
@group(1) @binding(1)
var<storage, read_write> Data1: array<f32>;
@group(1) @binding(2)
var<storage, read_write> Data2: array<f32>;
@group(1) @binding(3)
var<storage, read_write> Data3: array<f32>;
@group(1) @binding(4)
var<storage, read_write> Data4: array<f32>;
@group(1) @binding(5)
var<storage, read_write> Data5: array<f32>;
@group(1) @binding(6)
var<storage, read_write> Data6: array<f32>;
@group(1) @binding(7)
var<storage, read_write> Data7: array<f32>;
@group(1) @binding(8)
var<storage, read_write> IntData: array<i32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	Compute(idx);
}

fn DataGet(ix: u32) -> f32 {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		return Data0[ix];
	}
	case u32(1): {
		return Data1[ix - 536870912];
	}
	case u32(2): {
		return Data2[ix - 1073741824];
	}
	case u32(3): {
		return Data3[ix - 1610612736];
	}
	case u32(4): {
		return Data4[ix - 2147483648];
	}
	case u32(5): {
		return Data5[ix - 2684354560];
	}
	case u32(6): {
		return Data6[ix - 3221225472];
	}
	default: {
		return Data7[ix - 3758096384];
	}
	}
}

fn DataSet(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] = vl;
	}
	case u32(1): {
		Data1[ix - 536870912] = vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] = vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] = vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] = vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] = vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] = vl;
	}
	default: {
		Data7[ix - 3758096384] = vl;
	}
	}
}

fn DataSetAdd(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] += vl;
	}
	case u32(1): {
		Data1[ix - 536870912] += vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] += vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] += vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] += vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] += vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] += vl;
	}
	default: {
		Data7[ix - 3758096384] += vl;
	}
	}
}

fn DataSetSub(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] -= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] -= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] -= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] -= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] -= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] -= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] -= vl;
	}
	default: {
		Data7[ix - 3758096384] -= vl;
	}
	}
}

fn DataSetMul(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] *= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] *= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] *= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] *= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] *= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] *= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] *= vl;
	}
	default: {
		Data7[ix - 3758096384] *= vl;
	}
	}
}

fn DataSetDiv(vl: f32, ix: u32) {
	let ii = ix / 536870912;
	switch ii {
	case u32(0): {
		Data0[ix] /= vl;
	}
	case u32(1): {
		Data1[ix - 536870912] /= vl;
	}
	case u32(2): {
		Data2[ix - 1073741824] /= vl;
	}
	case u32(3): {
		Data3[ix - 1610612736] /= vl;
	}
	case u32(4): {
		Data4[ix - 2147483648] /= vl;
	}
	case u32(5): {
		Data5[ix - 2684354560] /= vl;
	}
	case u32(6): {
		Data6[ix - 3221225472] /= vl;
	}
	default: {
		Data7[ix - 3758096384] /= vl;
	}
	}
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "compute.go"
const  Raw: i32   = 0;
const  Integ: i32 = 1;
const  Exp: i32 = 2;
const  NVars: i32 = 3;
struct SubStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
}
struct ParamStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
	Sub: SubStruct,
}
fn SubStruct_IntegFromRaw(ps: SubStruct, idx: i32) {
	var integ = DataGet(Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ)));
	integ += ps.Dt * (DataGet(Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Raw))) - integ);
	DataSet(integ, Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ)));
	DataSet(FastExp(-integ), Index2D(TensorStrides[0],
	TensorStrides[1], u32(idx), u32(Exp)));
}
fn ParamStruct_IntegFromRaw(ps: ParamStruct, idx: i32) {
	var integ = DataGet(Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ)));
	integ += ps.Dt * (DataGet(Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Raw))) - integ);
	DataSet(integ, Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ)));
	DataSet(FastExp(-integ), Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Exp)));
	SubStruct_IntegFromRaw(ps.Sub, idx);
}
fn Compute(i: u32) { //gosl:kernel
	let params=Params[0]; ParamStruct_IntegFromRaw(params, i32(i));
}

//////// import: "atomic.go"

//////// import: "math32-fastexp.go"
fn FastExp(x: f32) -> f32 {
	if (x <= -88.02969) { // this doesn't add anything and -exp is main use-case anyway
		return f32(0.0);
	}
	var i = i32(12102203*x) + i32(127)*(i32(1)<<23);
	var m = (i >> 7) & 0xFFFF; // copy mantissa
	i += (((((((((((3537 * m) >> 16) + 13668) * m) >> 18) + 15817) * m) >> 14) - 80470) * m) >> 11);return bitcast<f32>(u32(i));
}