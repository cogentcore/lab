// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gotosl

import (
	"fmt"
	"strings"
)

// GenKernelHeader returns the novel generated WGSL kernel code
// for given kernel, which goes at the top of the resulting file.
func (st *State) GenKernelHeader(sy *System, kn *Kernel, avars map[string]*Var) string {
	var b strings.Builder
	b.WriteString("// Code generated by \"gosl\"; DO NOT EDIT\n")
	b.WriteString("// kernel: " + kn.Name + "\n\n")

	for gi, gp := range sy.Groups {
		if gp.Doc != "" {
			b.WriteString("// " + gp.Doc + "\n")
		}
		str := "storage"
		if gp.Uniform {
			str = "uniform"
		}
		viOff := 0
		if gi == 0 && sy.NTensors > 0 {
			access := ", read"
			if gp.Uniform {
				access = ""
			}
			viOff = 1
			b.WriteString("@group(0) @binding(0)\n")
			b.WriteString(fmt.Sprintf("var<%s%s> TensorStrides: array<u32>;\n", str, access))
		}
		gidx := viOff
		for _, vr := range gp.Vars {
			access := ", read_write"
			if vr.ReadOnly && !vr.ReadOrWrite {
				access = ", read"
			}
			if gp.Uniform {
				access = ""
			}
			if vr.Doc != "" {
				b.WriteString("// " + vr.Doc + "\n")
			}
			if vr.NBuffs <= 1 {
				b.WriteString(fmt.Sprintf("@group(%d) @binding(%d)\n", gi, gidx))
				b.WriteString(fmt.Sprintf("var<%s%s> %s: ", str, access, vr.Name))
				if _, ok := avars[vr.Name]; ok {
					b.WriteString(fmt.Sprintf("array<atomic<%s>>;\n", vr.SLType()))
				} else {
					b.WriteString(fmt.Sprintf("array<%s>;\n", vr.SLType()))
				}
				gidx++
				continue
			}
			for bi := range vr.NBuffs {
				b.WriteString(fmt.Sprintf("@group(%d) @binding(%d)\n", gi, gidx))
				b.WriteString(fmt.Sprintf("var<%s%s> %s%d: ", str, access, vr.Name, bi))
				b.WriteString(fmt.Sprintf("array<%s>;\n", vr.SLType()))
				gidx++
			}
		}
	}

	b.WriteString("\nalias GPUVars = i32;\n\n") // gets included when iteratively processing enumgen.go

	b.WriteString("@compute @workgroup_size(64, 1, 1)\n")
	b.WriteString("fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {\n")
	b.WriteString("\tlet idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;\n")
	b.WriteString(fmt.Sprintf("\t%s(idx);\n", kn.Name))
	b.WriteString("}\n")
	b.WriteString(st.GenTensorFuncs(sy))
	return b.String()
}

// GenTensorFuncs returns the generated WGSL code
// for indexing the tensors in given system.
func (st *State) GenTensorFuncs(sy *System) string {
	var b strings.Builder

	done := make(map[string]bool)

	for _, gp := range sy.Groups {
		for _, vr := range gp.Vars {
			if !vr.Tensor {
				continue
			}
			if vr.NBuffs > 1 {
				b.WriteString(st.GenNBuffFuncs(sy, vr))
			}

			fn := vr.IndexFunc()
			if _, ok := done[fn]; ok {
				continue
			}
			done[fn] = true
			typ := "u32"
			b.WriteString("\nfn " + fn + "(")
			nd := vr.TensorDims
			for d := range nd {
				b.WriteString(fmt.Sprintf("s%d: %s, ", d, typ))
			}
			for d := range nd {
				b.WriteString(fmt.Sprintf("i%d: u32", d))
				if d < nd-1 {
					b.WriteString(", ")
				}
			}
			b.WriteString(") -> u32 {\n\treturn ")
			for d := range nd {
				b.WriteString(fmt.Sprintf("s%d * i%d", d, d))
				if d < nd-1 {
					b.WriteString(" + ")
				}
			}
			b.WriteString(";\n}\n")
		}
	}
	return b.String()
}

// GenNBuffFuncs returns the generated WGSL code
// for accessing data in multi-buffer variables.
func (st *State) GenNBuffFuncs(sy *System, vr *Var) string {
	var b strings.Builder
	b.WriteString("\nfn " + vr.Name + "Get(ix: u32) -> " + vr.SLType() + " {\n")
	bsz := st.Config.MaxBufferSize / 4 // assume 4 bytes per
	b.WriteString(fmt.Sprintf("\tlet ii = ix / %d;\n", bsz))
	b.WriteString("\tswitch ii {\n")
	for bi := range vr.NBuffs {
		if bi == vr.NBuffs-1 {
			b.WriteString("\tdefault: {\n")
		} else {
			b.WriteString(fmt.Sprintf("\tcase u32(%d): {\n", bi))
		}
		if bi > 0 {
			b.WriteString(fmt.Sprintf("\t\treturn %s%d[ix - %d];\n", vr.Name, bi, bsz*uint32(bi)))
		} else {
			b.WriteString(fmt.Sprintf("\t\treturn %s%d[ix];\n", vr.Name, bi))
		}
		b.WriteString("\t}\n")
	}
	b.WriteString("\t}\n}\n")

	methNames := []string{"Set", "SetAdd", "SetSub", "SetMul", "SetDiv"}
	methOps := []string{"=", "+=", "-=", "*=", "/="}
	for mi, mn := range methNames {
		mop := methOps[mi]
		b.WriteString("\nfn " + vr.Name + mn + "(vl: " + vr.SLType() + ", ix: u32) {\n")
		b.WriteString(fmt.Sprintf("\tlet ii = ix / %d;\n", bsz))
		b.WriteString("\tswitch ii {\n")
		for bi := range vr.NBuffs {
			if bi == vr.NBuffs-1 {
				b.WriteString("\tdefault: {\n")
			} else {
				b.WriteString(fmt.Sprintf("\tcase u32(%d): {\n", bi))
			}
			if bi > 0 {
				b.WriteString(fmt.Sprintf("\t\t%s%d[ix - %d] %s vl;\n", vr.Name, bi, bsz*uint32(bi), mop))
			} else {
				b.WriteString(fmt.Sprintf("\t\t%s%d[ix] %s vl;\n", vr.Name, bi, mop))
			}
			b.WriteString("\t}\n")
		}
		b.WriteString("\t}\n}\n")
	}

	return b.String()
}
