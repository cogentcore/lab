// Code generated by "gosl"; DO NOT EDIT
// kernel: Compute

// // Params are the parameters for the computation. 
@group(0) @binding(0)
var<storage, read> Params: array<ParamStruct>;
@group(0) @binding(1)
var<storage, read_write> Data: array<DataStruct>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) idx: vec3<u32>) {
	Compute(idx.x);
}


//////// import: "basic.go"
alias NeuronFlags = i32;
const  NeuronOff: NeuronFlags = 0x01;
const  NeuronHasExt: NeuronFlags = 0x02; // note: 1<<2 does NOT work
const  NeuronHasTarg: NeuronFlags = 0x04;
const  NeuronHasCmpr: NeuronFlags = 0x08;
alias Modes = i32;
const  NoEvalMode: Modes = 0;
const  AllModes: Modes = 1;
const  Train: Modes = 2;
const  Test: Modes = 3;
const testSlice = array(NoEvalMode, AllModes, Train, Test);
struct DataStruct {
	Raw: f32,
	Integ: f32,
	Exp: f32,
	Int: i32,
}
struct SubParamStruct {
	A: f32,
	B: f32,
	C: f32,
	D: f32,
}
fn SubParamStruct_Sum(sp: ptr<function,SubParamStruct>) -> f32 {
	return (*sp).A + (*sp).B + (*sp).C + (*sp).D;
}
fn SubParamStruct_SumPlus(sp: ptr<function,SubParamStruct>, extra: f32) -> f32 {
	return SubParamStruct_Sum(sp) + extra;
}
struct ParamStruct {
	Tau: f32,
	Dt:     f32,
	Option: i32, // note: standard bool doesn't work
	pad: f32, // comment this out to trigger alignment warning
	Subs: SubParamStruct,
}
fn ParamStruct_IntegFromRaw(ps: ptr<function,ParamStruct>, ds: ptr<function,DataStruct>) -> f32 {
	var newVal = (*ps).Dt * ((*ds).Raw - (*ds).Integ);
	if (newVal < -10 || (*ps).Option == 1) {
		newVal = f32(-10);
	}
	(*ds).Integ += newVal;
	(*ds).Exp = exp(-(*ds).Integ);
	var a: f32;
	ParamStruct_AnotherMeth(ps, ds, &a);return (*ds).Exp;
}
fn ParamStruct_AnotherMeth(ps: ptr<function,ParamStruct>, ds: ptr<function,DataStruct>, ptrarg: ptr<function,f32>) {
	for (var i = 0; i < 10; i++) {
		(*ds).Integ *= f32(0.99);
	}
	var flag: NeuronFlags;
	flag &= ~NeuronHasExt; // clear flag -- op doesn't exist in C
	var mode = Test;
	switch (mode) { // note: no fallthrough!
	case Test: {
		var ab = f32(42);
		(*ds).Exp /= ab;
	}
	case Train: {
		var ab = f32(.5);
		(*ds).Exp *= ab;
	}
	default: {
		var ab = f32(1);
		(*ds).Exp *= ab;
	}
	}
	var a: f32;
	var b: f32;
	b = f32(42);
	a = SubParamStruct_Sum(&(*ps).Subs);
	(*ds).Exp = SubParamStruct_SumPlus(&(*ps).Subs, b);
	(*ds).Integ = a;
	for (var i=0; i<10; i++) {
		(*ds).Exp *= f32(0.99);
	}
	*ptrarg = f32(-1);
}
fn Compute(i: u32) { //gosl:kernel
	var data = Data[i];
	var params=Params[0]; ParamStruct_IntegFromRaw(&params, &data);
	Data[i] = data;
}