// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gotosl

import (
	"bytes"
	"fmt"
	"path/filepath"
	"strings"
)

// GenKernel generates and writes the WGSL kernel code for given kernel
func (st *State) GenKernel(sy *System, kn *Kernel) {
	hdr := st.GenKernelHeader(sy, kn)

	lines := bytes.Split([]byte(hdr), []byte("\n"))
	for _, im := range st.SLImportFiles {
		lines = append(lines, []byte(""))
		lines = append(lines, []byte(fmt.Sprintf("///////////// import: %q", im.Name)))
		lines = append(lines, im.Lines...)
	}
	kn.Lines = lines
	kfn := kn.Name + ".wgsl"
	fn := filepath.Join(st.Config.Output, kfn)
	kn.Filename = fn
	st.WriteFileLines(fn, lines)

	st.CompileFile(kfn)
}

// GenKernelHeader returns the novel generated WGSL kernel code
// for given kernel, which goes at the top of the resulting file.
func (st *State) GenKernelHeader(sy *System, kn *Kernel) string {
	var b strings.Builder
	b.WriteString("// Code generated by \"gosl\"; DO NOT EDIT\n")
	b.WriteString("// kernel: " + kn.Name + "\n\n")

	for gi, gp := range sy.Groups {
		if gp.Doc != "" {
			b.WriteString("// " + gp.Doc + "\n")
		}
		str := "storage, read_write"
		if gp.Uniform {
			str = "uniform"
		}
		for vi, vr := range gp.Vars {
			if vr.Doc != "" {
				b.WriteString("// " + vr.Doc + "\n")
			}
			b.WriteString(fmt.Sprintf("@group(%d) @binding(%d)\n", gi, vi))
			b.WriteString(fmt.Sprintf("var<%s> %s: ", str, vr.Name))
			if vr.Type[:2] == "[]" {
				b.WriteString(fmt.Sprintf("array<%s>;\n", vr.Type[2:]))
			} else {
				// todo: tensor type
			}
		}
	}

	b.WriteString("\n")
	b.WriteString("@compute @workgroup_size(64, 1, 1)\n")
	// todo: conditional on different index dimensionality
	b.WriteString("fn main(@builtin(global_invocation_id) idx: vec3<u32>) {\n")
	b.WriteString(fmt.Sprintf("\t%s(idx.x);\n", kn.Name))
	b.WriteString("}\n")
	return b.String()
}
