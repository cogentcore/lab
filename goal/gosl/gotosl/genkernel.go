// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package gotosl

import (
	"fmt"
	"strings"
)

// GenKernelHeader returns the novel generated WGSL kernel code
// for given kernel, which goes at the top of the resulting file.
func (st *State) GenKernelHeader(sy *System, kn *Kernel, avars map[string]*Var) string {
	var b strings.Builder
	b.WriteString("// Code generated by \"gosl\"; DO NOT EDIT\n")
	b.WriteString("// kernel: " + kn.Name + "\n\n")

	for gi, gp := range sy.Groups {
		if gp.Doc != "" {
			b.WriteString("// " + gp.Doc + "\n")
		}
		str := "storage"
		if gp.Uniform {
			str = "uniform"
		}
		viOff := 0
		if gi == 0 && sy.NTensors > 0 {
			access := ", read"
			if gp.Uniform {
				access = ""
			}
			viOff = 1
			b.WriteString("@group(0) @binding(0)\n")
			b.WriteString(fmt.Sprintf("var<%s%s> TensorStrides: array<u32>;\n", str, access))
		}
		for vi, vr := range gp.Vars {
			access := ", read_write"
			if vr.ReadOnly {
				access = ", read"
			}
			if gp.Uniform {
				access = ""
			}
			if vr.Doc != "" {
				b.WriteString("// " + vr.Doc + "\n")
			}
			b.WriteString(fmt.Sprintf("@group(%d) @binding(%d)\n", gi, vi+viOff))
			b.WriteString(fmt.Sprintf("var<%s%s> %s: ", str, access, vr.Name))
			if _, ok := avars[vr.Name]; ok {
				b.WriteString(fmt.Sprintf("array<atomic<%s>>;\n", vr.SLType()))
			} else {
				b.WriteString(fmt.Sprintf("array<%s>;\n", vr.SLType()))
			}
		}
	}

	b.WriteString("\nalias GPUVars = i32;\n\n") // gets included when iteratively processing enumgen.go

	b.WriteString("@compute @workgroup_size(64, 1, 1)\n")
	b.WriteString("fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {\n")
	b.WriteString("\tlet idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;\n")
	b.WriteString(fmt.Sprintf("\t%s(idx);\n", kn.Name))
	b.WriteString("}\n")
	b.WriteString(st.GenTensorFuncs(sy))
	return b.String()
}

// GenTensorFuncs returns the generated WGSL code
// for indexing the tensors in given system.
func (st *State) GenTensorFuncs(sy *System) string {
	var b strings.Builder

	done := make(map[string]bool)

	for _, gp := range sy.Groups {
		for _, vr := range gp.Vars {
			if !vr.Tensor {
				continue
			}
			fn := vr.IndexFunc()
			if _, ok := done[fn]; ok {
				continue
			}
			done[fn] = true
			typ := "u32"
			b.WriteString("\nfn " + fn + "(")
			nd := vr.TensorDims
			for d := range nd {
				b.WriteString(fmt.Sprintf("s%d: %s, ", d, typ))
			}
			for d := range nd {
				b.WriteString(fmt.Sprintf("i%d: u32", d))
				if d < nd-1 {
					b.WriteString(", ")
				}
			}
			b.WriteString(") -> u32 {\n\treturn ")
			for d := range nd {
				b.WriteString(fmt.Sprintf("s%d * i%d", d, d))
				if d < nd-1 {
					b.WriteString(" + ")
				}
			}
			b.WriteString(";\n}\n")
		}
	}
	return b.String()
}
