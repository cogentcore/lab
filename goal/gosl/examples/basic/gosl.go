// Code generated by "gosl"; DO NOT EDIT

package main

import (
	"embed"
	"unsafe"

	"cogentcore.org/core/gpu"
)

//go:embed shaders/*.wgsl
var shaders embed.FS

// GPU is the compute gpu device
var ComputeGPU *gpu.GPU

// UseGPU indicates whether to use GPU vs. CPU.
var UseGPU bool

var GPUSystem *gpu.ComputeSystem

// GPUVars is an enum for GPU variables, for specifying what to sync.
type GPUVars int32 //enums:enum

const (
	ParamsVar GPUVars = 0
	DataVar   GPUVars = 1
)

// GPUInit initializes the GPU compute system
// Configuring Systems, variables and kernels.
func GPUInit() {
	gp := gpu.NewComputeGPU()
	ComputeGPU = gp
	{
		sy := gpu.NewComputeSystem(gp, "Default")
		GPUSystem = sy
		gpu.NewComputePipelineShaderFS(shaders, "shaders/Compute.wgsl", sy)
		vars := sy.Vars()
		{
			sgp := vars.AddGroup(gpu.Storage)
			sgp.AddStruct("Params", int(unsafe.Sizeof(ParamStruct{})), len(Params), gpu.ComputeShader)
			sgp.AddStruct("Data", int(unsafe.Sizeof(DataStruct{})), len(Data), gpu.ComputeShader)
			sgp.SetNValues(1)
		}
		sy.Config()
	}
}

// GPURelease releases the GPU compute system.
func GPURelease() {
	GPUSystem.Release()
	ComputeGPU.Release()
}

// RunCompute runs the Compute kernel with given number of items,
// on either the CPU or GPU depending on the UseGPU.
// Pass *Var variable names to sync those variables back from the GPU
// after running (irrelevant for CPU).
func RunCompute(n int, syncVars ...GPUVars) {
	if UseGPU {
		RunComputeGPU(n, syncVars...)
	} else {
		RunComputeCPU(n)
	}
}

// RunComputeGPU runs the Compute kernel on the GPU.
func RunComputeGPU(n int, syncVars ...GPUVars) {
	sy := GPUSystem
	pl := sy.ComputePipelines["Compute"]
	ce, _ := sy.BeginComputePass()
	pl.Dispatch1D(ce, n, 64)
	ce.End()
	ReadFromGPU(syncVars...)
	sy.EndComputePass()
	SyncFromGPU(syncVars...)
}

// RunComputeCPU runs the Compute kernel on the CPU.
func RunComputeCPU(n int) {
	// todo: need flops, need threaded api -- not tensor
	for i := range n {
		Compute(uint32(i))
	}
}

// ToGPU copies given variables to the GPU for the system.
func ToGPU(vars ...GPUVars) {
	sy := GPUSystem
	syVars := sy.Vars()
	for _, v := range vars {
		switch v {
		case ParamsVar:
			v, _ := syVars.ValueByIndex(0, "Params", 0)
			gpu.SetValueFrom(v, Params)
		case DataVar:
			v, _ := syVars.ValueByIndex(0, "Data", 0)
			gpu.SetValueFrom(v, Data)
		}
	}
}

// ReadFromGPU starts the process of copying vars to the GPU.
func ReadFromGPU(vars ...GPUVars) {
	sy := GPUSystem
	syVars := sy.Vars()
	for _, v := range vars {
		switch v {
		case ParamsVar:
			v, _ := syVars.ValueByIndex(0, "Params", 0)
			v.GPUToRead(sy.CommandEncoder)
		case DataVar:
			v, _ := syVars.ValueByIndex(0, "Data", 0)
			v.GPUToRead(sy.CommandEncoder)
		}
	}
}

// SyncFromGPU synchronizes vars from the GPU to the actual variable.
func SyncFromGPU(vars ...GPUVars) {
	sy := GPUSystem
	syVars := sy.Vars()
	for _, v := range vars {
		switch v {
		case ParamsVar:
			v, _ := syVars.ValueByIndex(0, "Params", 0)
			v.ReadSync()
			gpu.ReadToBytes(v, Params)
		case DataVar:
			v, _ := syVars.ValueByIndex(0, "Data", 0)
			v.ReadSync()
			gpu.ReadToBytes(v, Data)
		}
	}
}
