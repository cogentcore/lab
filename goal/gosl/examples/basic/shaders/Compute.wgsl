// Code generated by "gosl"; DO NOT EDIT
// kernel: Compute

// // Params are the parameters for the computation. // 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<ParamStruct>;
// // Data is the data on which the computation operates. // 2D: outer index is data, inner index is: Raw, Integ, Exp vars. // 
@group(1) @binding(0)
var<storage, read_write> Data: array<f32>;
@group(1) @binding(1)
var<storage, read_write> IntData: array<i32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	Compute(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "compute.go"
const  Raw: i32   = 0;
const  Integ: i32 = 1;
const  Exp: i32 = 2;
const  NVars: i32 = 3;
struct ParamStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
}
fn ParamStruct_IntegFromRaw(ps: ptr<function,ParamStruct>, idx: i32) {
	var integ = Data[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ))];
	integ += (*ps).Dt * (Data[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Raw))] - integ);
	Data[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Integ))] = integ;
	Data[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(Exp))] = FastExp(-integ);
}
fn Compute(i: u32) { //gosl:kernel
	var params = Params[0];
	ParamStruct_IntegFromRaw(&params, i32(i));
}

//////// import: "atomic.go"

//////// import: "math32-fastexp.go"
fn FastExp(x: f32) -> f32 {
	if (x <= -88.02969) { // this doesn't add anything and -exp is main use-case anyway
		return f32(0.0);
	}
	var i = i32(12102203*x) + i32(127)*(i32(1)<<23);
	var m = (i >> 7) & 0xFFFF; // copy mantissa
	i += (((((((((((3537 * m) >> 16) + 13668) * m) >> 18) + 15817) * m) >> 14) - 80470) * m) >> 11);return bitcast<f32>(u32(i));
}