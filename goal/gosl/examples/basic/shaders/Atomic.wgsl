// Code generated by "gosl"; DO NOT EDIT
// kernel: Atomic

// // Params are the parameters for the computation. // 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<ParamStruct>;
// // Data is the data on which the computation operates. // 2D: outer index is data, inner index is: Raw, Integ, Exp vars. // 
@group(1) @binding(0)
var<storage, read_write> Data: array<f32>;
@group(1) @binding(1)
var<storage, read_write> IntData: array<atomic<i32>>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) idx: vec3<u32>) {
	Atomic(idx.x);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "compute.go"
const  Raw: i32   = 0;
const  Integ: i32 = 1;
const  Exp: i32 = 2;
const  NVars: i32 = 3;
struct ParamStruct {
	Tau: f32,
	Dt: f32,
	pad:  f32,
	pad1: f32,
}

//////// import: "atomic.go"
fn Atomic(i: u32) { //gosl:kernel
	atomicAdd(&IntData[Index2D(TensorStrides[10], TensorStrides[11], u32(i), u32(Integ))], 1);
}

//////// import: "math32-fastexp.go"