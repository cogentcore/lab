// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/tensor"
)

//go:generate core generate -add-types -gosl

// World contains and manages all of the physics elements.
type World struct {
	// GPU determines whether to use GPU (else CPU).
	GPU bool

	// Params are global parameters.
	Params []PhysParams

	// Bodies are the rigid body elements (dynamic and static),
	// specifying the constant, non-dynamic properties,
	// which is initial state for dynamics.
	// [body][BodyVarsN]
	Bodies *tensor.Float32 `display:"no-inline"`

	// Joints is a list of permanent joints connecting bodies,
	// which do not change (no dynamic variables).
	// [joint][JointVarsN]
	Joints *tensor.Float32 `display:"no-inline"`

	// JointDoFs is a list of joint DoF parameters, allocated per joint.
	// [dof][JointDoFVars]
	JointDoFs *tensor.Float32 `display:"no-inline"`

	// BodyJoints is a list of joint indexes for each dynamic body, for aggregating.
	// [dyn body][parent, child][Params.BodyJointsMax]
	BodyJoints *tensor.Int32 `display:"no-inline"`

	// BodyCollidePairs are pairs of Body indexes that could potentially collide
	// based on precomputed collision logic, using World, Group, and Joint indexes.
	// [BodyCollidePairsN][2]
	BodyCollidePairs *tensor.Int32

	// Dynamics are the dynamic rigid body elements: these actually move.
	// The first set of variables are for initial values, and the second current.
	// [body][cur/next][DynamicVarsN]
	Dynamics *tensor.Float32 `display:"no-inline"`

	// Contacts are points of contact between bodies.
	// [contact][ContactVarsN]
	Contacts *tensor.Float32 `display:"no-inline"`

	// JointControls are dynamic joint control inputs, per joint DoF
	// (in correspondence with [JointDoFs]). This can be uploaded to the
	// GPU at every step.
	// [dof][JointControlVarsN]
	JointControls *tensor.Float32 `display:"no-inline"`
}

func NewWorld() *World {
	wl := &World{}
	wl.Init()
	return wl
}

// Init makes initial vars.
func (wl *World) Init() {
	wl.Params = make([]PhysParams, 1)
	wl.Params[0].Defaults()
	wl.Bodies = tensor.NewFloat32(0, int(BodyVarsN))
	wl.Joints = tensor.NewFloat32(0, int(JointVarsN))
	wl.JointDoFs = tensor.NewFloat32(0, int(JointDoFVarsN))
	wl.BodyJoints = tensor.NewInt32(0, 2, 2)
	wl.Dynamics = tensor.NewFloat32(0, 2, int(DynamicVarsN))
	wl.Contacts = tensor.NewFloat32(0, int(ContactVarsN))
	wl.JointControls = tensor.NewFloat32(0, int(JointControlVarsN))
	wl.SetAsCurrentVars()
}

// NewBody adds a new body with given parameters. Returns the index.
// Use this for Static elements; NewDynamic for dynamic elements.
func (wl *World) NewBody(shape Shapes, size, pos math32.Vector3, rot math32.Quat) int32 {
	sizes := wl.Bodies.ShapeSizes()
	n := int32(sizes[0])
	wl.Bodies.SetShapeSizes(int(n+1), int(BodyVarsN))
	wl.Params[0].BodiesN = n + 1
	SetBodyShape(n, shape)
	SetBodyDynamic(n, -1)
	SetBodySize(n, size)
	SetBodyPos(n, pos)
	SetBodyQuat(n, rot)
	return n
}

// NewDynamic adds a new dynamic body with given parameters. Returns the index.
func (wl *World) NewDynamic(shape Shapes, mass float32, size, pos math32.Vector3, rot math32.Quat) (bodyIdx, dynIdx int32) {
	bodyIdx = wl.NewBody(shape, size, pos, rot)
	sizes := wl.Dynamics.ShapeSizes()
	dynIdx = int32(sizes[0])
	wl.Dynamics.SetShapeSizes(int(dynIdx+1), 2, int(DynamicVarsN))
	wl.Params[0].DynamicsN = dynIdx + 1
	SetDynamicBody(dynIdx, bodyIdx)
	SetBodyDynamic(bodyIdx, dynIdx)
	wl.SetMass(bodyIdx, shape, size, mass)
	return
}

// SetAsCurrent sets these as the current global values that are
// processed in the code (on the GPU). If this was not the setter of
// the current variables, then the parameter variables are copied up
// to the GPU.
func (wl *World) SetAsCurrent() {
	isCur := (Bodies == wl.Bodies)
	wl.SetAsCurrentVars()
	if GPUInitialized && !isCur {
		wl.ToGPUInfra()
	}
}

// SetAsCurrentVars sets these as the current global values that are
// processed in the code (on the GPU).
func (wl *World) SetAsCurrentVars() {
	Params = wl.Params
	Bodies = wl.Bodies
	Joints = wl.Joints
	BodyJoints = wl.BodyJoints
	JointDoFs = wl.JointDoFs
	Dynamics = wl.Dynamics
	Contacts = wl.Contacts
	JointControls = wl.JointControls
}

// GPUInit initializes the GPU and transfers Infra.
// Should have already called SetAsCurrent (needed for CPU and GPU).
func (wl *World) GPUInit() {
	GPUInit()
	UseGPU = wl.GPU
	wl.ToGPUInfra()
}

// ToGPUInfra copies all the infrastructure for these filters up to
// the GPU. This is done in GPUInit, and if current switched.
func (wl *World) ToGPUInfra() {
	ToGPUTensorStrides()
	ToGPU(ParamsVar, BodiesVar, JointsVar, BodyJointsVar, JointDoFsVar)
}
