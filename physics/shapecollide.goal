// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start

// newton: geometry/kernels.py class GeoData

// GeomData contains all geometric data for narrow-phase collision.
type GeomData struct {
	BodyIdx int32

	Shape Shapes

	// MinSize is the min of the Size dimensions.
	MinSize float32

	// Thickness of shape.
	Thick float32

	// Radius is the effective radius for sphere-like elements (Sphere, Capsule, Cone)
	Radius float32

	Size math32.Vector3

	// World-to-Body transform
	// Position (R) (i.e., BodyPos)
	WbR math32.Vector3
	// Quaternion (Q) (i.e., BodyQuat)
	WbQ math32.Quat

	// Body-to-World transform (inverse)
	// Position (R)
	BwR math32.Vector3
	// Quaternion (Q)
	BwQ math32.Quat
}

func NewGeomData(bi, cni int32, shp Shapes) GeomData {
	var gd GeomData
	gd.BodyIdx = bi
	gd.Shape = shp
	gd.Size = BodySize(bi)
	gd.Thick = Bodies[bi, BodyThick]
	gd.MinSize = min(gd.Size.X, gd.Size.Y)
	gd.MinSize = min(gd.MinSize, gd.Size.Z)
	gd.WbR = BodyDynamicPos(bi, cni)
	gd.WbQ = BodyDynamicQuat(bi, cni)
	var bwR math32.Vector3
	var bwQ math32.Quat
	slmath.SpatialTransformInverse(gd.WbR, gd.WbQ, &bwR, &bwQ)
	gd.BwR = bwR
	gd.BwQ = bwQ
	gd.Radius = 0
	if shp == Sphere || shp == Capsule { // todo: cone is separate
		gd.Radius = gd.Size.X
	}
	return gd
}

/////// Collision methods: in geometry/kernels.py
// note: have to pass a non-pointer arg as first arg, due to gosl issue.
// cpi = contact point index.

// X_wb, X_ws -> WtoB
// X_bw, X_sw -> BtoW

// ptAw = point in A, world coords; b = body coords

func ColSphereSphere(cpi int32, gdA *GeomData, gdB *GeomData, ptA, ptB, norm *math32.Vector3) float32 {
	ptAw := gdA.WbR
	ptBw := gdB.WbR
	diff := ptAw.Sub(ptBw)
	*ptA = ptAw
	*ptB = ptBw
	*norm = slmath.Normal3(diff)
	return slmath.Dot3(diff, *norm)
}

func ColCapsulePlane(cpi int32, gdA *GeomData, gdB *GeomData, ptA, ptB, norm *math32.Vector3) float32 {
	var ptAw, ptBw, diff math32.Vector3
	hh := gdA.Size.Y
	if cpi < 2 { // vertex
		side := float32(cpi)*2 - 1
		ptAw = slmath.MulSpatialPoint(gdA.WbR, gdA.WbQ, math32.Vec3(0, side*hh, 0))
		queryB := slmath.MulSpatialPoint(gdB.BwR, gdB.BwQ, ptAw)
		ptBb := ClosestPointPlane(gdB.Size.X, gdB.Size.Z, queryB)
		ptBw = slmath.MulSpatialPoint(gdA.WbR, gdA.WbQ, ptBb)
		diff = ptAw.Sub(ptBw)
		if gdB.Size.X > 0 {
			*norm = slmath.Normal3(diff)
		} else {
			*norm = slmath.MulSpatialPoint(gdB.WbR, gdB.WbQ, math32.Vec3(0, 1, 0))
		}
	} else { // edges of finite plane -- only here if plane is finite
		var edge0, edge1 math32.Vector3
		PlaneEdge(cpi-2, gdB.Size.X, gdB.Size.Z, &edge0, &edge1)
		edge0w := slmath.MulSpatialPoint(gdB.WbR, gdB.WbQ, edge0)
		edge1w := slmath.MulSpatialPoint(gdB.WbR, gdB.WbQ, edge1)
		edge0a := slmath.MulSpatialPoint(gdA.BwR, gdA.BwQ, edge0w)
		edge1a := slmath.MulSpatialPoint(gdA.BwR, gdA.BwQ, edge1w)
		u := ClosestEdgeCapsule(gdA.Size.X, gdA.Size.Y, edge0a, edge1a, 10) // todo: edge_sdf_iter
		ptBw = edge0w.MulScalar(1 - u).Add(edge1w.MulScalar(u))
		// find closest point + contact normal on capsule A
		pt0Aw := slmath.MulSpatialPoint(gdA.WbR, gdA.WbQ, math32.Vec3(0, hh, 0))
		pt1Aw := slmath.MulSpatialPoint(gdA.WbR, gdA.WbQ, math32.Vec3(0, -hh, 0))
		ptAw = ClosestPointLineSegment(pt0Aw, pt1Aw, ptBw)
		diff = ptAw.Sub(ptBw)
		*norm = slmath.MulSpatialPoint(gdB.WbR, gdB.WbQ, math32.Vec3(0, 1, 0))
	}
	*ptA = ptAw
	*ptB = ptBw
	return slmath.Dot3(diff, *norm)
}

//gosl:end
