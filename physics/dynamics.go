// Code generated by "goal build"; DO NOT EDIT.
//line dynamics.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	// "fmt"
	"math"

	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start

// DynamicVars are dynamic body variables stored in tensor.Float32.
type DynamicVars int32 //enums:enum

const (
	// Index of body in list of bodies.
	DynBody DynamicVars = iota

	// 3D position of structural center.
	DynPosX
	DynPosY
	DynPosZ

	// Quaternion rotation.
	DynQuatX
	DynQuatY
	DynQuatZ
	DynQuatW

	// Linear velocity.
	DynVelX
	DynVelY
	DynVelZ

	// Angular velocity.
	DynAngVelX
	DynAngVelY
	DynAngVelZ

	// Linear acceleration.
	DynAccX
	DynAccY
	DynAccZ

	// Angular acceleration due to applied torques.
	DynAngAccX
	DynAngAccY
	DynAngAccZ

	// Linear force driving linear acceleration (from joints, etc).
	DynForceX
	DynForceY
	DynForceZ

	// Torque driving angular acceleration (from joints, etc).
	DynTorqueX
	DynTorqueY
	DynTorqueZ

	// Linear deltas. These accumulate over time via StepBodyDeltas.
	DynDeltaX
	DynDeltaY
	DynDeltaZ

	// Angular deltas. These accumulate over time via StepBodyDeltas.
	DynAngDeltaX
	DynAngDeltaY
	DynAngDeltaZ

	// integrated weight of all contacts
	DynContactWeight
)

// cni = current / next index

func SetDynamicBody(idx, bodyIdx int32) {
	bi := math.Float32frombits(uint32(bodyIdx))
	Dynamics.Set(bi, int(idx), int(0), int(DynBody))
	Dynamics.Set(bi, int(idx), int(1), int(DynBody))
}

func DynamicBody(idx int32) int32 {
	return int32(math.Float32bits(Dynamics.Value(int(idx), int(0), int(DynBody))))
}

func DynamicPos(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynPosX)), Dynamics.Value(int(idx), int(cni), int(DynPosY)), Dynamics.Value(int(idx), int(cni), int(DynPosZ)))
}

func SetDynamicPos(idx, cni int32, pos math32.Vector3) {
	Dynamics.Set(pos.X, int(idx), int(cni), int(DynPosX))
	Dynamics.Set(pos.Y, int(idx), int(cni), int(DynPosY))
	Dynamics.Set(pos.Z, int(idx), int(cni), int(DynPosZ))
}

func DynamicQuat(idx, cni int32) math32.Quat {
	return math32.NewQuat(Dynamics.Value(int(idx), int(cni), int(DynQuatX)), Dynamics.Value(int(idx), int(cni), int(DynQuatY)), Dynamics.Value(int(idx), int(cni), int(DynQuatZ)), Dynamics.Value(int(idx), int(cni), int(DynQuatW)))
}

func SetDynamicQuat(idx, cni int32, rot math32.Quat) {
	Dynamics.Set(rot.X, int(idx), int(cni), int(DynQuatX))
	Dynamics.Set(rot.Y, int(idx), int(cni), int(DynQuatY))
	Dynamics.Set(rot.Z, int(idx), int(cni), int(DynQuatZ))
	Dynamics.Set(rot.W, int(idx), int(cni), int(DynQuatW))
}

func DynamicVel(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynVelX)), Dynamics.Value(int(idx), int(cni), int(DynVelY)), Dynamics.Value(int(idx), int(cni), int(DynVelZ)))
}

func SetDynamicVel(idx, cni int32, vel math32.Vector3) {
	Dynamics.Set(vel.X, int(idx), int(cni), int(DynVelX))
	Dynamics.Set(vel.Y, int(idx), int(cni), int(DynVelY))
	Dynamics.Set(vel.Z, int(idx), int(cni), int(DynVelZ))
}

func DynamicAcc(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAccX)), Dynamics.Value(int(idx), int(cni), int(DynAccY)), Dynamics.Value(int(idx), int(cni), int(DynAccZ)))
}

func SetDynamicAcc(idx, cni int32, acc math32.Vector3) {
	Dynamics.Set(acc.X, int(idx), int(cni), int(DynAccX))
	Dynamics.Set(acc.Y, int(idx), int(cni), int(DynAccY))
	Dynamics.Set(acc.Z, int(idx), int(cni), int(DynAccZ))
}

func DynamicForce(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynForceX)), Dynamics.Value(int(idx), int(cni), int(DynForceY)), Dynamics.Value(int(idx), int(cni), int(DynForceZ)))
}

func SetDynamicForce(idx, cni int32, force math32.Vector3) {
	Dynamics.Set(force.X, int(idx), int(cni), int(DynForceX))
	Dynamics.Set(force.Y, int(idx), int(cni), int(DynForceY))
	Dynamics.Set(force.Z, int(idx), int(cni), int(DynForceZ))
}

func DynamicTorque(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynTorqueX)), Dynamics.Value(int(idx), int(cni), int(DynTorqueY)), Dynamics.Value(int(idx), int(cni), int(DynTorqueZ)))
}

func SetDynamicTorque(idx, cni int32, torque math32.Vector3) {
	Dynamics.Set(torque.X, int(idx), int(cni), int(DynTorqueX))
	Dynamics.Set(torque.Y, int(idx), int(cni), int(DynTorqueY))
	Dynamics.Set(torque.Z, int(idx), int(cni), int(DynTorqueZ))
}

func DynamicAngVel(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngVelX)), Dynamics.Value(int(idx), int(cni), int(DynAngVelY)), Dynamics.Value(int(idx), int(cni), int(DynAngVelZ)))
}

func SetDynamicAngVel(idx, cni int32, angVel math32.Vector3) {
	Dynamics.Set(angVel.X, int(idx), int(cni), int(DynAngVelX))
	Dynamics.Set(angVel.Y, int(idx), int(cni), int(DynAngVelY))
	Dynamics.Set(angVel.Z, int(idx), int(cni), int(DynAngVelZ))
}

func DynamicAngAcc(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngAccX)), Dynamics.Value(int(idx), int(cni), int(DynAngAccY)), Dynamics.Value(int(idx), int(cni), int(DynAngAccZ)))
}

func SetDynamicAngAcc(idx, cni int32, angAcc math32.Vector3) {
	Dynamics.Set(angAcc.X, int(idx), int(cni), int(DynAngAccX))
	Dynamics.Set(angAcc.Y, int(idx), int(cni), int(DynAngAccY))
	Dynamics.Set(angAcc.Z, int(idx), int(cni), int(DynAngAccZ))
}

//////// Accumulating deltas

func DynamicDelta(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynDeltaX)), Dynamics.Value(int(idx), int(cni), int(DynDeltaY)), Dynamics.Value(int(idx), int(cni), int(DynDeltaZ)))
}

func SetDynamicDelta(idx, cni int32, delta math32.Vector3) {
	Dynamics.Set(delta.X, int(idx), int(cni), int(DynDeltaX))
	Dynamics.Set(delta.Y, int(idx), int(cni), int(DynDeltaY))
	Dynamics.Set(delta.Z, int(idx), int(cni), int(DynDeltaZ))
}

func DynamicAngDelta(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngDeltaX)), Dynamics.Value(int(idx), int(cni), int(DynAngDeltaY)), Dynamics.Value(int(idx), int(cni), int(DynAngDeltaZ)))
}

func SetDynamicAngDelta(idx, cni int32, angDelta math32.Vector3) {
	Dynamics.Set(angDelta.X, int(idx), int(cni), int(DynAngDeltaX))
	Dynamics.Set(angDelta.Y, int(idx), int(cni), int(DynAngDeltaY))
	Dynamics.Set(angDelta.Z, int(idx), int(cni), int(DynAngDeltaZ))
}

//gosl:end

// SetMass sets the mass of given body object (only relevant for dynamics),
// including a default inertia tensor based on solid shape of given size.
func (ml *Model) SetMass(idx int32, shape Shapes, size math32.Vector3, mass float32) {
	Bodies.Set(shape.Radius(size), int(idx), int(BodyRadius))
	Bodies.Set(mass, int(idx), int(BodyMass))
	invm := mass
	if mass > 0 {
		invm = 1.0 / mass
	}
	Bodies.Set(invm, int(idx), int(BodyInvMass))
	inertia := shape.Inertia(size, mass)
	SetBodyInertia(idx, inertia)
	SetBodyInvInertia(idx, inertia.Inverse())
}

// TotalKineticEnergy returns the total kinetic energy of the dynamic bodies,
// as a function of the velocities.
func (ml *Model) TotalKineticEnergy() float32 {
	params := GetParams(0)
	ke := float32(0)
	n := int32(Dynamics.DimSize(0))
	for di := range n {
		bi := DynamicBody(di)
		mass := Bodies.Value(int(bi), int(BodyMass))
		inertia := BodyInertia(bi)

		v := DynamicVel(di, params.Next)
		mv := 0.5 * mass * slmath.LengthSquared3(v)

		w := DynamicAngVel(di, params.Next)
		iw := 0.5 * slmath.Dot3(w, inertia.MulVector3(w))

		ke += mv + iw
	}
	return ke
}

// AngularVelocityAt returns the angular velocity vector of given dynamic body
// index and Next index, relative to given rotation axis at given point
// relative to the structural center of the given dynamic body.
// For example, to get rotation around the XZ plane, axis = (0,1,0) and
// the velocity value will show up in the Z axis for an X-axis point,
// and vice-versa (X for a Z-axis point).
// This uses DynamicAngVel which is computed after each step (into Next).
func AngularVelocityAt(di int32, point, axis math32.Vector3) math32.Vector3 {
	params := GetParams(0)
	w := DynamicAngVel(di, params.Next)
	wp := slmath.Cross3(w.Mul(axis), point)
	return wp
}

// AngularAccelAt returns the angular acceleration vector of given dynamic body
// index and Next index, relative to given rotation axis at given point
// relative to the structural center of the given dynamic body.
// For example, to get rotation around the XZ plane, axis = (0,1,0) and
// the acceleration value will show up in the Z axis for an X-axis point,
// and vice-versa (X for a Z-axis point).
// This uses DynamicAngAcc which is computed after each step (into Next).
func AngularAccelAt(di int32, point, axis math32.Vector3) math32.Vector3 {
	params := GetParams(0)
	w := DynamicAngAcc(di, params.Next)
	wp := slmath.Cross3(w.Mul(axis), point)
	return wp
}
