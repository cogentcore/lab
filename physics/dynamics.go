// Code generated by "goal build"; DO NOT EDIT.
//line dynamics.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// DynamicVars are dynamic body variables stored in tensor.Float32.
type DynamicVars int32 //enums:enum

const (
	// Index of body in list of bodies.
	DynIndex DynamicVars = iota

	// 3D position of center of mass.
	DynPosX
	DynPosY
	DynPosZ

	// Quaternion rotation.
	DynQuatX
	DynQuatY
	DynQuatZ
	DynQuatW

	// Linear velocity.
	DynVelX
	DynVelY
	DynVelZ

	// Angular velocity.
	DynAngVelX
	DynAngVelY
	DynAngVelZ

	// Linear acceleration.
	DynAccX
	DynAccY
	DynAccZ

	// Angular acceleration due to applied torques.
	DynAngAccX
	DynAngAccY
	DynAngAccZ

	// Linear force driving linear acceleration (from joints, etc).
	DynForceX
	DynForceY
	DynForceZ

	// Torque driving angular acceleration (from joints, etc).
	DynTorqueX
	DynTorqueY
	DynTorqueZ

	// Linear deltas.
	DynDeltaX
	DynDeltaY
	DynDeltaZ

	// Angular deltas.
	DynAngDeltaX
	DynAngDeltaY
	DynAngDeltaZ
)

func SetDynamicIndex(idx, cni, bodyIdx int32) {
	Dynamics.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(cni), int(DynIndex))
}

func DynamicIndex(idx, cni int32) int32 {
	return int32(math.Float32bits(Dynamics.Value(int(idx), int(cni), int(DynIndex))))
}

func DynamicPos(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynPosX)), Dynamics.Value(int(idx), int(cni), int(DynPosY)), Dynamics.Value(int(idx), int(cni), int(DynPosZ)))
}

func SetDynamicPos(idx, cni int32, pos math32.Vector3) {
	Dynamics.Set(pos.X, int(idx), int(cni), int(DynPosX))
	Dynamics.Set(pos.Y, int(idx), int(cni), int(DynPosY))
	Dynamics.Set(pos.Z, int(idx), int(cni), int(DynPosZ))
}

func DynamicQuat(idx, cni int32) math32.Quat {
	return math32.NewQuat(Dynamics.Value(int(idx), int(cni), int(DynQuatX)), Dynamics.Value(int(idx), int(cni), int(DynQuatY)), Dynamics.Value(int(idx), int(cni), int(DynQuatZ)), Dynamics.Value(int(idx), int(cni), int(DynQuatW)))
}

func SetDynamicQuat(idx, cni int32, rot math32.Quat) {
	Dynamics.Set(rot.X, int(idx), int(cni), int(DynQuatX))
	Dynamics.Set(rot.Y, int(idx), int(cni), int(DynQuatY))
	Dynamics.Set(rot.Z, int(idx), int(cni), int(DynQuatZ))
	Dynamics.Set(rot.W, int(idx), int(cni), int(DynQuatW))
}

func DynamicVel(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynVelX)), Dynamics.Value(int(idx), int(cni), int(DynVelY)), Dynamics.Value(int(idx), int(cni), int(DynVelZ)))
}

func SetDynamicVel(idx, cni int32, vel math32.Vector3) {
	Dynamics.Set(vel.X, int(idx), int(cni), int(DynVelX))
	Dynamics.Set(vel.Y, int(idx), int(cni), int(DynVelY))
	Dynamics.Set(vel.Z, int(idx), int(cni), int(DynVelZ))
}

func DynamicAcc(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAccX)), Dynamics.Value(int(idx), int(cni), int(DynAccY)), Dynamics.Value(int(idx), int(cni), int(DynAccZ)))
}

func SetDynamicAcc(idx, cni int32, acc math32.Vector3) {
	Dynamics.Set(acc.X, int(idx), int(cni), int(DynAccX))
	Dynamics.Set(acc.Y, int(idx), int(cni), int(DynAccY))
	Dynamics.Set(acc.Z, int(idx), int(cni), int(DynAccZ))
}

func DynamicForce(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynForceX)), Dynamics.Value(int(idx), int(cni), int(DynForceY)), Dynamics.Value(int(idx), int(cni), int(DynForceZ)))
}

func SetDynamicForce(idx, cni int32, force math32.Vector3) {
	Dynamics.Set(force.X, int(idx), int(cni), int(DynForceX))
	Dynamics.Set(force.Y, int(idx), int(cni), int(DynForceY))
	Dynamics.Set(force.Z, int(idx), int(cni), int(DynForceZ))
}

func DynamicTorque(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynTorqueX)), Dynamics.Value(int(idx), int(cni), int(DynTorqueY)), Dynamics.Value(int(idx), int(cni), int(DynTorqueZ)))
}

func SetDynamicTorque(idx, cni int32, torque math32.Vector3) {
	Dynamics.Set(torque.X, int(idx), int(cni), int(DynTorqueX))
	Dynamics.Set(torque.Y, int(idx), int(cni), int(DynTorqueY))
	Dynamics.Set(torque.Z, int(idx), int(cni), int(DynTorqueZ))
}

func DynamicAngVel(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngVelX)), Dynamics.Value(int(idx), int(cni), int(DynAngVelY)), Dynamics.Value(int(idx), int(cni), int(DynAngVelZ)))
}

func SetDynamicAngVel(idx, cni int32, angVel math32.Vector3) {
	Dynamics.Set(angVel.X, int(idx), int(cni), int(DynAngVelX))
	Dynamics.Set(angVel.Y, int(idx), int(cni), int(DynAngVelY))
	Dynamics.Set(angVel.Z, int(idx), int(cni), int(DynAngVelZ))
}

func DynamicAngAcc(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngAccX)), Dynamics.Value(int(idx), int(cni), int(DynAngAccY)), Dynamics.Value(int(idx), int(cni), int(DynAngAccZ)))
}

func SetDynamicAngAcc(idx, cni int32, angAcc math32.Vector3) {
	Dynamics.Set(angAcc.X, int(idx), int(cni), int(DynAngAccX))
	Dynamics.Set(angAcc.Y, int(idx), int(cni), int(DynAngAccY))
	Dynamics.Set(angAcc.Z, int(idx), int(cni), int(DynAngAccZ))
}

func DynamicDelta(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynDeltaX)), Dynamics.Value(int(idx), int(cni), int(DynDeltaY)), Dynamics.Value(int(idx), int(cni), int(DynDeltaZ)))
}

func SetDynamicDelta(idx, cni int32, delta math32.Vector3) {
	Dynamics.Set(delta.X, int(idx), int(cni), int(DynDeltaX))
	Dynamics.Set(delta.Y, int(idx), int(cni), int(DynDeltaY))
	Dynamics.Set(delta.Z, int(idx), int(cni), int(DynDeltaZ))
}

func DynamicAngDelta(idx, cni int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(cni), int(DynAngDeltaX)), Dynamics.Value(int(idx), int(cni), int(DynAngDeltaY)), Dynamics.Value(int(idx), int(cni), int(DynAngDeltaZ)))
}

func SetDynamicAngDelta(idx, cni int32, angDelta math32.Vector3) {
	Dynamics.Set(angDelta.X, int(idx), int(cni), int(DynAngDeltaX))
	Dynamics.Set(angDelta.Y, int(idx), int(cni), int(DynAngDeltaY))
	Dynamics.Set(angDelta.Z, int(idx), int(cni), int(DynAngDeltaZ))
}

//gosl:end

// SetMass sets the mass of given body object (only relevant for dynamics),
// including a default inertia tensor based on solid shape of given size.
func (wl *World) SetMass(idx int32, shape Shapes, size math32.Vector3, mass float32) {
	Bodies.Set(mass, int(idx), int(BodyMass))
	invm := mass
	if mass > 0 {
		invm = 1.0 / mass
	}
	Bodies.Set(invm, int(idx), int(BodyInvMass))
	inertia := shape.Inertia(size, mass)
	SetBodyInertia(idx, inertia)
	SetBodyInvInertia(idx, inertia.Inverse())
}
