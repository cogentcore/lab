// Code generated by "goal build"; DO NOT EDIT.
//line contact.goal:1
// Copyright (c) 2019, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"fmt"
	"math"
	"sync/atomic"

	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
	"cogentcore.org/lab/tensor"
)

//gosl:start

// Contact is one pairwise point of contact between two bodies.
// Contacts are represented in spherical terms relative to the
// spherical BBox of A and B.
type ContactVars int32 //enums:enum

const (
	// first body index
	ContactA ContactVars = iota

	// the other body index
	ContactB

	// contact point index for A-B pair
	ContactPointIdx

	// contact point on body A
	ContactAPointX
	ContactAPointY
	ContactAPointZ

	// contact point on body B
	ContactBPointX
	ContactBPointY
	ContactBPointZ

	// contact offset on body A
	ContactAOffX
	ContactAOffY
	ContactAOffZ

	// contact offset on body B
	ContactBOffX
	ContactBOffY
	ContactBOffZ

	// Contact thickness
	ContactAThick
	ContactBThick

	// normal pointing from center of B to center of A
	ContactNormX
	ContactNormY
	ContactNormZ

	// contact weighting -- 1 if contact made; for restitution
	// use this to filter contacts when updating body.
	ContactWeight

	// computed contact deltas, A
	ContactADeltaX
	ContactADeltaY
	ContactADeltaZ

	ContactAAngDeltaX
	ContactAAngDeltaY
	ContactAAngDeltaZ

	// computed contact deltas, B
	ContactBDeltaX
	ContactBDeltaY
	ContactBDeltaZ

	ContactBAngDeltaX
	ContactBAngDeltaY
	ContactBAngDeltaZ
)

// number of broad-phase contact values: just the indexes
const BroadContactVarsN = ContactAPointX

func SetBroadContactA(idx, bodIdx int32) {
	BroadContacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactA))
}

func GetBroadContactA(idx int32) int32 {
	return int32(math.Float32bits(BroadContacts.Value(int(idx), int(ContactA))))
}

func SetBroadContactB(idx, bodIdx int32) {
	BroadContacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactB))
}

func GetBroadContactB(idx int32) int32 {
	return int32(math.Float32bits(BroadContacts.Value(int(idx), int(ContactB))))
}

func SetBroadContactPointIdx(idx, ptIdx int32) {
	BroadContacts.Set(math.Float32frombits(uint32(ptIdx)), int(idx), int(ContactPointIdx))
}

func GetBroadContactPointIdx(idx int32) int32 {
	return int32(math.Float32bits(BroadContacts.Value(int(idx), int(ContactPointIdx))))
}

//////// Narrow

func SetContactA(idx, bodIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactA))
}

func GetContactA(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactA))))
}

func SetContactB(idx, bodIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactB))
}

func GetContactB(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactB))))
}

func SetContactPointIdx(idx, ptIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(ptIdx)), int(idx), int(ContactPointIdx))
}

func GetContactPointIdx(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactPointIdx))))
}

func ContactAPoint(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactAPointX)), Contacts.Value(int(idx), int(ContactAPointY)), Contacts.Value(int(idx), int(ContactAPointZ)))
}

func SetContactAPoint(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactAPointX))
	Contacts.Set(pos.Y, int(idx), int(ContactAPointY))
	Contacts.Set(pos.Z, int(idx), int(ContactAPointZ))
}

func ContactBPoint(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactBPointX)), Contacts.Value(int(idx), int(ContactBPointY)), Contacts.Value(int(idx), int(ContactBPointZ)))
}

func SetContactBPoint(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactBPointX))
	Contacts.Set(pos.Y, int(idx), int(ContactBPointY))
	Contacts.Set(pos.Z, int(idx), int(ContactBPointZ))
}

func ContactAOff(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactAOffX)), Contacts.Value(int(idx), int(ContactAOffY)), Contacts.Value(int(idx), int(ContactAOffZ)))
}

func SetContactAOff(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactAOffX))
	Contacts.Set(pos.Y, int(idx), int(ContactAOffY))
	Contacts.Set(pos.Z, int(idx), int(ContactAOffZ))
}

func ContactBOff(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactBOffX)), Contacts.Value(int(idx), int(ContactBOffY)), Contacts.Value(int(idx), int(ContactBOffZ)))
}

func SetContactBOff(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactBOffX))
	Contacts.Set(pos.Y, int(idx), int(ContactBOffY))
	Contacts.Set(pos.Z, int(idx), int(ContactBOffZ))
}

func ContactNorm(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactNormX)), Contacts.Value(int(idx), int(ContactNormY)), Contacts.Value(int(idx), int(ContactNormZ)))
}

func SetContactNorm(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactNormX))
	Contacts.Set(pos.Y, int(idx), int(ContactNormY))
	Contacts.Set(pos.Z, int(idx), int(ContactNormZ))
}

func ContactADelta(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactADeltaX)), Contacts.Value(int(idx), int(ContactADeltaY)), Contacts.Value(int(idx), int(ContactADeltaZ)))
}

func SetContactADelta(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactADeltaX))
	Contacts.Set(pos.Y, int(idx), int(ContactADeltaY))
	Contacts.Set(pos.Z, int(idx), int(ContactADeltaZ))
}

func ContactAAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactAAngDeltaX)), Contacts.Value(int(idx), int(ContactAAngDeltaY)), Contacts.Value(int(idx), int(ContactAAngDeltaZ)))
}

func SetContactAAngDelta(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactAAngDeltaX))
	Contacts.Set(pos.Y, int(idx), int(ContactAAngDeltaY))
	Contacts.Set(pos.Z, int(idx), int(ContactAAngDeltaZ))
}

func ContactBDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactBDeltaX)), Contacts.Value(int(idx), int(ContactBDeltaY)), Contacts.Value(int(idx), int(ContactBDeltaZ)))
}

func SetContactBDelta(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactBDeltaX))
	Contacts.Set(pos.Y, int(idx), int(ContactBDeltaY))
	Contacts.Set(pos.Z, int(idx), int(ContactBDeltaZ))
}

func ContactBAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactBAngDeltaX)), Contacts.Value(int(idx), int(ContactBAngDeltaY)), Contacts.Value(int(idx), int(ContactBAngDeltaZ)))
}

func SetContactBAngDelta(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactBAngDeltaX))
	Contacts.Set(pos.Y, int(idx), int(ContactBAngDeltaY))
	Contacts.Set(pos.Z, int(idx), int(ContactBAngDeltaZ))
}

func WorldsCollide(wa, wb int32) bool {
	if wa != -1 && wb != -1 && wa != wb {
		return false
	}
	return true
}

func GroupsCollide(ga, gb int32) bool {
	if ga == 0 || gb == 0 {
		return false
	}
	if ga > 0 {
		return ga == gb || gb < 0
	}
	if ga < 0 {
		return ga != gb
	}
	return false
}

// CollisionInit performs initialization at start of collision (i=1)
func CollisionInit(i uint32) { //gosl:kernel
	if i > 0 {
		return
	}
	BroadContactsN.Values[0] = 0
	ContactsN.Values[0] = 0
}

// newton: geometry/kernels.py: broadphase_collision_pairs

// CollisionBroad performs broad-phase collision detection, generating Contacts.
func CollisionBroad(i uint32) { //gosl:kernel
	params := GetParams(0)
	ci := int32(i)
	if ci >= params.BodyCollidePairsN {
		return
	}
	biA := BodyCollidePairs.Value(int(ci), int(0))
	biB := BodyCollidePairs.Value(int(ci), int(1))

	xwAR := BodyDynamicPos(biA, params.Cur)
	xwAQ := BodyDynamicQuat(biA, params.Cur)
	xwBR := BodyDynamicPos(biB, params.Cur)
	// xwBQ := BodyDynamicQuat(bb, params.Cur)

	// note: sA <= sB
	sA := GetBodyShape(biA)
	sB := GetBodyShape(biB)

	rb := Bodies.Value(int(biB), int(BodyRadius))
	//    if type_a == GeoType.PLANE and type_b == GeoType.PLANE:
	//        return

	// could be per-shape
	// margin = wp.max(shape_contact_margin[shape_a], shape_contact_margin[shape_b])
	margin := params.ContactMargin

	// bounding sphere check
	infPlane := false
	if sA == Plane {
		szA := BodyHSize(biA)
		if szA.X == 0 {
			infPlane = true
		}
		queryB := slmath.MulSpatialPoint(xwAR, xwAQ, xwBR)
		closest := ClosestPointPlane(szA.X, szA.Z, queryB)
		d := slmath.Length3(queryB.Sub(closest))
		if d > rb+margin {
			return
		}
		// fmt.Println("broad ct plane:", queryB, szA, closest, d, rb, margin)
	} else {
		d := slmath.Length3(xwAR.Sub(xwBR))
		ra := Bodies.Value(int(biA), int(BodyRadius))
		if d > ra+rb+margin {
			return
		}
	}
	var ncB int32
	ncA := ShapePairContacts(sA, sB, infPlane, &ncB)

	// note: ignoring contact_point_limit code for now

	enci := atomic.AddInt32(&BroadContactsN.Values[0], ncA+ncB)
	// Go returns post-added value, while WGSL returns pre-added value

	//gosl:wgsl
	// enci += ncA + ncB // wgsl now matches Go
	//gosl:end

	nci := enci - (ncA + ncB)      // starting index
	if nci >= params.ContactsMax { // shouldn't happen!
		return
	}
	AddBroadContacts(biA, biB, nci, ncA, ncB)
}

// newton: geometry/kernels.py: allocate_contact_points

// AddBroadContacts adds broad-phase contact records in prep for narrow phase.
func AddBroadContacts(biA, biB, nci, ncA, ncB int32) {
	for i := range ncA {
		SetBroadContactA(nci+i, biA)
		SetBroadContactB(nci+i, biB)
		SetBroadContactPointIdx(nci+i, i)
	}
	for i := range ncB {
		SetBroadContactA(nci+ncA+i, biB) // flipped
		SetBroadContactB(nci+ncA+i, biA)
		SetBroadContactPointIdx(nci+i, i)
	}
}

// newton: geometry/kernels.py: generate_handle_contact_pairs / handle_contact_pairs

// CollisionNarrow performs narrow-phase collision on Contacts.
func CollisionNarrow(i uint32) { //gosl:kernel
	params := GetParams(0)
	ci := int32(i)
	cmax := BroadContactsN.Values[0]
	if ci >= cmax {
		return
	}
	biA := GetBroadContactA(ci)
	biB := GetBroadContactB(ci)
	cpi := GetBroadContactPointIdx(ci)

	sA := GetBodyShape(biA)
	sB := GetBodyShape(biB)

	gdA := NewGeomData(biA, params.Cur, sA)
	gdB := NewGeomData(biB, params.Cur, sB)

	// could be per-shape
	// margin = wp.max(shape_contact_margin[shape_a], shape_contact_margin[shape_b])
	margin := params.ContactMargin
	dist := float32(1.0e6)
	maxIter := params.MaxGeomIter

	// note: no Cone on anything
	var ptA, ptB, norm, nnorm math32.Vector3
	switch gdA.Shape {
	case Plane:
		switch gdB.Shape {
		case Sphere:
			dist = ColSpherePlane(cpi, maxIter, &gdB, &gdA, &ptB, &ptA, &nnorm) // reverse
			norm = slmath.Negate3(nnorm)
		case Capsule:
			dist = ColCapsulePlane(cpi, maxIter, &gdB, &gdA, &ptB, &ptA, &nnorm) // reverse
			norm = slmath.Negate3(nnorm)
		case Cylinder:
			dist = ColCylinderPlane(cpi, maxIter, &gdB, &gdA, &ptB, &ptA, &nnorm) // reverse
			norm = slmath.Negate3(nnorm)
		case Box:
			dist = ColBoxPlane(cpi, maxIter, &gdB, &gdA, &ptB, &ptA, &nnorm) // reverse
			norm = slmath.Negate3(nnorm)
		default:
		}
	case Sphere:
		switch gdB.Shape {
		case Sphere:
			dist = ColSphereSphere(cpi, maxIter, &gdA, &gdB, &ptA, &ptB, &norm)
		case Capsule:
			dist = ColSphereCapsule(cpi, maxIter, &gdA, &gdB, &ptA, &ptB, &norm)
		// no cylinder
		case Box:
			dist = ColSphereBox(cpi, maxIter, &gdA, &gdB, &ptA, &ptB, &norm)
		default:
		}
	case Capsule:
		switch gdB.Shape {
		case Capsule:
			dist = ColCapsuleCapsule(cpi, maxIter, &gdA, &gdB, &ptA, &ptB, &norm)
		// no cylinder
		case Box:
			dist = ColBoxCapsule(cpi, maxIter, &gdB, &gdA, &ptB, &ptA, &nnorm) // reverse
			norm = slmath.Negate3(nnorm)
		default:
		}
	case Box:
		switch gdB.Shape {
		case Box:
			dist = ColBoxBox(cpi, maxIter, &gdA, &gdB, &ptA, &ptB, &norm)
		default:
		}
	default:
	}
	var ctA, ctB, offA, offB math32.Vector3
	var distActual, offMagA, offMagB float32
	actual := ContactPoints(dist, margin, &gdA, &gdB, ptA, ptB, norm, &ctA, &ctB, &offA, &offB, &distActual, &offMagA, &offMagB)
	if !actual {
		return
	}

	enci := atomic.AddInt32(&ContactsN.Values[0], 1)
	// Go returns post-added value, while WGSL returns pre-added value

	//gosl:wgsl
	// enci += int32(1) // wgsl now matches Go
	//gosl:end

	nci := enci - 1

	SetContactA(nci, biA)
	SetContactB(nci, biB)
	SetContactPointIdx(nci, cpi)
	SetContactAPoint(nci, ctA)
	SetContactBPoint(nci, ctB)
	SetContactAOff(nci, offA)
	SetContactBOff(nci, offB)
	SetContactNorm(nci, norm)
	Contacts.Set(offMagA, int(nci), int(ContactAThick))
	Contacts.Set(offMagB, int(nci), int(ContactBThick))
}

// newton: solvers/xpbd/kernels.py: solve_body_contact_positions

// StepBodyContacts generates contact forces for bodies.
func StepBodyContacts(i uint32) { //gosl:kernel
	params := GetParams(0)
	ci := int32(i)
	cmax := ContactsN.Values[0]
	if ci >= cmax {
		return
	}

	biA := GetContactA(ci)
	biB := GetContactB(ci)
	diA := GetBodyDynamic(biA)
	diB := GetBodyDynamic(biB)

	r1A := BodyDynamicPos(biA, params.Next)
	q1A := BodyDynamicQuat(biA, params.Next)

	r1B := BodyDynamicPos(biB, params.Next)
	q1B := BodyDynamicQuat(biB, params.Next)

	ctA := ContactAPoint(ci)
	offA := ContactAOff(ci)
	ctB := ContactBPoint(ci)
	offB := ContactBOff(ci)

	ctAw := slmath.MulSpatialPoint(r1A, q1A, ctA)
	ctBw := slmath.MulSpatialPoint(r1B, q1B, ctB)
	thickA := Contacts.Value(int(ci), int(ContactAThick))
	thickB := Contacts.Value(int(ci), int(ContactBThick))
	thick := thickA + thickB
	nnorm := ContactNorm(ci)
	norm := slmath.Negate3(nnorm)

	d := slmath.Dot3(norm, ctBw.Sub(ctAw)) - thick
	if d >= 0.0 { // now separated
		Contacts.Set(0.0, int(ci), int(ContactWeight))
		z := math32.Vec3(0, 0, 0)
		SetContactADelta(ci, z)
		SetContactBDelta(ci, z)
		SetContactAAngDelta(ci, z)
		SetContactBAngDelta(ci, z)
		return
	}
	comA := BodyCom(biA)
	mInvA := Bodies.Value(int(biA), int(BodyInvMass))
	iInvA := BodyInvInertia(biA)

	comB := BodyCom(biB)
	mInvB := Bodies.Value(int(biB), int(BodyInvMass))
	iInvB := BodyInvInertia(biB)

	var w1A, w1B math32.Vector3
	if diA >= 0 {
		w1A = DynamicAngDelta(diA, params.Next)
	}
	if diB >= 0 {
		w1B = DynamicAngDelta(diB, params.Next)
	}

	// use average contact material properties
	mu := 0.5 * (Bodies.Value(int(biA), int(BodyFriction)) + Bodies.Value(int(biB), int(BodyFriction)))
	frTors := 0.5 * (Bodies.Value(int(biA), int(BodyFrictionTortion)) + Bodies.Value(int(biB), int(BodyFrictionTortion)))
	frRoll := 0.5 * (Bodies.Value(int(biA), int(BodyFrictionRolling)) + Bodies.Value(int(biB), int(BodyFrictionRolling)))
	bounce := 0.5 * (Bodies.Value(int(biA), int(BodyBounce)) + Bodies.Value(int(biB), int(BodyBounce)))

	// moment arms
	dA := ctAw.Sub(slmath.MulSpatialPoint(r1A, q1A, comA))
	dB := ctBw.Sub(slmath.MulSpatialPoint(r1B, q1B, comB))

	angA := slmath.Negate3(slmath.Cross3(dA, norm))
	angB := slmath.Cross3(dB, norm)

	lambdaN := ContactConstraint(d, q1A, q1B, mInvA, mInvB, iInvA, iInvB, nnorm, norm, angA, angB, params.ContactRelax, params.Dt)

	linDeltaA := slmath.Negate3(norm).MulScalar(lambdaN)
	linDeltaB := norm.MulScalar(lambdaN)
	angDeltaA := angA.MulScalar(lambdaN)
	angDeltaB := angB.MulScalar(lambdaN)

	// linear friction
	if mu > 0.0 {
		// add on displacement from surface offsets, this ensures
		// we include any rotational effects due to thickness from feature
		// need to use the current rotation to account for friction due to
		// angular effects (e.g.: slipping contact)
		ctAm := ctAw.Add(slmath.MulQuatVector(q1A, offA))
		ctBm := ctBw.Add(slmath.MulQuatVector(q1B, offB))

		// update delta
		delta := ctBm.Sub(ctAm)
		frDelta := delta.Sub(norm.MulScalar(slmath.Dot3(norm, delta)))

		perp := slmath.Normal3(frDelta)

		dAm := ctAm.Sub(slmath.MulSpatialPoint(r1A, q1A, comA))
		dBm := ctBm.Sub(slmath.MulSpatialPoint(r1B, q1B, comB))

		angA = slmath.Negate3(slmath.Cross3(dAm, perp))
		angB = slmath.Cross3(dBm, perp)

		err := slmath.Length3(frDelta)

		if err > 0.0 {
			lambdaFr := ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, slmath.Negate3(perp), perp, angA, angB, params.ContactRelax, params.Dt)

			// limit friction based on incremental normal force,
			// good approximation to limiting on total force
			lambdaFr = max(lambdaFr, -lambdaN*mu)

			linDeltaA = linDeltaA.Sub(perp.MulScalar(lambdaFr))
			linDeltaB = linDeltaB.Add(perp.MulScalar(lambdaFr))
			angDeltaA = angDeltaA.Add(angA.MulScalar(lambdaFr))
			angDeltaB = angDeltaB.Add(angB.MulScalar(lambdaFr))
		}
	}

	deltaW := w1B.Sub(w1A)

	if frTors > 0.0 {
		err := slmath.Dot3(deltaW, norm) * params.Dt

		if math32.Abs(err) > 0.0 {
			lin := math32.Vec3(0, 0, 0)
			lambdaTors := ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, lin, lin, nnorm, norm, params.ContactRelax, params.Dt)

			lambdaTors = math32.Clamp(lambdaTors, -lambdaN*frTors, lambdaN*frTors)
			angDeltaA = angDeltaA.Sub(norm.MulScalar(lambdaTors))
			angDeltaB = angDeltaB.Add(norm.MulScalar(lambdaTors))
		}
	}

	if frRoll > 0.0 {
		deltaW = deltaW.Sub(norm.MulScalar(slmath.Dot3(norm, deltaW)))
		err := slmath.Length3(deltaW) * params.Dt
		if err > 0.0 {
			lin := math32.Vec3(0, 0, 0)
			rollN := slmath.Normal3(deltaW)
			lambdaRoll := ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, lin, lin, slmath.Negate3(rollN), rollN, params.ContactRelax, params.Dt)
			lambdaRoll = max(lambdaRoll, -lambdaN*frRoll)

			angDeltaA = angDeltaA.Sub(rollN.MulScalar(lambdaRoll))
			angDeltaB = angDeltaB.Add(rollN.MulScalar(lambdaRoll))
		}
	}

	// restitution (bounce)
	if params.Restitution.IsTrue() && bounce > 0 && (mInvA > 0 || mInvB > 0) {
		var vA, vB, vAnew, vBnew, dAnew, dBnew math32.Vector3
		var mInvAr, mInvBr float32
		var q0A, q0B math32.Quat
		grav := params.Gravity.V().MulScalar(params.Dt)
		if diA >= 0 {
			q0A = DynamicQuat(diA, params.Cur)
			w0A := DynamicAngDelta(diA, params.Cur)
			v0A := DynamicDelta(diA, params.Cur)
			v1A := DynamicDelta(diA, params.Next)

			vA = VelocityAtPoint(v0A, w0A, dA).Add(grav)
			vAnew = VelocityAtPoint(v1A, w1A, dA)
			dAnew = slmath.MulQuatVectorInverse(q0A, slmath.Cross3(dA, nnorm)) // norm is not - here..
			mInvAr = mInvA + slmath.Dot3(dAnew, iInvA.MulVector3(dAnew))
		}
		if diB >= 0 {
			q0B = DynamicQuat(diB, params.Cur)
			w0B := DynamicAngDelta(diB, params.Cur)
			v0B := DynamicDelta(diB, params.Cur)
			v1B := DynamicDelta(diB, params.Next)

			vB = VelocityAtPoint(v0B, w0B, dB).Add(grav)
			vBnew = VelocityAtPoint(v1B, w1B, dB)
			dBnew = slmath.MulQuatVectorInverse(q0B, slmath.Cross3(dB, nnorm)) // norm is not - here..
			mInvBr = mInvB + slmath.Dot3(dBnew, iInvB.MulVector3(dBnew))
		}
		mInv := mInvAr + mInvBr
		relVel0 := slmath.Dot3(nnorm, vA.Sub(vB))
		relVel1 := slmath.Dot3(nnorm, vAnew.Sub(vBnew))
		if relVel0 < 0 {
			dv := -(relVel1 - relVel0*bounce) / mInv
			if diA >= 0 {
				dvA := nnorm.MulScalar(mInvA * dv)
				dwA := slmath.MulQuatVector(q0A, iInvA.MulVector3(dAnew).MulScalar(dv))
				linDeltaA = linDeltaA.Add(dvA)
				angDeltaA = angDeltaA.Add(dwA)
			}
			if diB >= 0 {
				dvB := nnorm.MulScalar(mInvB * dv)
				dwB := slmath.MulQuatVector(q0B, iInvB.MulVector3(dBnew).MulScalar(dv))
				linDeltaB = linDeltaB.Add(dvB)
				angDeltaB = angDeltaB.Add(dwB)
			}
		}
	}

	Contacts.Set(1.0, int(ci), int(ContactWeight))
	SetContactADelta(ci, linDeltaA)
	SetContactBDelta(ci, linDeltaB)
	SetContactAAngDelta(ci, angDeltaA)
	SetContactBAngDelta(ci, angDeltaB)
}

// DeltasFromContacts gathers deltas, angDeltas from contacts per dynamic.
func DeltasFromContacts(i uint32) { //gosl:kernel
	params := GetParams(0)
	di := int32(i)
	if di >= params.DynamicsN {
		return
	}
	cmax := ContactsN.Values[0]

	bi := DynamicBody(di)

	td := math32.Vec3(0, 0, 0)
	ta := math32.Vec3(0, 0, 0)
	tw := float32(0)
	for ci := range cmax {
		wt := Contacts.Value(int(ci), int(ContactWeight))
		if wt == 0 {
			continue
		}
		biA := GetContactA(ci)
		biB := GetContactB(ci)
		if biA == bi {
			tw += wt
			d := ContactADelta(ci)
			td = td.Add(d)
			a := ContactAAngDelta(ci)
			ta = ta.Add(a)
		}
		if biB == bi {
			tw += wt
			d := ContactBDelta(ci)
			td = td.Add(d)
			a := ContactBAngDelta(ci)
			ta = ta.Add(a)
		}
	}
	v0 := DynamicDelta(di, params.Next)
	w0 := DynamicAngDelta(di, params.Next)
	// fmt.Println(params.Next, "contact:", v0, td)

	SetDynamicDelta(di, params.Next, td.Add(v0))
	SetDynamicAngDelta(di, params.Next, ta.Add(w0))
	Dynamics.Set(tw, int(di), int(params.Next), int(DynContactWeight))
}

func ContactConstraint(err float32, q0A, q0B math32.Quat, mInvA, mInvB float32, iInvA, iInvB math32.Matrix3, linA, linB, angA, angB math32.Vector3, relaxation, dt float32) float32 {
	denom := float32(0.0)
	denom += slmath.LengthSquared3(linA) * mInvA
	denom += slmath.LengthSquared3(linB) * mInvB

	// Eq. 2-3 (make sure to project into the frame of the body)
	rotAngA := slmath.MulQuatVectorInverse(q0A, angA)
	rotAngB := slmath.MulQuatVectorInverse(q0B, angB)

	denom += slmath.Dot3(rotAngA, iInvA.MulVector3(rotAngA))
	denom += slmath.Dot3(rotAngB, iInvB.MulVector3(rotAngB))

	lambda := -err
	if denom > 0.0 {
		lambda /= dt * denom
	}

	return lambda * relaxation
}

//gosl:end

// IsChildDynamic returns true if dic is a direct child
// on any joint where dip is the parent.
func (wl *World) IsChildDynamic(dip, dic int32) bool {
	if dip < 0 || dic < 0 {
		return false
	}
	npja := wl.BodyJoints.Value(int(dip), int(0), int(0))
	for j := range npja {
		ji := wl.BodyJoints.Value(int(dip), int(0), int(1+j))
		jci := JointChildIndex(ji)
		if jci == dic {
			return true
		}
	}
	return false
}

// newton: sim/builder.py: find_shape_contact_pairs

// ConfigBodyCollidePairs compiles a list of body paris that could collide
// based on world and group settings and not being direct parent
// child relationship within a joint. Result has A with lower shape type,
// so that shapes are in a canonical order.
func (wl *World) ConfigBodyCollidePairs() {
	params := &wl.Params[0]
	nb := params.BodiesN
	nalc := int(nb) * 10
	pt := tensor.NewInt32(nalc, 2)
	np := 0
	for a := range nb {
		wa := GetBodyWorld(a)
		ga := GetBodyGroup(a)
		dia := GetBodyDynamic(a)
		for b := range nb {
			wb := GetBodyWorld(b)
			gb := GetBodyGroup(b)
			if !WorldsCollide(wa, wb) {
				continue
			}
			if !GroupsCollide(ga, gb) {
				continue
			}
			dib := GetBodyDynamic(b)
			// now check joints (ConfigJoints must have been called first)
			if wl.IsChildDynamic(dia, dib) {
				continue
			}
			if np >= nalc {
				nalc += int(nb)
				pt.SetShapeSizes(nalc, 2)
				fmt.Println("body pairs realoc", nalc)
			}

			sA := GetBodyShape(a)
			sB := GetBodyShape(b)
			if sA <= sB {
				pt.Set(a, int(np), int(0))
				pt.Set(b, int(np), int(1))
			} else {
				pt.Set(b, int(np), int(0))
				pt.Set(a, int(np), int(1))
			}
			np++
		}
	}
	params.BodyCollidePairsN = int32(np)
	pt.SetShapeSizes(np, 2)
	wl.BodyCollidePairs = pt
	BodyCollidePairs = pt
	fmt.Println("body pairs over alloc", nalc, np)
}

// newton: geometry/kernels.py: count_contact_points

// SetMaxContacts computes [Params.MaxContacts] based on current list of
// [BodyCollidePairs].
func (wl *World) SetMaxContacts() {
	params := &wl.Params[0]

	n := int32(0)
	for ci := range params.BodyCollidePairsN {
		biA := BodyCollidePairs.Value(int(ci), int(0))
		biB := BodyCollidePairs.Value(int(ci), int(1))

		// note: sA <= sB
		sA := GetBodyShape(biA)
		sB := GetBodyShape(biB)

		infPlane := false
		szA := BodyHSize(biA)
		if szA.X == 0 {
			infPlane = true
		}

		var ncB int32
		ncA := ShapePairContacts(sA, sB, infPlane, &ncB)
		n += ncA + ncB
	}
	// todo: this is a massive over-estimate, b/c there is no way everyone could be
	// colliding at once. Except.. if it is a very small model.
	if params.BodyCollidePairsN > 1000 {
		n = n / 2 // todo: could do more of this as N gets larger
	}
	params.ContactsMax = n
	wl.BroadContacts.SetShapeSizes(int(n), int(BroadContactVarsN))
	wl.Contacts.SetShapeSizes(int(n), int(ContactVarsN))
}
