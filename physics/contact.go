// Code generated by "goal build"; DO NOT EDIT.
//line contact.goal:1
// Copyright (c) 2019, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"fmt"
	"math"
	"sync/atomic"

	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
	"cogentcore.org/lab/tensor"
)

//gosl:start

// Contact is one pairwise point of contact between two bodies.
// Contacts are represented in spherical terms relative to the
// spherical BBox of A and B.
type ContactVars int32 //enums:enum

const (
	// first body index
	ContactA ContactVars = iota

	// the other body index
	ContactB

	// contact point index for A-B pair
	ContactPointIdx

	// contact point on body A
	ContactAPointX
	ContactAPointY
	ContactAPointZ

	// contact point on body B
	ContactBPointX
	ContactBPointY
	ContactBPointZ

	// Contact depths (thickness in newton)
	ContactADepth
	ContactBDepth

	// normal pointing from center of B to center of A
	ContactNormX
	ContactNormY
	ContactNormZ

	// computed contact force vector
	ContactForceX
	ContactForceY
	ContactForceZ
)

func SetContactA(idx, bodIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactA))
}

func GetContactA(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactA))))
}

func SetContactB(idx, bodIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(bodIdx)), int(idx), int(ContactB))
}

func GetContactB(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactB))))
}

func SetContactPointIdx(idx, ptIdx int32) {
	Contacts.Set(math.Float32frombits(uint32(ptIdx)), int(idx), int(ContactPointIdx))
}

func GetContactPointIdx(idx int32) int32 {
	return int32(math.Float32bits(Contacts.Value(int(idx), int(ContactPointIdx))))
}

func ContactAPoint(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactAPointX)), Contacts.Value(int(idx), int(ContactAPointY)), Contacts.Value(int(idx), int(ContactAPointZ)))
}

func SetContactAPoint(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactAPointX))
	Contacts.Set(pos.Y, int(idx), int(ContactAPointY))
	Contacts.Set(pos.Z, int(idx), int(ContactAPointZ))
}

func ContactBPoint(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactBPointX)), Contacts.Value(int(idx), int(ContactBPointY)), Contacts.Value(int(idx), int(ContactBPointZ)))
}

func SetContactBPoint(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactBPointX))
	Contacts.Set(pos.Y, int(idx), int(ContactBPointY))
	Contacts.Set(pos.Z, int(idx), int(ContactBPointZ))
}

func ContactNorm(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactNormX)), Contacts.Value(int(idx), int(ContactNormY)), Contacts.Value(int(idx), int(ContactNormZ)))
}

func SetContactNorm(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactNormX))
	Contacts.Set(pos.Y, int(idx), int(ContactNormY))
	Contacts.Set(pos.Z, int(idx), int(ContactNormZ))
}

func ContactForce(idx int32) math32.Vector3 {
	return math32.Vec3(Contacts.Value(int(idx), int(ContactForceX)), Contacts.Value(int(idx), int(ContactForceY)), Contacts.Value(int(idx), int(ContactForceZ)))
}

func SetContactForce(idx int32, pos math32.Vector3) {
	Contacts.Set(pos.X, int(idx), int(ContactForceX))
	Contacts.Set(pos.Y, int(idx), int(ContactForceY))
	Contacts.Set(pos.Z, int(idx), int(ContactForceZ))
}

func WorldsCollide(wa, wb int32) bool {
	if wa != -1 && wb != -1 && wa != wb {
		return false
	}
	return true
}

func GroupsCollide(ga, gb int32) bool {
	if ga == 0 || gb == 0 {
		return false
	}
	if ga > 0 {
		return ga == gb || gb < 0
	}
	if ga < 0 {
		return ga != gb
	}
	return false
}

// newton: geometry/kernels.py: broadphase_collision_pairs

// CollisionBroad performs broad-phase collision detection, generating Contacts.
func CollisionBroad(i uint32) { //gosl:kernel
	params := GetParams(0)
	ci := int32(i)
	if ci >= params.BodyCollidePairsN {
		return
	}
	biA := BodyCollidePairs.Value(int(ci), int(0))
	biB := BodyCollidePairs.Value(int(ci), int(1))

	xwAR := BodyDynamicPos(biA, params.Cur)
	xwAQ := BodyDynamicQuat(biA, params.Cur)
	xwBR := BodyDynamicPos(biB, params.Cur)
	// xwBQ := BodyDynamicQuat(bb, params.Cur)

	// note: sA <= sB
	sA := GetBodyShape(biA)
	sB := GetBodyShape(biB)

	rb := Bodies.Value(int(biB), int(BodyRadius))
	//    if type_a == GeoType.PLANE and type_b == GeoType.PLANE:
	//        return

	// could be per-shape
	// margin = wp.max(shape_contact_margin[shape_a], shape_contact_margin[shape_b])
	margin := params.ContactMargin

	// bounding sphere check
	infPlane := false
	if sA == Plane {
		szA := BodySize(biA)
		if szA.X == 0 {
			infPlane = true
		}
		queryB := slmath.MulSpatialPoint(xwAR, xwAQ, xwBR)
		closest := ClosestPointPlane(szA, queryB)
		d := slmath.Length3(queryB.Sub(closest))
		if d > rb+margin {
			return
		}
	} else {
		d := slmath.Length3(xwAR.Sub(xwBR))
		ra := Bodies.Value(int(biA), int(BodyRadius))
		if d > ra+rb+margin {
			return
		}
	}
	//    pair_index_ab = shape_a * num_shapes + shape_b
	//    pair_index_ba = shape_b * num_shapes + shape_a

	var ncB int32
	ncA := ShapePairContacts(sA, sB, infPlane, &ncB)

	// note: ignoring contact_point_limit code for now

	enci := atomic.AddInt32(&ContactCount.Values[int(params.Cur)], ncA+ncB)
	// Go returns post-added value, while WGSL returns pre-added value

	//gosl:wgsl
	// enci += ncA + ncB // wgsl now matches Go
	//gosl:end

	nci := enci - (ncA + ncB)      // starting index
	if nci >= params.ContactsMax { // shouldn't happen!
		return
	}
	AddContacts(biA, biB, ci, ncA, ncB)
}

// newton: geometry/kernels.py: allocate_contact_points

// AddContacts adds contact records in prep for narrow phase.
func AddContacts(biA, biB, ci, ncA, ncB int32) {
	for i := range ncA {
		SetContactA(ci+i, biA)
		SetContactB(ci+i, biB)
		SetContactPointIdx(ci+i, i)
	}
	for i := range ncB {
		SetContactA(ci+ncA+i, biB) // flipped
		SetContactB(ci+ncA+i, biA)
		SetContactPointIdx(ci+i, i)
	}
}

// ClosestPointPlane projects the point onto the quad in
// the xy plane (if size > 0.0, otherwise infinite.
func ClosestPointPlane(sz, pt math32.Vector3) math32.Vector3 {
	cp := pt
	if sz.X == 0.0 {
		return cp
	}
	cp.X = math32.Clamp(pt.X, -sz.X, sz.X)
	cp.Y = math32.Clamp(pt.Y, -sz.Y, sz.Y)
	return cp
}

//gosl:end

// IsChildDynamic returns true if dic is a direct child
// on any joint where dip is the parent.
func (wl *World) IsChildDynamic(dip, dic int32) bool {
	npja := wl.BodyJoints.Value(int(dip), int(0), int(0))
	for j := range npja {
		ji := wl.BodyJoints.Value(int(dip), int(0), int(1+j))
		jci := JointChildIndex(ji)
		if jci == dic {
			return true
		}
	}
	return false
}

// newton: sim/builder.py: find_shape_contact_pairs

// ConfigBodyCollidePairs compiles a list of body paris that could collide
// based on world and group settings and not being direct parent
// child relationship within a joint. Result has A with lower shape type,
// so that shapes are in a canonical order.
func (wl *World) ConfigBodyCollidePairs() {
	params := &wl.Params[0]
	nb := params.BodiesN
	nalc := int(nb) * 10
	pt := tensor.NewInt32(nalc, 2)
	np := 0
	for a := range nb {
		wa := GetBodyWorld(a)
		ga := GetBodyGroup(a)
		dia := GetBodyDynamic(a)
		for b := range nb {
			wb := GetBodyWorld(b)
			gb := GetBodyGroup(b)
			if !WorldsCollide(wa, wb) {
				continue
			}
			if !GroupsCollide(ga, gb) {
				continue
			}
			dib := GetBodyDynamic(b)
			// now check joints (ConfigJoints must have been called first)
			if wl.IsChildDynamic(dia, dib) {
				continue
			}
			if np >= nalc {
				nalc += int(nb)
				pt.SetShapeSizes(nalc, 2)
				fmt.Println("body pairs realoc", nalc)
			}

			sA := GetBodyShape(a)
			sB := GetBodyShape(b)
			if sA <= sB {
				pt.Set(a, int(np), int(0))
				pt.Set(b, int(np), int(1))
			} else {
				pt.Set(b, int(np), int(0))
				pt.Set(a, int(np), int(1))
			}
			np++
		}
	}
	params.BodyCollidePairsN = int32(np)
	pt.SetShapeSizes(np, 2)
	wl.BodyCollidePairs = pt
	fmt.Println("body pairs over alloc", nalc, np)
}

// newton: geometry/kernels.py: count_contact_points

// SetMaxContacts computes [Params.MaxContacts] based on current list of
// [BodyCollidePairs].
func (wl *World) SetMaxContacts() {
	params := &wl.Params[0]

	n := int32(0)
	for ci := range params.BodyCollidePairsN {
		biA := BodyCollidePairs.Value(int(ci), int(0))
		biB := BodyCollidePairs.Value(int(ci), int(1))

		// note: sA <= sB
		sA := GetBodyShape(biA)
		sB := GetBodyShape(biB)

		infPlane := false
		szA := BodySize(biA)
		if szA.X == 0 {
			infPlane = true
		}

		var ncB int32
		ncA := ShapePairContacts(sA, sB, infPlane, &ncB)
		n += ncA + ncB
	}
	// todo: this is a massive over-estimate, b/c there is no way everyone could be
	// colliding at once. Except.. if it is a very small model.
	if params.BodyCollidePairsN > 1000 {
		n = n / 2 // todo: could do more of this as N gets larger
	}
	params.ContactsMax = n
	wl.Contacts.SetShapeSizes(int(n), int(ContactVarsN))
}
