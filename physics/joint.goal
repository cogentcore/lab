// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

//  Sentinel value for unlimited joint limits
const JointLimitUnlimited = 1e10

// JointTypes are joint types that determine nature of interaction.
type JointTypes int32 //enums:enum

const (
	// Prismatic allows translation along a single axis (slider): 1 DoF.
	Prismatic JointTypes = iota

	// Revolute allows rotation about a single axis (axel): 1 DoF.
	Revolute

	// Ball allows rotation about all three axes (3 DoF, quaternion).
	Ball

	// Fixed locks all relative motion: 0 DoF.
	Fixed

	// Free allows full 6-DoF motion (translation and rotation).
	Free

	// Distance keeps two bodies a distance within joint limits: 6 DoF.
	Distance

	// D6 is a generic 6-DoF joint.
	D6
)

// JointVars are joint state variables stored in tensor.Float32.
// These are all static joint properties; dynamic control variables
// in [JointControlVars] and [JointControls].
type JointVars int32 //enums:enum

const (
	// JointType (as an int32 from bits).
	JointType JointVars = iota

	// JointEnabled allows joints to be dynamically enabled.
	JointEnabled

	// JointParent is the dynamic body index for parent body.
	// Can be -1 for a fixed parent for absolute anchor.
	JointParent

	// JointChild is the dynamic body index for child body.
	JointChild

	// relative position of joint, in parent frame.
	JointPPosX
	JointPPosY
	JointPPosZ

	// relative orientation of joint, in parent frame.
	JointPQuatX
	JointPQuatY
	JointPQuatZ
	JointPQuatW

	// relative position of joint, in child frame.
	JointCPosX
	JointCPosY
	JointCPosZ

	// relative orientation of joint, in child frame.
	JointCQuatX
	JointCQuatY
	JointCQuatZ
	JointCQuatW

	// JointLinearDoFN is the number of linear degrees-of-freedom for the joint.
	JointLinearDoFN
	// JointAngularDoFN is the number of angular degrees-of-freedom for the joint.
	JointAngularDoFN

	// indexes in JointDoFs for each DoF
	JointDoF1
	JointDoF2
	JointDoF3
	// angular starts here for Free, Distance, D6
	JointDoF4
	JointDoF5
	JointDoF6

	// Computed forces (temp storage until aggregated by bodies).

	// Computed parent joint force value.
	JointPForceX
	JointPForceY
	JointPForceZ

	// Computed parent joint torque value.
	JointPTorqueX
	JointPTorqueY
	JointPTorqueZ

	// Computed child joint force value.
	JointCForceX
	JointCForceY
	JointCForceZ

	// Computed child joint torque value.
	JointCTorqueX
	JointCTorqueY
	JointCTorqueZ

	// Computed parent joint delta value.
	JointPDeltaX
	JointPDeltaY
	JointPDeltaZ

	// Computed parent joint angdelta value.
	JointPAngDeltaX
	JointPAngDeltaY
	JointPAngDeltaZ

	// Computed child joint delta value.
	JointCDeltaX
	JointCDeltaY
	JointCDeltaZ

	// Computed child joint angdelta value.
	JointCAngDeltaX
	JointCAngDeltaY
	JointCAngDeltaZ
)

func GetJointType(idx int32) JointTypes {
	return JointTypes(math.Float32bits(Joints[idx, JointType]))
}

func SetJointType(idx int32, typ JointTypes) {
	Joints[idx, JointType] = math.Float32frombits(uint32(typ))
}

func GetJointEnabled(idx int32) bool {
	je := math.Float32bits(Joints[idx, JointEnabled])
	return je != 0
}

func SetJointEnabled(idx int32, enabled bool) {
	je := uint32(0)
	if enabled {
		je = 1
	}
	Joints[idx, JointEnabled] = math.Float32frombits(je)
}

func SetJointParent(idx, bodyIdx int32) {
	Joints[idx, JointParent] = math.Float32frombits(uint32(bodyIdx))
}

func JointParentIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointParent]))
}

func SetJointChild(idx, bodyIdx int32) {
	Joints[idx, JointChild] = math.Float32frombits(uint32(bodyIdx))
}

func JointChildIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointChild]))
}

func SetJointLinearDoFN(idx, dofN int32) {
	Joints[idx, JointLinearDoFN] = math.Float32frombits(uint32(dofN))
}

func GetJointLinearDoFN(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointLinearDoFN]))
}

func SetJointAngularDoFN(idx, dofN int32) {
	Joints[idx, JointAngularDoFN] = math.Float32frombits(uint32(dofN))
}

func GetJointAngularDoFN(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointAngularDoFN]))
}

func SetJointDoFIndex(idx, dof, dofIdx int32) {
	Joints[idx, int32(JointDoF1) + dof] = math.Float32frombits(uint32(dofIdx))
}

func JointDoFIndex(idx, dof int32) int32 {
	return int32(math.Float32bits(Joints[idx, int32(JointDoF1)+dof]))
}

func JointPPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointPPosX], Joints[idx, JointPPosY], Joints[idx, JointPPosZ])
}

func SetJointPPos(idx int32, pos math32.Vector3) {
	Joints[idx, JointPPosX] = pos.X
	Joints[idx, JointPPosY] = pos.Y
	Joints[idx, JointPPosZ] = pos.Z
}

func JointPQuat(idx int32) math32.Quat {
	return math32.NewQuat(Joints[idx, JointPQuatX], Joints[idx, JointPQuatY], Joints[idx, JointPQuatZ], Joints[idx, JointPQuatW])
}

func SetJointPQuat(idx int32, rot math32.Quat) {
	Joints[idx, JointPQuatX] = rot.X
	Joints[idx, JointPQuatY] = rot.Y
	Joints[idx, JointPQuatZ] = rot.Z
	Joints[idx, JointPQuatW] = rot.W
}

func JointCPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointCPosX], Joints[idx, JointCPosY], Joints[idx, JointCPosZ])
}

func SetJointCPos(idx int32, pos math32.Vector3) {
	Joints[idx, JointCPosX] = pos.X
	Joints[idx, JointCPosY] = pos.Y
	Joints[idx, JointCPosZ] = pos.Z
}

func JointCQuat(idx int32) math32.Quat {
	return math32.NewQuat(Joints[idx, JointCQuatX], Joints[idx, JointCQuatY], Joints[idx, JointCQuatZ], Joints[idx, JointCQuatW])
}

func SetJointCQuat(idx int32, rot math32.Quat) {
	Joints[idx, JointCQuatX] = rot.X
	Joints[idx, JointCQuatY] = rot.Y
	Joints[idx, JointCQuatZ] = rot.Z
	Joints[idx, JointCQuatW] = rot.W
}

func JointPForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointPForceX], Joints[idx, JointPForceY], Joints[idx, JointPForceZ])
}

func SetJointPForce(idx int32, f math32.Vector3) {
	Joints[idx, JointPForceX] = f.X
	Joints[idx, JointPForceY] = f.Y
	Joints[idx, JointPForceZ] = f.Z
}

func JointPTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointPTorqueX], Joints[idx, JointPTorqueY], Joints[idx, JointPTorqueZ])
}

func SetJointPTorque(idx int32, t math32.Vector3) {
	Joints[idx, JointPTorqueX] = t.X
	Joints[idx, JointPTorqueY] = t.Y
	Joints[idx, JointPTorqueZ] = t.Z
}

func JointCForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointCForceX], Joints[idx, JointCForceY], Joints[idx, JointCForceZ])
}

func SetJointCForce(idx int32, f math32.Vector3) {
	Joints[idx, JointCForceX] = f.X
	Joints[idx, JointCForceY] = f.Y
	Joints[idx, JointCForceZ] = f.Z
}

func JointCTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointCTorqueX], Joints[idx, JointCTorqueY], Joints[idx, JointCTorqueZ])
}

func SetJointCTorque(idx int32, t math32.Vector3) {
	Joints[idx, JointCTorqueX] = t.X
	Joints[idx, JointCTorqueY] = t.Y
	Joints[idx, JointCTorqueZ] = t.Z
}

func JointPDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointPDeltaX], Joints[idx, JointPDeltaY], Joints[idx, JointPDeltaZ])
}

func SetJointPDelta(idx int32, f math32.Vector3) {
	Joints[idx, JointPDeltaX] = f.X
	Joints[idx, JointPDeltaY] = f.Y
	Joints[idx, JointPDeltaZ] = f.Z
}

func JointPAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointPAngDeltaX], Joints[idx, JointPAngDeltaY], Joints[idx, JointPAngDeltaZ])
}

func SetJointPAngDelta(idx int32, t math32.Vector3) {
	Joints[idx, JointPAngDeltaX] = t.X
	Joints[idx, JointPAngDeltaY] = t.Y
	Joints[idx, JointPAngDeltaZ] = t.Z
}

func JointCDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointCDeltaX], Joints[idx, JointCDeltaY], Joints[idx, JointCDeltaZ])
}

func SetJointCDelta(idx int32, f math32.Vector3) {
	Joints[idx, JointCDeltaX] = f.X
	Joints[idx, JointCDeltaY] = f.Y
	Joints[idx, JointCDeltaZ] = f.Z
}

func JointCAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints[idx, JointCAngDeltaX], Joints[idx, JointCAngDeltaY], Joints[idx, JointCAngDeltaZ])
}

func SetJointCAngDelta(idx int32, t math32.Vector3) {
	Joints[idx, JointCAngDeltaX] = t.X
	Joints[idx, JointCAngDeltaY] = t.Y
	Joints[idx, JointCAngDeltaZ] = t.Z
}

// JointDoFVars are joint DoF state variables stored in tensor.Float32,
// one for each DoF.
type JointDoFVars int32 //enums:enum

const (
	// axis of articulation for the DoF
	JointAxisX JointDoFVars = iota
	JointAxisY
	JointAxisZ

	// joint limits
	JointLimitLower
	JointLimitUpper

	// joint stiffness target (ke)
	JointStiff

	// joint damping target (kd)
	JointDamp
)

func JointAxisDoF(didx int32) math32.Vector3 {
	return math32.Vec3(JointDoFs[didx, JointAxisX], JointDoFs[didx, JointAxisY], JointDoFs[didx, JointAxisZ])
}

func SetJointAxisDoF(didx int32, axis math32.Vector3) {
	JointDoFs[didx, JointAxisX] = axis.X
	JointDoFs[didx, JointAxisY] = axis.Y
	JointDoFs[didx, JointAxisZ] = axis.Z
}

func JointAxis(idx, dof int32) math32.Vector3 {
	return JointAxisDoF(JointDoFIndex(idx, dof))
}

func SetJointAxis(idx, dof int32, axis math32.Vector3) {
	SetJointAxisDoF(JointDoFIndex(idx, dof), axis)
}

func JointDoF(idx, dof int32, vr JointDoFVars) float32 {
	return JointDoFs[JointDoFIndex(idx, dof), vr]
}

func SetJointDoF(idx, dof int32, vr JointDoFVars, value float32) {
	JointDoFs[JointDoFIndex(idx, dof), vr] = value
}



//gosl:end

func (wl *World) JointDefaults(idx int32) {
	rot := math32.NewQuat(0, 0, 0, 1)
	SetJointPQuat(idx, rot)
	SetJointCQuat(idx, rot)
}

func (wl *World) JointDoFDefaults(didx int32) {
	JointDoFs[didx, JointLimitLower] = -JointLimitUnlimited
	JointDoFs[didx, JointLimitUpper] = JointLimitUnlimited
	JointDoFs[didx, JointStiff] = 1.0e4
	JointDoFs[didx, JointDamp] = 1.0e1
}

// NewJointPrismatic adds a new Prismatic (slider) joint
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// axis is the axis of articulation for the joint.
// Use [SetJointDoF] to set the remaining DoF parameters.
func (wl *World) NewJointPrismatic(parent, child int32, ppos, cpos, axis math32.Vector3) int32 {
	idx := wl.newJoint(Prismatic, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, 1)
	didx := wl.newJointDoF(0, axis)
	SetJointDoFIndex(idx, 0, didx)
	return idx
}

// NewJointRevolute adds a new Revolute (hinge, axel) joint
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// axis is the axis of articulation for the joint.
// Use [SetJointDoF] to set the remaining DoF parameters.
func (wl *World) NewJointRevolute(parent, child int32, ppos, cpos, axis math32.Vector3) int32 {
	idx := wl.newJoint(Revolute, parent, child, ppos, cpos)
	SetJointAngularDoFN(idx, 1)
	didx := wl.newJointDoF(0, axis)
	SetJointDoFIndex(idx, 0, didx)
	return idx
}

// NewJointBall adds a new Ball joint (3 angular DoF)
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// Use [SetJointDoF] to set the remaining DoF parameters.
func (wl *World) NewJointBall(parent, child int32, ppos, cpos math32.Vector3) int32 {
	idx := wl.newJoint(Ball, parent, child, ppos, cpos)
	SetJointAngularDoFN(idx, 3)
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		didx := wl.newJointDoF(int32(d), axis)
		SetJointDoFIndex(idx, int32(d), didx)
	}
	return idx
}

// NewJointDistance adds a new Distance joint (6 DoF)
// between parent and child dynamic object indexes,
// with distance constrained only on the first linear X axis.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// Use [SetJointDoF] to set the remaining DoF parameters.
func (wl *World) NewJointDistance(parent, child int32, ppos, cpos math32.Vector3, minDist, maxDist float32) int32 {
	idx := wl.newJoint(Distance, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, 3)
	SetJointAngularDoFN(idx, 3)
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		didx := wl.newJointDoF(int32(d), axis)
		SetJointDoFIndex(idx, int32(d), didx)
	}
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		didx := wl.newJointDoF(int32(d), axis)
		SetJointDoFIndex(idx, int32(d), didx)
	}
	// only on the X linear axis
	SetJointDoF(idx, 0, JointLimitLower, minDist)
	SetJointDoF(idx, 0, JointLimitUpper, maxDist)
	return idx
}

// newJoint adds a new joint between parent and child
// dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (wl *World) newJoint(joint JointTypes, parent, child int32, ppos, cpos math32.Vector3) int32 {
	sizes := wl.Joints.ShapeSizes()
	idx := int32(sizes[0])
	wl.Params[0].JointsN = idx + 1
	wl.Joints.SetShapeSizes(int(idx+1), int(JointVarsN))
	wl.JointDefaults(idx)
	SetJointType(idx, joint)
	SetJointEnabled(idx, true)
	SetJointParent(idx, parent)
	SetJointChild(idx, child)
	SetJointPPos(idx, ppos)
	SetJointCPos(idx, cpos)
	return idx
}

// newJointDoF adds new JointDoFs and JointControls entries
// initialized to detfaults. Returns index.
func (wl *World) newJointDoF(dof int32, axis math32.Vector3) int32 {
	sizes := wl.JointDoFs.ShapeSizes()
	idx := int32(sizes[0])
	wl.JointDoFs.SetShapeSizes(int(idx+1), int(JointDoFVarsN))
	wl.JointControls.SetShapeSizes(int(idx+1), int(JointControlVarsN))
	wl.JointDoFDefaults(idx)
	SetJointAxis(idx, 0, axis)
	wl.Params[0].JointDoFsN = idx + 1
	return idx
}

