// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// JointVars are joint state variables stored in tensor.Float32.
// These are all static joint properties; dynamic control variables
// in [JointControlVars] and [JointControls].
type JointVars int32 //enums:enum

const (
	// JointType (as an int32 from bits).
	JointType JointVars = iota

	// JointEnabled allows joints to be dynamically enabled.
	JointEnabled

	// JointParent is the dynamic body index for parent body.
	// Can be -1 for a fixed parent for absolute anchor.
	JointParent

	// JointChild is the dynamic body index for child body.
	JointChild

	// position of joint, in parent frame.
	JointPPosX
	JointPPosY
	JointPPosZ

	// orientation of joint, in parent frame.
	JointPRotX
	JointPRotY
	JointPRotZ
	JointPRotW

	// position of joint, in child frame.
	JointCPosX
	JointCPosY
	JointCPosZ

	// orientation of joint, in child frame.
	JointCRotX
	JointCRotY
	JointCRotZ
	JointCRotW

	JointAxisX
	JointAxisY
	JointAxisZ

	// joint limits
	JointLimitLower
	JointLimitUpper

	// Computed forces (temp storage until aggregated by bodies).

	// Computed parent joint force value.
	JointPForceX
	JointPForceY
	JointPForceZ

	// Computed parent joint torque value.
	JointPTorqueX
	JointPTorqueY
	JointPTorqueZ

	// Computed child joint force value.
	JointCForceX
	JointCForceY
	JointCForceZ

	// Computed child joint torque value.
	JointCTorqueX
	JointCTorqueY
	JointCTorqueZ
)

func GetJointType(idx int32) JointTypes {
	return JointTypes(math.Float32bits(Joints[idx, JointType]))
}

func SetJointType(idx int32, typ JointTypes) {
	Joints[idx, JointType] = math.Float32frombits(uint32(typ))
}

func SetJointParent(idx, bodyIdx int32) {
	Joints[idx, JointParent] = math.Float32frombits(uint32(bodyIdx))
}

func JointParentIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointParent]))
}

func SetJointChild(idx, bodyIdx int32) {
	Joints[idx, JointChild] = math.Float32frombits(uint32(bodyIdx))
}

func JointChildIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints[idx, JointChild]))
}

func JointPPos(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Joints[idx, JointPPosX]
	pos.Y = Joints[idx, JointPPosY]
	pos.Z = Joints[idx, JointPPosZ]
	return pos
}

func SetJointPPos(idx int32, pos math32.Vector3) {
	Joints[idx, JointPPosX] = pos.X
	Joints[idx, JointPPosY] = pos.Y
	Joints[idx, JointPPosZ] = pos.Z
}

func JointPRot(idx int32) math32.Quat {
	var rot math32.Quat
	rot.X = Joints[idx, JointPRotX]
	rot.Y = Joints[idx, JointPRotY]
	rot.Z = Joints[idx, JointPRotZ]
	rot.W = Joints[idx, JointPRotW]
	return rot
}

func SetJointPRot(idx int32, rot math32.Quat) {
	Joints[idx, JointPRotX] = rot.X
	Joints[idx, JointPRotY] = rot.Y
	Joints[idx, JointPRotZ] = rot.Z
	Joints[idx, JointPRotW] = rot.W
}

func JointAxis(idx int32) math32.Vector3 {
	var axis math32.Vector3
	axis.X = Joints[idx, JointAxisX]
	axis.Y = Joints[idx, JointAxisY]
	axis.Z = Joints[idx, JointAxisZ]
	return axis
}

func SetJointAxis(idx int32, axis math32.Vector3) {
	Joints[idx, JointAxisX] = axis.X
	Joints[idx, JointAxisY] = axis.Y
	Joints[idx, JointAxisZ] = axis.Z
}

func JointPForce(idx int32) math32.Vector3 {
	var f math32.Vector3
	f.X = Joints[idx, JointPForceX]
	f.Y = Joints[idx, JointPForceY]
	f.Z = Joints[idx, JointPForceZ]
	return f
}

func SetJointPForce(idx int32, f math32.Vector3) {
	Joints[idx, JointPForceX] = f.X
	Joints[idx, JointPForceY] = f.Y
	Joints[idx, JointPForceZ] = f.Z
}

func JointPTorque(idx int32) math32.Vector3 {
	var t math32.Vector3
	t.X = Joints[idx, JointPTorqueX]
	t.Y = Joints[idx, JointPTorqueY]
	t.Z = Joints[idx, JointPTorqueZ]
	return t
}

func SetJointPTorque(idx int32, t math32.Vector3) {
	Joints[idx, JointPTorqueX] = t.X
	Joints[idx, JointPTorqueY] = t.Y
	Joints[idx, JointPTorqueZ] = t.Z
}

func JointCForce(idx int32) math32.Vector3 {
	var f math32.Vector3
	f.X = Joints[idx, JointCForceX]
	f.Y = Joints[idx, JointCForceY]
	f.Z = Joints[idx, JointCForceZ]
	return f
}

func SetJointCForce(idx int32, f math32.Vector3) {
	Joints[idx, JointCForceX] = f.X
	Joints[idx, JointCForceY] = f.Y
	Joints[idx, JointCForceZ] = f.Z
}

func JointCTorque(idx int32) math32.Vector3 {
	var t math32.Vector3
	t.X = Joints[idx, JointCTorqueX]
	t.Y = Joints[idx, JointCTorqueY]
	t.Z = Joints[idx, JointCTorqueZ]
	return t
}

func SetJointCTorque(idx int32, t math32.Vector3) {
	Joints[idx, JointCTorqueX] = t.X
	Joints[idx, JointCTorqueY] = t.Y
	Joints[idx, JointCTorqueZ] = t.Z
}

// JointTypes are joint types that determine nature of interaction.
type JointTypes int32 //enums:enum

const (
	// Prismatic allows translation along a single axis (slider): 1 DoF.
	Prismatic JointTypes = iota

	// Revolute allows rotation about a single axis (axel): 1 DoF.
	Revolute

	// Ball allows rotation about all three axes (3 DoF, quaternion).
	Ball

	// Fixed locks all relative motion: 0 DoF.
	Fixed

	// Free allows full 6-DoF motion (translation and rotation).
	Free

	// Distance keeps two bodies a distance within joint limits: 6 DoF.
	Distance

	// D6 is a generic 6-DoF joint.
	D6
)

//gosl:end
