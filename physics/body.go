// Code generated by "goal build"; DO NOT EDIT.
//line body.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// BodyVars are body state variables stored in tensor.Float32
type BodyVars int32 //enums:enum

const (
	// BodyShape is the shape type of the object, as a Shapes type.
	BodyShape BodyVars = iota

	// BodyWorldIndex partitions body into different worlds; Global are -1
	BodyWorldIndex

	// BodySize is the size of the object (values depend on shape type).
	BodySizeX
	BodySizeY
	BodySizeZ

	// physical properties

	// BodyMass is the mass of the object.
	BodyMass

	// BodyInvMass is 1/mass of the object or 0 if no mass.
	BodyInvMass

	// BodyBounce specifies the COR or coefficient of restitution (0..1),
	// which determines how elastic the collision is,
	// i.e., final velocity / initial velocity.
	BodyBounce

	// BodyFriction coefficient: how much friction is generated by transverse motion.
	// Additive across the two surfaces.
	BodyFriction

	// 3D position of body (structural center).
	BodyPosX
	BodyPosY
	BodyPosZ

	// Quaternion rotation of body.
	BodyRotX
	BodyRotY
	BodyRotZ
	BodyRotW

	// Relative center-of-mass offset from 3D position of body.
	BodyComX
	BodyComY
	BodyComZ

	// Inertia 3x3 matrix (column matrix organization, r,c labels).
	BodyInertiaXX
	BodyInertiaYX
	BodyInertiaZX
	BodyInertiaXY
	BodyInertiaYY
	BodyInertiaZY
	BodyInertiaXZ
	BodyInertiaYZ
	BodyInertiaZZ

	// InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).
	BodyInvInertiaXX
	BodyInvInertiaYX
	BodyInvInertiaZX
	BodyInvInertiaXY
	BodyInvInertiaYY
	BodyInvInertiaZY
	BodyInvInertiaXZ
	BodyInvInertiaYZ
	BodyInvInertiaZZ
)

func GetBodyShape(idx int32) Shapes {
	return Shapes(math.Float32bits(Bodies.Value(int(idx), int(BodyShape))))
}

func SetBodyShape(idx int32, shape Shapes) {
	Bodies.Set(math.Float32frombits(uint32(shape)), int(idx), int(BodyShape))
}

func BodySize(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodySizeX)), Bodies.Value(int(idx), int(BodySizeY)), Bodies.Value(int(idx), int(BodySizeZ)))
}

func SetBodySize(idx int32, size math32.Vector3) {
	Bodies.Set(size.X, int(idx), int(BodySizeX))
	Bodies.Set(size.Y, int(idx), int(BodySizeY))
	Bodies.Set(size.Z, int(idx), int(BodySizeZ))
}

func BodyPos(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodyPosX)), Bodies.Value(int(idx), int(BodyPosY)), Bodies.Value(int(idx), int(BodyPosZ)))
}

func SetBodyPos(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyPosX))
	Bodies.Set(pos.Y, int(idx), int(BodyPosY))
	Bodies.Set(pos.Z, int(idx), int(BodyPosZ))
}

func BodyRot(idx int32) math32.Quat {
	return math32.NewQuat(Bodies.Value(int(idx), int(BodyRotX)), Bodies.Value(int(idx), int(BodyRotY)), Bodies.Value(int(idx), int(BodyRotZ)), Bodies.Value(int(idx), int(BodyRotW)))
}

func SetBodyRot(idx int32, rot math32.Quat) {
	Bodies.Set(rot.X, int(idx), int(BodyRotX))
	Bodies.Set(rot.Y, int(idx), int(BodyRotY))
	Bodies.Set(rot.Z, int(idx), int(BodyRotZ))
	Bodies.Set(rot.W, int(idx), int(BodyRotW))
}

func BodyCom(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodyComX)), Bodies.Value(int(idx), int(BodyComY)), Bodies.Value(int(idx), int(BodyComZ)))
}

func SetBodyCom(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyComX))
	Bodies.Set(pos.Y, int(idx), int(BodyComY))
	Bodies.Set(pos.Z, int(idx), int(BodyComZ))
}

func BodyInertia(idx int32) math32.Matrix3 {
	return math32.Mat3(Bodies.Value(int(idx), int(BodyInertiaXX)), Bodies.Value(int(idx), int(BodyInertiaYX)), Bodies.Value(int(idx), int(BodyInertiaZX)),
		Bodies.Value(int(idx), int(BodyInertiaXY)), Bodies.Value(int(idx), int(BodyInertiaYY)), Bodies.Value(int(idx), int(BodyInertiaZY)),
		Bodies.Value(int(idx), int(BodyInertiaXZ)), Bodies.Value(int(idx), int(BodyInertiaYZ)), Bodies.Value(int(idx), int(BodyInertiaZZ)))
}

func BodyInvInertia(idx int32) math32.Matrix3 {
	return math32.Mat3(Bodies.Value(int(idx), int(BodyInvInertiaXX)), Bodies.Value(int(idx), int(BodyInvInertiaYX)), Bodies.Value(int(idx), int(BodyInvInertiaZX)),
		Bodies.Value(int(idx), int(BodyInvInertiaXY)), Bodies.Value(int(idx), int(BodyInvInertiaYY)), Bodies.Value(int(idx), int(BodyInvInertiaZY)),
		Bodies.Value(int(idx), int(BodyInvInertiaXZ)), Bodies.Value(int(idx), int(BodyInvInertiaYZ)), Bodies.Value(int(idx), int(BodyInvInertiaZZ)))
}

//////// Dynamic

// DynamicVars are dynamic body variables stored in tensor.Float32.
type DynamicVars int32 //enums:enum

const (
	// Index of body in list of bodies.
	DynIndex DynamicVars = iota

	// 3D position of center of mass.
	DynPosX
	DynPosY
	DynPosZ

	// Quaternion rotation.
	DynRotX
	DynRotY
	DynRotZ
	DynRotW

	// Linear velocity.
	DynVelX
	DynVelY
	DynVelZ

	// Angular velocity.
	DynAngVelX
	DynAngVelY
	DynAngVelZ

	// Linear acceleration.
	DynAccX
	DynAccY
	DynAccZ

	// Angular acceleration due to applied torques.
	DynAngAccX
	DynAngAccY
	DynAngAccZ

	// Linear force driving linear acceleration (from joints, etc).
	DynForceX
	DynForceY
	DynForceZ

	// Torque driving angular acceleration (from joints, etc).
	DynTorqueX
	DynTorqueY
	DynTorqueZ

	// Linear deltas.
	DynDeltaX
	DynDeltaY
	DynDeltaZ

	// Angular deltas.
	DynAngDeltaX
	DynAngDeltaY
	DynAngDeltaZ
)

func SetDynamicIndex(idx, bodyIdx int32) {
	Dynamics.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(DynIndex))
}

func DynamicIndex(idx int32) int32 {
	return int32(math.Float32bits(Dynamics.Value(int(idx), int(DynIndex))))
}

func DynamicPos(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynPosX)), Dynamics.Value(int(idx), int(DynPosY)), Dynamics.Value(int(idx), int(DynPosZ)))
}

func SetDynamicPos(idx int32, pos math32.Vector3) {
	Dynamics.Set(pos.X, int(idx), int(DynPosX))
	Dynamics.Set(pos.Y, int(idx), int(DynPosY))
	Dynamics.Set(pos.Z, int(idx), int(DynPosZ))
}

func DynamicRot(idx int32) math32.Quat {
	return math32.NewQuat(Dynamics.Value(int(idx), int(DynRotX)), Dynamics.Value(int(idx), int(DynRotY)), Dynamics.Value(int(idx), int(DynRotZ)), Dynamics.Value(int(idx), int(DynRotW)))
}

func SetDynamicRot(idx int32, rot math32.Quat) {
	Dynamics.Set(rot.X, int(idx), int(DynRotX))
	Dynamics.Set(rot.Y, int(idx), int(DynRotY))
	Dynamics.Set(rot.Z, int(idx), int(DynRotZ))
	Dynamics.Set(rot.W, int(idx), int(DynRotW))
}

func DynamicVel(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynVelX)), Dynamics.Value(int(idx), int(DynVelY)), Dynamics.Value(int(idx), int(DynVelZ)))
}

func SetDynamicVel(idx int32, vel math32.Vector3) {
	Dynamics.Set(vel.X, int(idx), int(DynVelX))
	Dynamics.Set(vel.Y, int(idx), int(DynVelY))
	Dynamics.Set(vel.Z, int(idx), int(DynVelZ))
}

func DynamicAcc(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynAccX)), Dynamics.Value(int(idx), int(DynAccY)), Dynamics.Value(int(idx), int(DynAccZ)))
}

func SetDynamicAcc(idx int32, acc math32.Vector3) {
	Dynamics.Set(acc.X, int(idx), int(DynAccX))
	Dynamics.Set(acc.Y, int(idx), int(DynAccY))
	Dynamics.Set(acc.Z, int(idx), int(DynAccZ))
}

func DynamicForce(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynForceX)), Dynamics.Value(int(idx), int(DynForceY)), Dynamics.Value(int(idx), int(DynForceZ)))
}

func SetDynamicForce(idx int32, force math32.Vector3) {
	Dynamics.Set(force.X, int(idx), int(DynForceX))
	Dynamics.Set(force.Y, int(idx), int(DynForceY))
	Dynamics.Set(force.Z, int(idx), int(DynForceZ))
}

func DynamicTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynTorqueX)), Dynamics.Value(int(idx), int(DynTorqueY)), Dynamics.Value(int(idx), int(DynTorqueZ)))
}

func SetDynamicTorque(idx int32, torque math32.Vector3) {
	Dynamics.Set(torque.X, int(idx), int(DynTorqueX))
	Dynamics.Set(torque.Y, int(idx), int(DynTorqueY))
	Dynamics.Set(torque.Z, int(idx), int(DynTorqueZ))
}

func DynamicAngVel(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynAngVelX)), Dynamics.Value(int(idx), int(DynAngVelY)), Dynamics.Value(int(idx), int(DynAngVelZ)))
}

func SetDynamicAngVel(idx int32, angVel math32.Vector3) {
	Dynamics.Set(angVel.X, int(idx), int(DynAngVelX))
	Dynamics.Set(angVel.Y, int(idx), int(DynAngVelY))
	Dynamics.Set(angVel.Z, int(idx), int(DynAngVelZ))
}

func DynamicAngAcc(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynAngAccX)), Dynamics.Value(int(idx), int(DynAngAccY)), Dynamics.Value(int(idx), int(DynAngAccZ)))
}

func SetDynamicAngAcc(idx int32, angAcc math32.Vector3) {
	Dynamics.Set(angAcc.X, int(idx), int(DynAngAccX))
	Dynamics.Set(angAcc.Y, int(idx), int(DynAngAccY))
	Dynamics.Set(angAcc.Z, int(idx), int(DynAngAccZ))
}

func DynamicDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynDeltaX)), Dynamics.Value(int(idx), int(DynDeltaY)), Dynamics.Value(int(idx), int(DynDeltaZ)))
}

func SetDynamicDelta(idx int32, delta math32.Vector3) {
	Dynamics.Set(delta.X, int(idx), int(DynDeltaX))
	Dynamics.Set(delta.Y, int(idx), int(DynDeltaY))
	Dynamics.Set(delta.Z, int(idx), int(DynDeltaZ))
}

func DynamicAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Dynamics.Value(int(idx), int(DynAngDeltaX)), Dynamics.Value(int(idx), int(DynAngDeltaY)), Dynamics.Value(int(idx), int(DynAngDeltaZ)))
}

func SetDynamicAngDelta(idx int32, angDelta math32.Vector3) {
	Dynamics.Set(angDelta.X, int(idx), int(DynAngDeltaX))
	Dynamics.Set(angDelta.Y, int(idx), int(DynAngDeltaY))
	Dynamics.Set(angDelta.Z, int(idx), int(DynAngDeltaZ))
}

//gosl:end
