// Code generated by "goal build"; DO NOT EDIT.
//line body.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// BodyVars are body state variables stored in tensor.Float32
type BodyVars int32 //enums:enum

const (
	// Shape is the shape type of the object, as a Shapes type.
	Shape BodyVars = iota

	// WorldIndex partitions body into different worlds; Global are -1
	WorldIndex

	// Size is the size of the object (values depend on shape type).
	SizeX
	SizeY
	SizeZ

	// physical properties

	// Mass is the mass of the object.
	Mass

	// InvMass is 1/mass of the object or 0 if no mass.
	InvMass

	// Bounce specifies the COR or coefficient of restitution (0..1),
	// which determines how elastic the collision is,
	// i.e., final velocity / initial velocity.
	Bounce

	// Friction coefficient: how much friction is generated by transverse motion.
	// Additive across the two surfaces.
	Friction

	// 3D position of body (structural center).
	BodyPosX
	BodyPosY
	BodyPosZ

	// Quaternion rotation of body.
	BodyRotX
	BodyRotY
	BodyRotZ
	BodyRotW

	// Relative center-of-mass offset from 3D position of body.
	BodyComX
	BodyComY
	BodyComZ

	// Inertia 3x3 matrix (column matrix organization, r,c labels).
	InertiaXX
	InertiaYX
	InertiaZX
	InertiaXY
	InertiaYY
	InertiaZY
	InertiaXZ
	InertiaYZ
	InertiaZZ

	// InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).
	InvInertiaXX
	InvInertiaYX
	InvInertiaZX
	InvInertiaXY
	InvInertiaYY
	InvInertiaZY
	InvInertiaXZ
	InvInertiaYZ
	InvInertiaZZ
)

func BodyShape(idx int32) Shapes {
	return Shapes(math.Float32bits(Bodies.Value(int(idx), int(Shape))))
}

func SetBodyShape(idx int32, shape Shapes) {
	Bodies.Set(math.Float32frombits(uint32(shape)), int(idx), int(Shape))
}

func BodySize(idx int32) math32.Vector3 {
	var size math32.Vector3
	size.X = Bodies.Value(int(idx), int(SizeX))
	size.Y = Bodies.Value(int(idx), int(SizeY))
	size.Z = Bodies.Value(int(idx), int(SizeZ))
	return size
}

func SetBodySize(idx int32, size math32.Vector3) {
	Bodies.Set(size.X, int(idx), int(SizeX))
	Bodies.Set(size.Y, int(idx), int(SizeY))
	Bodies.Set(size.Z, int(idx), int(SizeZ))
}

func BodyPos(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Bodies.Value(int(idx), int(BodyPosX))
	pos.Y = Bodies.Value(int(idx), int(BodyPosY))
	pos.Z = Bodies.Value(int(idx), int(BodyPosZ))
	return pos
}

func SetBodyPos(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyPosX))
	Bodies.Set(pos.Y, int(idx), int(BodyPosY))
	Bodies.Set(pos.Z, int(idx), int(BodyPosZ))
}

func BodyRot(idx int32) math32.Quat {
	var rot math32.Quat
	rot.X = Bodies.Value(int(idx), int(BodyRotX))
	rot.Y = Bodies.Value(int(idx), int(BodyRotY))
	rot.Z = Bodies.Value(int(idx), int(BodyRotZ))
	rot.W = Bodies.Value(int(idx), int(BodyRotW))
	return rot
}

func SetBodyRot(idx int32, rot math32.Quat) {
	Bodies.Set(rot.X, int(idx), int(BodyRotX))
	Bodies.Set(rot.Y, int(idx), int(BodyRotY))
	Bodies.Set(rot.Z, int(idx), int(BodyRotZ))
	Bodies.Set(rot.W, int(idx), int(BodyRotW))
}

func BodyCom(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Bodies.Value(int(idx), int(BodyComX))
	pos.Y = Bodies.Value(int(idx), int(BodyComY))
	pos.Z = Bodies.Value(int(idx), int(BodyComZ))
	return pos
}

func SetBodyCom(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyComX))
	Bodies.Set(pos.Y, int(idx), int(BodyComY))
	Bodies.Set(pos.Z, int(idx), int(BodyComZ))
}

// DynamicVars are dynamic body variables stored in tensor.Float32.
type DynamicVars int32 //enums:enum

const (
	// Index of body in list of bodies.
	Index DynamicVars = iota

	// 3D position of center of mass.
	PosX
	PosY
	PosZ

	// Quaternion rotation.
	RotX
	RotY
	RotZ
	RotW

	// Linear velocity.
	VelX
	VelY
	VelZ

	// Angular velocity.
	AngVelX
	AngVelY
	AngVelZ

	// Linear acceleration.
	AccX
	AccY
	AccZ

	// Angular acceleration due to applied torques.
	AngAccX
	AngAccY
	AngAccZ

	// Linear force driving linear acceleration (from joints, etc).
	ForceX
	ForceY
	ForceZ

	// Torque driving angular acceleration (from joints, etc).
	TorqueX
	TorqueY
	TorqueZ

	// Linear deltas.
	DeltaX
	DeltaY
	DeltaZ

	// Angular deltas.
	AngDeltaX
	AngDeltaY
	AngDeltaZ
)

func SetDynamicIndex(idx, bodyIdx int32) {
	Dynamics.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(Index))
}

func DynamicIndex(idx int32) int32 {
	return int32(math.Float32bits(Dynamics.Value(int(idx), int(Index))))
}

func DynamicPos(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Dynamics.Value(int(idx), int(PosX))
	pos.Y = Dynamics.Value(int(idx), int(PosY))
	pos.Z = Dynamics.Value(int(idx), int(PosZ))
	return pos
}

func SetDynamicPos(idx int32, pos math32.Vector3) {
	Dynamics.Set(pos.X, int(idx), int(PosX))
	Dynamics.Set(pos.Y, int(idx), int(PosY))
	Dynamics.Set(pos.Z, int(idx), int(PosZ))
}

func DynamicRot(idx int32) math32.Quat {
	var rot math32.Quat
	rot.X = Dynamics.Value(int(idx), int(RotX))
	rot.Y = Dynamics.Value(int(idx), int(RotY))
	rot.Z = Dynamics.Value(int(idx), int(RotZ))
	rot.W = Dynamics.Value(int(idx), int(RotW))
	return rot
}

func SetDynamicRot(idx int32, rot math32.Quat) {
	Dynamics.Set(rot.X, int(idx), int(RotX))
	Dynamics.Set(rot.Y, int(idx), int(RotY))
	Dynamics.Set(rot.Z, int(idx), int(RotZ))
	Dynamics.Set(rot.W, int(idx), int(RotW))
}

func DynamicVel(idx int32) math32.Vector3 {
	var vel math32.Vector3
	vel.X = Dynamics.Value(int(idx), int(VelX))
	vel.Y = Dynamics.Value(int(idx), int(VelY))
	vel.Z = Dynamics.Value(int(idx), int(VelZ))
	return vel
}

func SetDynamicVel(idx int32, vel math32.Vector3) {
	Dynamics.Set(vel.X, int(idx), int(VelX))
	Dynamics.Set(vel.Y, int(idx), int(VelY))
	Dynamics.Set(vel.Z, int(idx), int(VelZ))
}

func DynamicAcc(idx int32) math32.Vector3 {
	var acc math32.Vector3
	acc.X = Dynamics.Value(int(idx), int(AccX))
	acc.Y = Dynamics.Value(int(idx), int(AccY))
	acc.Z = Dynamics.Value(int(idx), int(AccZ))
	return acc
}

func SetDynamicAcc(idx int32, acc math32.Vector3) {
	Dynamics.Set(acc.X, int(idx), int(AccX))
	Dynamics.Set(acc.Y, int(idx), int(AccY))
	Dynamics.Set(acc.Z, int(idx), int(AccZ))
}

func DynamicForce(idx int32) math32.Vector3 {
	var force math32.Vector3
	force.X = Dynamics.Value(int(idx), int(ForceX))
	force.Y = Dynamics.Value(int(idx), int(ForceY))
	force.Z = Dynamics.Value(int(idx), int(ForceZ))
	return force
}

func SetDynamicForce(idx int32, force math32.Vector3) {
	Dynamics.Set(force.X, int(idx), int(ForceX))
	Dynamics.Set(force.Y, int(idx), int(ForceY))
	Dynamics.Set(force.Z, int(idx), int(ForceZ))
}

func DynamicAngVel(idx int32) math32.Vector3 {
	var angVel math32.Vector3
	angVel.X = Dynamics.Value(int(idx), int(AngVelX))
	angVel.Y = Dynamics.Value(int(idx), int(AngVelY))
	angVel.Z = Dynamics.Value(int(idx), int(AngVelZ))
	return angVel
}

func SetDynamicAngVel(idx int32, angVel math32.Vector3) {
	Dynamics.Set(angVel.X, int(idx), int(AngVelX))
	Dynamics.Set(angVel.Y, int(idx), int(AngVelY))
	Dynamics.Set(angVel.Z, int(idx), int(AngVelZ))
}

func DynamicAngAcc(idx int32) math32.Vector3 {
	var angAcc math32.Vector3
	angAcc.X = Dynamics.Value(int(idx), int(AngAccX))
	angAcc.Y = Dynamics.Value(int(idx), int(AngAccY))
	angAcc.Z = Dynamics.Value(int(idx), int(AngAccZ))
	return angAcc
}

func SetDynamicAngAcc(idx int32, angAcc math32.Vector3) {
	Dynamics.Set(angAcc.X, int(idx), int(AngAccX))
	Dynamics.Set(angAcc.Y, int(idx), int(AngAccY))
	Dynamics.Set(angAcc.Z, int(idx), int(AngAccZ))
}

//gosl:end
