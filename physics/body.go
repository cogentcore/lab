// Code generated by "goal build"; DO NOT EDIT.
//line body.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// BodyVars are body state variables stored in tensor.Float32
type BodyVars int32 //enums:enum

const (
	// BodyShape is the shape type of the object, as a Shapes type.
	BodyShape BodyVars = iota

	// BodyDynamic is the index into Dynamics for this body,
	// which is -1 for static bodies. Use this to get current
	// Pos and Quat values for a dynamic body.
	BodyDynamic

	// BodyWorld partitions bodies into different worlds for
	// collision detection: Global bodies = -1 can collide with
	// everything; otherwise only items within the same world collide.
	BodyWorld

	// BodyGroup partitions bodies within worlds into different groups
	// for collision detection. 0 does not collide with anything.
	// Negative numbers are global within a world, except they don't
	// collide amongst themselves (all non-dynamic bodies should go
	// in -1 because they don't collide amongst each-other, but do
	// potentially collide with dynamics).
	// Positive numbers only collide amongst themselves, and with
	// negative groups, but not other positive groups. This is for
	// more special-purpose dynamics: in general use 1 for all dynamic
	// bodies. There is an automatic constraint that the two objects
	// within a single joint do not collide with each other, so this
	// does not need to be handled here.
	BodyGroup

	// BodyHSize is the size of the object (values depend on shape type).
	BodyHSizeX
	BodyHSizeY
	BodyHSizeZ

	// BodyThick is the thickness of the body, as a hollow shape.
	// If 0, then it is a solid shape (default).
	BodyThick

	// physical properties

	// BodyMass is the mass of the object.
	BodyMass

	// BodyInvMass is 1/mass of the object or 0 if no mass.
	BodyInvMass

	// BodyBounce specifies the COR or coefficient of restitution (0..1),
	// which determines how elastic the collision is,
	// i.e., final velocity / initial velocity.
	BodyBounce

	// BodyFriction coefficient: how much friction is generated by transverse motion.
	// Additive across the two surfaces.
	BodyFriction

	// 3D position of body (structural center).
	BodyPosX
	BodyPosY
	BodyPosZ

	// Quaternion rotation of body.
	BodyQuatX
	BodyQuatY
	BodyQuatZ
	BodyQuatW

	// Relative center-of-mass offset from 3D position of body.
	BodyComX
	BodyComY
	BodyComZ

	// Inertia 3x3 matrix (column matrix organization, r,c labels).
	BodyInertiaXX
	BodyInertiaYX
	BodyInertiaZX
	BodyInertiaXY
	BodyInertiaYY
	BodyInertiaZY
	BodyInertiaXZ
	BodyInertiaYZ
	BodyInertiaZZ

	// InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).
	BodyInvInertiaXX
	BodyInvInertiaYX
	BodyInvInertiaZX
	BodyInvInertiaXY
	BodyInvInertiaYY
	BodyInvInertiaZY
	BodyInvInertiaXZ
	BodyInvInertiaYZ
	BodyInvInertiaZZ

	// radius for broadphase collision
	BodyRadius
)

func GetBodyShape(idx int32) Shapes {
	return Shapes(math.Float32bits(Bodies.Value(int(idx), int(BodyShape))))
}

func SetBodyShape(idx int32, shape Shapes) {
	Bodies.Set(math.Float32frombits(uint32(shape)), int(idx), int(BodyShape))
}

func SetBodyDynamic(idx, dynIdx int32) {
	Bodies.Set(math.Float32frombits(uint32(dynIdx)), int(idx), int(BodyDynamic))
}

func GetBodyDynamic(idx int32) int32 {
	return int32(math.Float32bits(Bodies.Value(int(idx), int(BodyDynamic))))
}

func SetBodyWorld(idx, w int32) {
	Bodies.Set(math.Float32frombits(uint32(w)), int(idx), int(BodyWorld))
}

func GetBodyWorld(idx int32) int32 {
	return int32(math.Float32bits(Bodies.Value(int(idx), int(BodyWorld))))
}

func SetBodyGroup(idx, w int32) {
	Bodies.Set(math.Float32frombits(uint32(w)), int(idx), int(BodyGroup))
}

func GetBodyGroup(idx int32) int32 {
	return int32(math.Float32bits(Bodies.Value(int(idx), int(BodyGroup))))
}

func BodyHSize(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodyHSizeX)), Bodies.Value(int(idx), int(BodyHSizeY)), Bodies.Value(int(idx), int(BodyHSizeZ)))
}

func SetBodyHSize(idx int32, size math32.Vector3) {
	Bodies.Set(size.X, int(idx), int(BodyHSizeX))
	Bodies.Set(size.Y, int(idx), int(BodyHSizeY))
	Bodies.Set(size.Z, int(idx), int(BodyHSizeZ))
}

func BodyPos(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodyPosX)), Bodies.Value(int(idx), int(BodyPosY)), Bodies.Value(int(idx), int(BodyPosZ)))
}

func SetBodyPos(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyPosX))
	Bodies.Set(pos.Y, int(idx), int(BodyPosY))
	Bodies.Set(pos.Z, int(idx), int(BodyPosZ))
}

func BodyQuat(idx int32) math32.Quat {
	return math32.NewQuat(Bodies.Value(int(idx), int(BodyQuatX)), Bodies.Value(int(idx), int(BodyQuatY)), Bodies.Value(int(idx), int(BodyQuatZ)), Bodies.Value(int(idx), int(BodyQuatW)))
}

func SetBodyQuat(idx int32, rot math32.Quat) {
	Bodies.Set(rot.X, int(idx), int(BodyQuatX))
	Bodies.Set(rot.Y, int(idx), int(BodyQuatY))
	Bodies.Set(rot.Z, int(idx), int(BodyQuatZ))
	Bodies.Set(rot.W, int(idx), int(BodyQuatW))
}

// BodyDynamicPos gets the position for dynamic bodies or
// static position if not dynamic. cni is the current / next index.
func BodyDynamicPos(idx, cni int32) math32.Vector3 {
	didx := GetBodyDynamic(idx)
	if didx < 0 {
		return BodyPos(idx)
	}
	return DynamicPos(didx, cni)
}

// BodyDynamicQuat gets the quat rotation for dynamic bodies or
// static rotation if not dynamic. cni is the current / next index.
func BodyDynamicQuat(idx, cni int32) math32.Quat {
	didx := GetBodyDynamic(idx)
	if didx < 0 {
		return BodyQuat(idx)
	}
	return DynamicQuat(didx, cni)
}

func BodyCom(idx int32) math32.Vector3 {
	return math32.Vec3(Bodies.Value(int(idx), int(BodyComX)), Bodies.Value(int(idx), int(BodyComY)), Bodies.Value(int(idx), int(BodyComZ)))
}

func SetBodyCom(idx int32, pos math32.Vector3) {
	Bodies.Set(pos.X, int(idx), int(BodyComX))
	Bodies.Set(pos.Y, int(idx), int(BodyComY))
	Bodies.Set(pos.Z, int(idx), int(BodyComZ))
}

func BodyInertia(idx int32) math32.Matrix3 {
	return math32.Mat3(Bodies.Value(int(idx), int(BodyInertiaXX)), Bodies.Value(int(idx), int(BodyInertiaYX)), Bodies.Value(int(idx), int(BodyInertiaZX)),
		Bodies.Value(int(idx), int(BodyInertiaXY)), Bodies.Value(int(idx), int(BodyInertiaYY)), Bodies.Value(int(idx), int(BodyInertiaZY)),
		Bodies.Value(int(idx), int(BodyInertiaXZ)), Bodies.Value(int(idx), int(BodyInertiaYZ)), Bodies.Value(int(idx), int(BodyInertiaZZ)))
}

func BodyInvInertia(idx int32) math32.Matrix3 {
	return math32.Mat3(Bodies.Value(int(idx), int(BodyInvInertiaXX)), Bodies.Value(int(idx), int(BodyInvInertiaYX)), Bodies.Value(int(idx), int(BodyInvInertiaZX)),
		Bodies.Value(int(idx), int(BodyInvInertiaXY)), Bodies.Value(int(idx), int(BodyInvInertiaYY)), Bodies.Value(int(idx), int(BodyInvInertiaZY)),
		Bodies.Value(int(idx), int(BodyInvInertiaXZ)), Bodies.Value(int(idx), int(BodyInvInertiaYZ)), Bodies.Value(int(idx), int(BodyInvInertiaZZ)))
}

func SetBodyInertia(idx int32, inertia math32.Matrix3) {
	for i := range 9 {
		Bodies.Set(inertia[i], int(idx), int(int(BodyInertiaXX)+i))
	}
}

func SetBodyInvInertia(idx int32, invInertia math32.Matrix3) {
	for i := range 9 {
		Bodies.Set(invInertia[i], int(idx), int(int(BodyInvInertiaXX)+i))
	}
}

//gosl:end
