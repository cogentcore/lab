// Code generated by "goal build"; DO NOT EDIT.
//line joint.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// JointVars are joint state variables stored in tensor.Float32.
// These are all static joint properties; dynamic control variables
// in [JointControlVars] and [JointControls].
type JointVars int32 //enums:enum

const (
	// JointType (as an int32 from bits).
	JointType JointVars = iota

	// JointEnabled allows joints to be dynamically enabled.
	JointEnabled

	// JointParent is the dynamic body index for parent body.
	// Can be -1 for a fixed parent for absolute anchor.
	JointParent

	// JointChild is the dynamic body index for child body.
	JointChild

	// position of joint, in parent frame.
	JointPPosX
	JointPPosY
	JointPPosZ

	// orientation of joint, in parent frame.
	JointPRotX
	JointPRotY
	JointPRotZ
	JointPRotW

	// position of joint, in child frame.
	JointCPosX
	JointCPosY
	JointCPosZ

	// orientation of joint, in child frame.
	JointCRotX
	JointCRotY
	JointCRotZ
	JointCRotW

	JointAxisX
	JointAxisY
	JointAxisZ

	// joint limits
	JointLimitLower
	JointLimitUpper

	// joint stiffness target (ke)
	JointStiffX
	JointStiffY
	JointStiffZ

	// joint damping target (kd)
	JointDampX
	JointDampY
	JointDampZ

	// Computed forces (temp storage until aggregated by bodies).

	// Computed parent joint force value.
	JointPForceX
	JointPForceY
	JointPForceZ

	// Computed parent joint torque value.
	JointPTorqueX
	JointPTorqueY
	JointPTorqueZ

	// Computed child joint force value.
	JointCForceX
	JointCForceY
	JointCForceZ

	// Computed child joint torque value.
	JointCTorqueX
	JointCTorqueY
	JointCTorqueZ

	// Computed parent joint delta value.
	JointPDeltaX
	JointPDeltaY
	JointPDeltaZ

	// Computed parent joint angdelta value.
	JointPAngDeltaX
	JointPAngDeltaY
	JointPAngDeltaZ

	// Computed child joint delta value.
	JointCDeltaX
	JointCDeltaY
	JointCDeltaZ

	// Computed child joint angdelta value.
	JointCAngDeltaX
	JointCAngDeltaY
	JointCAngDeltaZ
)

func GetJointType(idx int32) JointTypes {
	return JointTypes(math.Float32bits(Joints.Value(int(idx), int(JointType))))
}

func SetJointType(idx int32, typ JointTypes) {
	Joints.Set(math.Float32frombits(uint32(typ)), int(idx), int(JointType))
}

func SetJointParent(idx, bodyIdx int32) {
	Joints.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(JointParent))
}

func JointParentIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointParent))))
}

func SetJointChild(idx, bodyIdx int32) {
	Joints.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(JointChild))
}

func JointChildIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointChild))))
}

func JointPPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPPosX)), Joints.Value(int(idx), int(JointPPosY)), Joints.Value(int(idx), int(JointPPosZ)))
}

func SetJointPPos(idx int32, pos math32.Vector3) {
	Joints.Set(pos.X, int(idx), int(JointPPosX))
	Joints.Set(pos.Y, int(idx), int(JointPPosY))
	Joints.Set(pos.Z, int(idx), int(JointPPosZ))
}

func JointPRot(idx int32) math32.Quat {
	return math32.NewQuat(Joints.Value(int(idx), int(JointPRotX)), Joints.Value(int(idx), int(JointPRotY)), Joints.Value(int(idx), int(JointPRotZ)), Joints.Value(int(idx), int(JointPRotW)))
}

func SetJointPRot(idx int32, rot math32.Quat) {
	Joints.Set(rot.X, int(idx), int(JointPRotX))
	Joints.Set(rot.Y, int(idx), int(JointPRotY))
	Joints.Set(rot.Z, int(idx), int(JointPRotZ))
	Joints.Set(rot.W, int(idx), int(JointPRotW))
}

func JointCPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCPosX)), Joints.Value(int(idx), int(JointCPosY)), Joints.Value(int(idx), int(JointCPosZ)))
}

func SetJointCPos(idx int32, pos math32.Vector3) {
	Joints.Set(pos.X, int(idx), int(JointCPosX))
	Joints.Set(pos.Y, int(idx), int(JointCPosY))
	Joints.Set(pos.Z, int(idx), int(JointCPosZ))
}

func JointCRot(idx int32) math32.Quat {
	return math32.NewQuat(Joints.Value(int(idx), int(JointCRotX)), Joints.Value(int(idx), int(JointCRotY)), Joints.Value(int(idx), int(JointCRotZ)), Joints.Value(int(idx), int(JointCRotW)))
}

func SetJointCRot(idx int32, rot math32.Quat) {
	Joints.Set(rot.X, int(idx), int(JointCRotX))
	Joints.Set(rot.Y, int(idx), int(JointCRotY))
	Joints.Set(rot.Z, int(idx), int(JointCRotZ))
	Joints.Set(rot.W, int(idx), int(JointCRotW))
}

func JointAxis(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointAxisX)), Joints.Value(int(idx), int(JointAxisY)), Joints.Value(int(idx), int(JointAxisZ)))
}

func SetJointAxis(idx int32, axis math32.Vector3) {
	Joints.Set(axis.X, int(idx), int(JointAxisX))
	Joints.Set(axis.Y, int(idx), int(JointAxisY))
	Joints.Set(axis.Z, int(idx), int(JointAxisZ))
}

func JointStiff(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointStiffX)), Joints.Value(int(idx), int(JointStiffY)), Joints.Value(int(idx), int(JointStiffZ)))
}

func SetJointStiff(idx int32, stiff math32.Vector3) {
	Joints.Set(stiff.X, int(idx), int(JointStiffX))
	Joints.Set(stiff.Y, int(idx), int(JointStiffY))
	Joints.Set(stiff.Z, int(idx), int(JointStiffZ))
}

func JointDamp(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointDampX)), Joints.Value(int(idx), int(JointDampY)), Joints.Value(int(idx), int(JointDampZ)))
}

func SetJointDamp(idx int32, damp math32.Vector3) {
	Joints.Set(damp.X, int(idx), int(JointDampX))
	Joints.Set(damp.Y, int(idx), int(JointDampY))
	Joints.Set(damp.Z, int(idx), int(JointDampZ))
}

func JointPForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPForceX)), Joints.Value(int(idx), int(JointPForceY)), Joints.Value(int(idx), int(JointPForceZ)))
}

func SetJointPForce(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointPForceX))
	Joints.Set(f.Y, int(idx), int(JointPForceY))
	Joints.Set(f.Z, int(idx), int(JointPForceZ))
}

func JointPTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPTorqueX)), Joints.Value(int(idx), int(JointPTorqueY)), Joints.Value(int(idx), int(JointPTorqueZ)))
}

func SetJointPTorque(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointPTorqueX))
	Joints.Set(t.Y, int(idx), int(JointPTorqueY))
	Joints.Set(t.Z, int(idx), int(JointPTorqueZ))
}

func JointCForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCForceX)), Joints.Value(int(idx), int(JointCForceY)), Joints.Value(int(idx), int(JointCForceZ)))
}

func SetJointCForce(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointCForceX))
	Joints.Set(f.Y, int(idx), int(JointCForceY))
	Joints.Set(f.Z, int(idx), int(JointCForceZ))
}

func JointCTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCTorqueX)), Joints.Value(int(idx), int(JointCTorqueY)), Joints.Value(int(idx), int(JointCTorqueZ)))
}

func SetJointCTorque(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointCTorqueX))
	Joints.Set(t.Y, int(idx), int(JointCTorqueY))
	Joints.Set(t.Z, int(idx), int(JointCTorqueZ))
}

func JointPDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPDeltaX)), Joints.Value(int(idx), int(JointPDeltaY)), Joints.Value(int(idx), int(JointPDeltaZ)))
}

func SetJointPDelta(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointPDeltaX))
	Joints.Set(f.Y, int(idx), int(JointPDeltaY))
	Joints.Set(f.Z, int(idx), int(JointPDeltaZ))
}

func JointPAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPAngDeltaX)), Joints.Value(int(idx), int(JointPAngDeltaY)), Joints.Value(int(idx), int(JointPAngDeltaZ)))
}

func SetJointPAngDelta(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointPAngDeltaX))
	Joints.Set(t.Y, int(idx), int(JointPAngDeltaY))
	Joints.Set(t.Z, int(idx), int(JointPAngDeltaZ))
}

func JointCDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCDeltaX)), Joints.Value(int(idx), int(JointCDeltaY)), Joints.Value(int(idx), int(JointCDeltaZ)))
}

func SetJointCDelta(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointCDeltaX))
	Joints.Set(f.Y, int(idx), int(JointCDeltaY))
	Joints.Set(f.Z, int(idx), int(JointCDeltaZ))
}

func JointCAngDelta(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCAngDeltaX)), Joints.Value(int(idx), int(JointCAngDeltaY)), Joints.Value(int(idx), int(JointCAngDeltaZ)))
}

func SetJointCAngDelta(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointCAngDeltaX))
	Joints.Set(t.Y, int(idx), int(JointCAngDeltaY))
	Joints.Set(t.Z, int(idx), int(JointCAngDeltaZ))
}

// JointTypes are joint types that determine nature of interaction.
type JointTypes int32 //enums:enum

const (
	// Prismatic allows translation along a single axis (slider): 1 DoF.
	Prismatic JointTypes = iota

	// Revolute allows rotation about a single axis (axel): 1 DoF.
	Revolute

	// Ball allows rotation about all three axes (3 DoF, quaternion).
	Ball

	// Fixed locks all relative motion: 0 DoF.
	Fixed

	// Free allows full 6-DoF motion (translation and rotation).
	Free

	// Distance keeps two bodies a distance within joint limits: 6 DoF.
	Distance

	// D6 is a generic 6-DoF joint.
	D6
)

//gosl:end
