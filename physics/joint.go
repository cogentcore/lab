// Code generated by "goal build"; DO NOT EDIT.
//line joint.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	// "fmt"
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// Sentinel value for unlimited joint limits
const JointLimitUnlimited = 1e10

// JointTypes are joint types that determine nature of interaction.
type JointTypes int32 //enums:enum

const (
	// Prismatic allows translation along a single axis (slider): 1 DoF.
	Prismatic JointTypes = iota

	// Revolute allows rotation about a single axis (axel): 1 DoF.
	Revolute

	// Ball allows rotation about all three axes (3 DoF, quaternion).
	Ball

	// Fixed locks all relative motion: 0 DoF.
	Fixed

	// Free allows full 6-DoF motion (translation and rotation).
	Free

	// Distance keeps two bodies a distance within joint limits: 6 DoF.
	Distance

	// D6 is a generic 6-DoF joint.
	D6

	// PlaneXZ is a version of D6 for navigation in the X-Z plane,
	// which creates 2 linear DoF (X, Z) for movement.
	PlaneXZ
)

// JointVars are joint state variables stored in tensor.Float32.
// These are all static joint properties; dynamic control variables
// in [JointControlVars] and [JointControls].
type JointVars int32 //enums:enum

const (
	// JointType (as an int32 from bits).
	JointType JointVars = iota

	// JointEnabled allows joints to be dynamically enabled.
	JointEnabled

	// JointParentFixed means that the parent is NOT updated based on
	// the forces and positions for this joint. This can make dynamics
	// cleaner when full accuracy is not necessary.
	JointParentFixed

	// JointNoLinearRotation ignores the rotational (angular) effects of
	// linear joint position constraints (i.e., Coriolis and centrifugal forces)
	// which can otherwise interfere with rotational position constraints in
	// joints with both linear and angular DoFs
	// (e.g., [PlaneXZ], for which this is on by default).
	JointNoLinearRotation

	// JointParent is the dynamic body index for parent body.
	// Can be -1 for a fixed parent for absolute anchor.
	JointParent

	// JointChild is the dynamic body index for child body.
	JointChild

	// relative position of joint, in parent frame.
	// This is prior to parent body rotation.
	JointPPosX
	JointPPosY
	JointPPosZ

	// relative orientation of joint, in parent frame.
	// This is prior to parent body rotation.
	JointPQuatX
	JointPQuatY
	JointPQuatZ
	JointPQuatW

	// relative position of joint, in child frame.
	// This is prior to child body rotation.
	JointCPosX
	JointCPosY
	JointCPosZ

	// relative orientation of joint, in child frame.
	// This is prior to parent body rotation.
	JointCQuatX
	JointCQuatY
	JointCQuatZ
	JointCQuatW

	// JointLinearDoFN is the number of linear degrees-of-freedom for the joint.
	JointLinearDoFN
	// JointAngularDoFN is the number of angular degrees-of-freedom for the joint.
	JointAngularDoFN

	// indexes in JointDoFs for each DoF
	JointDoF1
	JointDoF2
	JointDoF3
	// angular starts here for Free, Distance, D6
	JointDoF4
	JointDoF5
	JointDoF6

	// Computed forces (temp storage until aggregated by bodies).

	// Computed parent joint force value.
	JointPForceX
	JointPForceY
	JointPForceZ

	// Computed parent joint torque value.
	JointPTorqueX
	JointPTorqueY
	JointPTorqueZ

	// Computed child joint force value.
	JointCForceX
	JointCForceY
	JointCForceZ

	// Computed child joint torque value.
	JointCTorqueX
	JointCTorqueY
	JointCTorqueZ

	// Computed linear lambdas.
	JointLinLambdaX
	JointLinLambdaY
	JointLinLambdaZ

	// Computed angular lambdas.
	JointAngLambdaX
	JointAngLambdaY
	JointAngLambdaZ
)

func GetJointType(idx int32) JointTypes {
	return JointTypes(math.Float32bits(Joints.Value(int(idx), int(JointType))))
}

func SetJointType(idx int32, typ JointTypes) {
	Joints.Set(math.Float32frombits(uint32(typ)), int(idx), int(JointType))
}

func GetJointEnabled(idx int32) bool {
	je := math.Float32bits(Joints.Value(int(idx), int(JointEnabled)))
	return je != 0
}

func SetJointEnabled(idx int32, enabled bool) {
	je := uint32(0)
	if enabled {
		je = 1
	}
	Joints.Set(math.Float32frombits(je), int(idx), int(JointEnabled))
}

func GetJointParentFixed(idx int32) bool {
	je := math.Float32bits(Joints.Value(int(idx), int(JointParentFixed)))
	return je != 0
}

func SetJointParentFixed(idx int32, enabled bool) {
	je := uint32(0)
	if enabled {
		je = 1
	}
	Joints.Set(math.Float32frombits(je), int(idx), int(JointParentFixed))
}

func GetJointNoLinearRotation(idx int32) bool {
	je := math.Float32bits(Joints.Value(int(idx), int(JointNoLinearRotation)))
	return je != 0
}

func SetJointNoLinearRotation(idx int32, enabled bool) {
	je := uint32(0)
	if enabled {
		je = 1
	}
	Joints.Set(math.Float32frombits(je), int(idx), int(JointNoLinearRotation))
}

func SetJointParent(idx, bodyIdx int32) {
	Joints.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(JointParent))
}

func JointParentIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointParent))))
}

func SetJointChild(idx, bodyIdx int32) {
	Joints.Set(math.Float32frombits(uint32(bodyIdx)), int(idx), int(JointChild))
}

func JointChildIndex(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointChild))))
}

func SetJointLinearDoFN(idx, dofN int32) {
	Joints.Set(math.Float32frombits(uint32(dofN)), int(idx), int(JointLinearDoFN))
}

func GetJointLinearDoFN(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointLinearDoFN))))
}

func SetJointAngularDoFN(idx, dofN int32) {
	Joints.Set(math.Float32frombits(uint32(dofN)), int(idx), int(JointAngularDoFN))
}

func GetJointAngularDoFN(idx int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(JointAngularDoFN))))
}

func SetJointDoFIndex(idx, dof, dofIdx int32) {
	Joints.Set(math.Float32frombits(uint32(dofIdx)), int(idx), int(int32(JointDoF1)+dof))
}

func JointDoFIndex(idx, dof int32) int32 {
	return int32(math.Float32bits(Joints.Value(int(idx), int(int32(JointDoF1)+dof))))
}

func JointPPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPPosX)), Joints.Value(int(idx), int(JointPPosY)), Joints.Value(int(idx), int(JointPPosZ)))
}

func SetJointPPos(idx int32, pos math32.Vector3) {
	Joints.Set(pos.X, int(idx), int(JointPPosX))
	Joints.Set(pos.Y, int(idx), int(JointPPosY))
	Joints.Set(pos.Z, int(idx), int(JointPPosZ))
}

func JointPQuat(idx int32) math32.Quat {
	return math32.NewQuat(Joints.Value(int(idx), int(JointPQuatX)), Joints.Value(int(idx), int(JointPQuatY)), Joints.Value(int(idx), int(JointPQuatZ)), Joints.Value(int(idx), int(JointPQuatW)))
}

func SetJointPQuat(idx int32, rot math32.Quat) {
	Joints.Set(rot.X, int(idx), int(JointPQuatX))
	Joints.Set(rot.Y, int(idx), int(JointPQuatY))
	Joints.Set(rot.Z, int(idx), int(JointPQuatZ))
	Joints.Set(rot.W, int(idx), int(JointPQuatW))
}

func JointCPos(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCPosX)), Joints.Value(int(idx), int(JointCPosY)), Joints.Value(int(idx), int(JointCPosZ)))
}

func SetJointCPos(idx int32, pos math32.Vector3) {
	Joints.Set(pos.X, int(idx), int(JointCPosX))
	Joints.Set(pos.Y, int(idx), int(JointCPosY))
	Joints.Set(pos.Z, int(idx), int(JointCPosZ))
}

func JointCQuat(idx int32) math32.Quat {
	return math32.NewQuat(Joints.Value(int(idx), int(JointCQuatX)), Joints.Value(int(idx), int(JointCQuatY)), Joints.Value(int(idx), int(JointCQuatZ)), Joints.Value(int(idx), int(JointCQuatW)))
}

func SetJointCQuat(idx int32, rot math32.Quat) {
	Joints.Set(rot.X, int(idx), int(JointCQuatX))
	Joints.Set(rot.Y, int(idx), int(JointCQuatY))
	Joints.Set(rot.Z, int(idx), int(JointCQuatZ))
	Joints.Set(rot.W, int(idx), int(JointCQuatW))
}

func JointPForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPForceX)), Joints.Value(int(idx), int(JointPForceY)), Joints.Value(int(idx), int(JointPForceZ)))
}

func SetJointPForce(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointPForceX))
	Joints.Set(f.Y, int(idx), int(JointPForceY))
	Joints.Set(f.Z, int(idx), int(JointPForceZ))
}

func JointPTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointPTorqueX)), Joints.Value(int(idx), int(JointPTorqueY)), Joints.Value(int(idx), int(JointPTorqueZ)))
}

func SetJointPTorque(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointPTorqueX))
	Joints.Set(t.Y, int(idx), int(JointPTorqueY))
	Joints.Set(t.Z, int(idx), int(JointPTorqueZ))
}

func JointCForce(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCForceX)), Joints.Value(int(idx), int(JointCForceY)), Joints.Value(int(idx), int(JointCForceZ)))
}

func SetJointCForce(idx int32, f math32.Vector3) {
	Joints.Set(f.X, int(idx), int(JointCForceX))
	Joints.Set(f.Y, int(idx), int(JointCForceY))
	Joints.Set(f.Z, int(idx), int(JointCForceZ))
}

func JointCTorque(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointCTorqueX)), Joints.Value(int(idx), int(JointCTorqueY)), Joints.Value(int(idx), int(JointCTorqueZ)))
}

func SetJointCTorque(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointCTorqueX))
	Joints.Set(t.Y, int(idx), int(JointCTorqueY))
	Joints.Set(t.Z, int(idx), int(JointCTorqueZ))
}

func JointLinLambda(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointLinLambdaX)), Joints.Value(int(idx), int(JointLinLambdaY)), Joints.Value(int(idx), int(JointLinLambdaZ)))
}

func SetJointLinLambda(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointLinLambdaX))
	Joints.Set(t.Y, int(idx), int(JointLinLambdaY))
	Joints.Set(t.Z, int(idx), int(JointLinLambdaZ))
}

func JointAngLambda(idx int32) math32.Vector3 {
	return math32.Vec3(Joints.Value(int(idx), int(JointAngLambdaX)), Joints.Value(int(idx), int(JointAngLambdaY)), Joints.Value(int(idx), int(JointAngLambdaZ)))
}

func SetJointAngLambda(idx int32, t math32.Vector3) {
	Joints.Set(t.X, int(idx), int(JointAngLambdaX))
	Joints.Set(t.Y, int(idx), int(JointAngLambdaY))
	Joints.Set(t.Z, int(idx), int(JointAngLambdaZ))
}

// JointDoFVars are joint DoF state variables stored in tensor.Float32,
// one for each DoF.
type JointDoFVars int32 //enums:enum

const (
	// axis of articulation for the DoF
	JointAxisX JointDoFVars = iota
	JointAxisY
	JointAxisZ

	// joint limits
	JointLimitLower
	JointLimitUpper
)

func JointAxisDoF(didx int32) math32.Vector3 {
	return math32.Vec3(JointDoFs.Value(int(didx), int(JointAxisX)), JointDoFs.Value(int(didx), int(JointAxisY)), JointDoFs.Value(int(didx), int(JointAxisZ)))
}

func SetJointAxisDoF(didx int32, axis math32.Vector3) {
	JointDoFs.Set(axis.X, int(didx), int(JointAxisX))
	JointDoFs.Set(axis.Y, int(didx), int(JointAxisY))
	JointDoFs.Set(axis.Z, int(didx), int(JointAxisZ))
}

func JointAxis(idx, dof int32) math32.Vector3 {
	return JointAxisDoF(JointDoFIndex(idx, dof))
}

func SetJointAxis(idx, dof int32, axis math32.Vector3) {
	SetJointAxisDoF(JointDoFIndex(idx, dof), axis)
}

func JointDoF(idx, dof int32, vr JointDoFVars) float32 {
	return JointDoFs.Value(int(JointDoFIndex(idx, dof)), int(vr))
}

func SetJointDoF(idx, dof int32, vr JointDoFVars, value float32) {
	JointDoFs.Set(value, int(JointDoFIndex(idx, dof)), int(vr))
}

//gosl:end

func (ml *Model) JointDefaults(idx int32) {
	rot := math32.NewQuatIdentity()
	SetJointPQuat(idx, rot)
	SetJointCQuat(idx, rot)
}

func (ml *Model) JointDoFDefaults(didx int32) {
	JointDoFs.Set(-JointLimitUnlimited, int(didx), int(JointLimitLower))
	JointDoFs.Set(JointLimitUnlimited, int(didx), int(JointLimitUpper))
	JointControls.Set(1, int(didx), int(JointTargetDamp))
}

// NewJointFixed adds a new Fixed joint
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointFixed(parent, child int32, ppos, cpos math32.Vector3) int32 {
	idx := ml.newJoint(Fixed, parent, child, ppos, cpos)
	SetJointNoLinearRotation(idx, true)
	return idx
}

// NewJointPrismatic adds a new Prismatic (slider) joint
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// axis is the axis of articulation for the joint.
func (ml *Model) NewJointPrismatic(parent, child int32, ppos, cpos, axis math32.Vector3) int32 {
	idx := ml.newJoint(Prismatic, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, 1)
	ml.newJointDoF(idx, 0, axis)
	return idx
}

// NewJointRevolute adds a new Revolute (hinge, axel) joint
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
// axis is the axis of articulation for the joint.
func (ml *Model) NewJointRevolute(parent, child int32, ppos, cpos, axis math32.Vector3) int32 {
	idx := ml.newJoint(Revolute, parent, child, ppos, cpos)
	SetJointAngularDoFN(idx, 1)
	ml.newJointDoF(idx, 0, axis)
	return idx
}

// NewJointBall adds a new Ball joint (3 angular DoF)
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointBall(parent, child int32, ppos, cpos math32.Vector3) int32 {
	idx := ml.newJoint(Ball, parent, child, ppos, cpos)
	SetJointAngularDoFN(idx, 3)
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		ml.newJointDoF(idx, int32(d), axis)
	}
	return idx
}

// NewJointPlaneXZ adds a new 3 DoF Planar motion joint suitable for
// controlling the motion of a body on the standard X-Z plane (Y = up).
// The two linear DoF control position in X, Z, and 3rd angular
// controls rotation in Y axis. Sets [JointNoLinearRotation]
// Use -1 for parent to add a world-anchored joint (typical).
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointPlaneXZ(parent, child int32, ppos, cpos math32.Vector3) int32 {
	idx := ml.NewJointD6(parent, child, ppos, cpos, 2, 1)
	ml.newJointDoF(idx, 0, math32.Vec3(1, 0, 0))
	ml.newJointDoF(idx, 1, math32.Vec3(0, 0, 1))
	ml.newJointDoF(idx, 2, math32.Vec3(0, 1, 0))
	SetJointNoLinearRotation(idx, true)
	return idx
}

// NewJointDistance adds a new Distance joint (6 DoF)
// between parent and child dynamic object indexes,
// with distance constrained only on the first linear X axis.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointDistance(parent, child int32, ppos, cpos math32.Vector3, minDist, maxDist float32) int32 {
	idx := ml.newJoint(Distance, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, 3)
	SetJointAngularDoFN(idx, 3)
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		ml.newJointDoF(idx, int32(d), axis)
	}
	for d := range math32.W {
		axis := math32.Vector3{}
		axis.SetDim(d, 1)
		ml.newJointDoF(idx, int32(d), axis)
	}
	// only on the X linear axis
	SetJointDoF(idx, 0, JointLimitLower, minDist)
	SetJointDoF(idx, 0, JointLimitUpper, maxDist)
	return idx
}

// NewJointD6 adds a new D6 6 DoF joint with given number of actual
// linear and angular degrees-of-freedom,
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointD6(parent, child int32, ppos, cpos math32.Vector3, linDoF, angDoF int32) int32 {
	idx := ml.newJoint(D6, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, linDoF)
	SetJointAngularDoFN(idx, angDoF)
	return idx
}

// NewJointFree adds a new Free joint (of which there is little point)
// between parent and child dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) NewJointFree(parent, child int32, ppos, cpos math32.Vector3) int32 {
	idx := ml.newJoint(Free, parent, child, ppos, cpos)
	SetJointLinearDoFN(idx, 0)
	SetJointAngularDoFN(idx, 0)
	return idx
}

// newJoint adds a new joint between parent and child
// dynamic object indexes.
// Use -1 for parent to add a world-anchored joint.
// ppos, cpos are the relative positions from the parent, child.
// Sets relative rotation matricies to identity by default.
func (ml *Model) newJoint(joint JointTypes, parent, child int32, ppos, cpos math32.Vector3) int32 {
	sizes := ml.Joints.ShapeSizes()
	idx := int32(sizes[0])
	params := &ml.Params[0]
	params.JointsN = idx + 1
	ml.Joints.SetShapeSizes(int(idx+1), int(JointVarsN))
	ml.JointDefaults(idx)
	SetJointType(idx, joint)
	SetJointEnabled(idx, true)
	SetJointParent(idx, parent)
	SetJointChild(idx, child)
	SetJointPPos(idx, ppos)
	SetJointCPos(idx, cpos)
	if ml.CurrentObjectJoint >= int(params.MaxObjectJoints)-1 {
		params.MaxObjectJoints = int32(ml.CurrentObjectJoint + 1)
		ml.Objects.SetShapeSizes(ml.CurrentObject+1, int(params.MaxObjectJoints+1))
	}
	ml.Objects.Set(idx, int(ml.CurrentObject), int(1+ml.CurrentObjectJoint))
	ml.CurrentObjectJoint++
	ml.Objects.Set(int32(ml.CurrentObjectJoint), int(ml.CurrentObject), int(0))
	return idx
}

// newJointDoF adds new JointDoFs and JointControls entries
// initialized to detfaults. Returns index.
func (ml *Model) newJointDoF(jidx, dof int32, axis math32.Vector3) int32 {
	sizes := ml.JointDoFs.ShapeSizes()
	didx := int32(sizes[0])
	ml.JointDoFs.SetShapeSizes(int(didx+1), int(JointDoFVarsN))
	ml.JointControls.SetShapeSizes(int(didx+1), int(JointControlVarsN))
	ml.Params[0].JointDoFsN = didx + 1
	ml.JointDoFDefaults(didx)
	SetJointDoFIndex(jidx, dof, didx)
	SetJointAxis(jidx, dof, axis)
	return didx
}
