// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"math"

	"cogentcore.org/core/math32"
)

//gosl:start

// BodyVars are body state variables stored in tensor.Float32
type BodyVars int32 //enums:enum

const (
	// Shape is the shape type of the object, as a Shapes type.
	Shape BodyVars = iota

	// WorldIndex partitions body into different worlds; Global are -1
	WorldIndex

	// Size is the size of the object (values depend on shape type).
	SizeX
	SizeY
	SizeZ

	// physical properties

	// Mass is the mass of the object.
	Mass

	// InvMass is 1/mass of the object or 0 if no mass.
	InvMass

	// Bounce specifies the COR or coefficient of restitution (0..1),
	// which determines how elastic the collision is,
	// i.e., final velocity / initial velocity.
	Bounce

	// Friction coefficient: how much friction is generated by transverse motion.
	// Additive across the two surfaces.
	Friction

	// 3D position of body (structural center).
	BodyPosX
	BodyPosY
	BodyPosZ

	// Quaternion rotation of body.
	BodyRotX
	BodyRotY
	BodyRotZ
	BodyRotW

	// Relative center-of-mass offset from 3D position of body.
	BodyComX
	BodyComY
	BodyComZ

	// Inertia 3x3 matrix (column matrix organization, r,c labels).
	InertiaXX
	InertiaYX
	InertiaZX
	InertiaXY
	InertiaYY
	InertiaZY
	InertiaXZ
	InertiaYZ
	InertiaZZ

	// InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).
	InvInertiaXX
	InvInertiaYX
	InvInertiaZX
	InvInertiaXY
	InvInertiaYY
	InvInertiaZY
	InvInertiaXZ
	InvInertiaYZ
	InvInertiaZZ
)

func BodyShape(idx int32) Shapes {
	return Shapes(math.Float32bits(Bodies[idx, Shape]))
}

func SetBodyShape(idx int32, shape Shapes) {
	Bodies[idx, Shape] = math.Float32frombits(uint32(shape))
}

func BodySize(idx int32) math32.Vector3 {
	var size math32.Vector3
	size.X = Bodies[idx, SizeX]
	size.Y = Bodies[idx, SizeY]
	size.Z = Bodies[idx, SizeZ]
	return size
}

func SetBodySize(idx int32, size math32.Vector3) {
	Bodies[idx, SizeX] = size.X
	Bodies[idx, SizeY] = size.Y
	Bodies[idx, SizeZ] = size.Z
}

func BodyPos(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Bodies[idx, BodyPosX]
	pos.Y = Bodies[idx, BodyPosY]
	pos.Z = Bodies[idx, BodyPosZ]
	return pos
}

func SetBodyPos(idx int32, pos math32.Vector3) {
	Bodies[idx, BodyPosX] = pos.X
	Bodies[idx, BodyPosY] = pos.Y
	Bodies[idx, BodyPosZ] = pos.Z
}

func BodyRot(idx int32) math32.Quat {
	var rot math32.Quat
	rot.X = Bodies[idx, BodyRotX]
	rot.Y = Bodies[idx, BodyRotY]
	rot.Z = Bodies[idx, BodyRotZ]
	rot.W = Bodies[idx, BodyRotW]
	return rot
}

func SetBodyRot(idx int32, rot math32.Quat) {
	Bodies[idx, BodyRotX] = rot.X
	Bodies[idx, BodyRotY] = rot.Y
	Bodies[idx, BodyRotZ] = rot.Z
	Bodies[idx, BodyRotW] = rot.W
}

func BodyCom(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Bodies[idx, BodyComX]
	pos.Y = Bodies[idx, BodyComY]
	pos.Z = Bodies[idx, BodyComZ]
	return pos
}

func SetBodyCom(idx int32, pos math32.Vector3) {
	Bodies[idx, BodyComX] = pos.X
	Bodies[idx, BodyComY] = pos.Y
	Bodies[idx, BodyComZ] = pos.Z
}

// DynamicVars are dynamic body variables stored in tensor.Float32.
type DynamicVars int32 //enums:enum

const (
	// Index of body in list of bodies.
	Index DynamicVars = iota

	// 3D position of center of mass.
	PosX
	PosY
	PosZ

	// Quaternion rotation.
	RotX
	RotY
	RotZ
	RotW

	// Linear velocity.
	VelX
	VelY
	VelZ

	// Angular velocity.
	AngVelX
	AngVelY
	AngVelZ

	// Linear acceleration.
	AccX
	AccY
	AccZ

	// Angular acceleration due to applied torques.
	AngAccX
	AngAccY
	AngAccZ

	// Linear force driving linear acceleration.
	// joints write to this using atomic. must clear after each step.
	ForceX
	ForceY
	ForceZ

	// Linear force driving linear acceleration.
	// joints write to this using atomic. must clear after each step.
	TorqueX
	TorqueY
	TorqueZ

	// Linear deltas.
	DeltaX
	DeltaY
	DeltaZ

	// Angular deltas.
	AngDeltaX
	AngDeltaY
	AngDeltaZ
)

func SetDynamicIndex(idx, bodyIdx int32) {
	Dynamics[idx, Index] = math.Float32frombits(uint32(bodyIdx))
}

func DynamicIndex(idx int32) int32 {
	return int32(math.Float32bits(Dynamics[idx, Index]))
}

func DynamicPos(idx int32) math32.Vector3 {
	var pos math32.Vector3
	pos.X = Dynamics[idx, PosX]
	pos.Y = Dynamics[idx, PosY]
	pos.Z = Dynamics[idx, PosZ]
	return pos
}

func SetDynamicPos(idx int32, pos math32.Vector3) {
	Dynamics[idx, PosX] = pos.X
	Dynamics[idx, PosY] = pos.Y
	Dynamics[idx, PosZ] = pos.Z
}

func DynamicRot(idx int32) math32.Quat {
	var rot math32.Quat
	rot.X = Dynamics[idx, RotX]
	rot.Y = Dynamics[idx, RotY]
	rot.Z = Dynamics[idx, RotZ]
	rot.W = Dynamics[idx, RotW]
	return rot
}

func SetDynamicRot(idx int32, rot math32.Quat) {
	Dynamics[idx, RotX] = rot.X
	Dynamics[idx, RotY] = rot.Y
	Dynamics[idx, RotZ] = rot.Z
	Dynamics[idx, RotW] = rot.W
}

func DynamicVel(idx int32) math32.Vector3 {
	var vel math32.Vector3
	vel.X = Dynamics[idx, VelX]
	vel.Y = Dynamics[idx, VelY]
	vel.Z = Dynamics[idx, VelZ]
	return vel
}

func SetDynamicVel(idx int32, vel math32.Vector3) {
	Dynamics[idx, VelX] = vel.X
	Dynamics[idx, VelY] = vel.Y
	Dynamics[idx, VelZ] = vel.Z
}

func DynamicAcc(idx int32) math32.Vector3 {
	var acc math32.Vector3
	acc.X = Dynamics[idx, AccX]
	acc.Y = Dynamics[idx, AccY]
	acc.Z = Dynamics[idx, AccZ]
	return acc
}

func SetDynamicAcc(idx int32, acc math32.Vector3) {
	Dynamics[idx, AccX] = acc.X
	Dynamics[idx, AccY] = acc.Y
	Dynamics[idx, AccZ] = acc.Z
}

func DynamicForce(idx int32) math32.Vector3 {
	var force math32.Vector3
	force.X = Dynamics[idx, ForceX]
	force.Y = Dynamics[idx, ForceY]
	force.Z = Dynamics[idx, ForceZ]
	return force
}

func SetDynamicForce(idx int32, force math32.Vector3) {
	Dynamics[idx, ForceX] = force.X
	Dynamics[idx, ForceY] = force.Y
	Dynamics[idx, ForceZ] = force.Z
}

func DynamicAngVel(idx int32) math32.Vector3 {
	var angVel math32.Vector3
	angVel.X = Dynamics[idx, AngVelX]
	angVel.Y = Dynamics[idx, AngVelY]
	angVel.Z = Dynamics[idx, AngVelZ]
	return angVel
}

func SetDynamicAngVel(idx int32, angVel math32.Vector3) {
	Dynamics[idx, AngVelX] = angVel.X
	Dynamics[idx, AngVelY] = angVel.Y
	Dynamics[idx, AngVelZ] = angVel.Z
}

func DynamicAngAcc(idx int32) math32.Vector3 {
	var angAcc math32.Vector3
	angAcc.X = Dynamics[idx, AngAccX]
	angAcc.Y = Dynamics[idx, AngAccY]
	angAcc.Z = Dynamics[idx, AngAccZ]
	return angAcc
}

func SetDynamicAngAcc(idx int32, angAcc math32.Vector3) {
	Dynamics[idx, AngAccX] = angAcc.X
	Dynamics[idx, AngAccY] = angAcc.Y
	Dynamics[idx, AngAccZ] = angAcc.Z
}

//gosl:end
