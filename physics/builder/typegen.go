// Code generated by "core generate -add-types -setters"; DO NOT EDIT.

package builder

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/core/math32/minmax"
	"cogentcore.org/core/types"
	"cogentcore.org/lab/physics"
	"cogentcore.org/lab/physics/phyxyz"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Body", IDName: "body", Doc: "Body is a rigid body.", Fields: []types.Field{{Name: "ObjectIndex", Doc: "ObjectIndex is the index of body within parent [Object],\nwhich is used for id in [Builder] context."}, {Name: "Shape", Doc: "Shape of the body."}, {Name: "Dynamic", Doc: "Dynamic makes this a dynamic body."}, {Name: "Group", Doc: "Group partitions bodies within worlds into different groups\nfor collision detection. 0 does not collide with anything.\nNegative numbers are global within a world, except they don't\ncollide amongst themselves (all non-dynamic bodies should go\nin -1 because they don't collide amongst each-other, but do\npotentially collide with dynamics).\nPositive numbers only collide amongst themselves, and with\nnegative groups, but not other positive groups. To avoid\nunwanted collisions, put bodies into separate groups.\nThere is an automatic constraint that the two objects\nwithin a single joint do not collide with each other, so this\ndoes not need to be handled here."}, {Name: "HSize", Doc: "HSize is the half-size (e.g., radius) of the body.\nValues depend on shape type: X is generally radius,\nY is half-height."}, {Name: "Thick", Doc: "Thick is the thickness of the body, as a hollow shape.\nIf 0, then it is a solid shape (default)."}, {Name: "Mass", Doc: "Mass of the object. Only relevant for Dynamic bodies."}, {Name: "Pose", Doc: "Pose has the position and rotation."}, {Name: "Com", Doc: "Com is the center-of-mass offset from the Pose.Pos."}, {Name: "Bounce", Doc: "Bounce specifies the COR or coefficient of restitution (0..1),\nwhich determines how elastic the collision is,\ni.e., final velocity / initial velocity."}, {Name: "Friction", Doc: "Friction is the standard coefficient for linear friction (mu)."}, {Name: "FrictionTortion", Doc: "FrictionTortion is resistance to spinning at the contact point."}, {Name: "FrictionRolling", Doc: "FrictionRolling is resistance to rolling motion at contact."}, {Name: "Skin", Doc: "Optional [phyxyz.Skin] for visualizing the body."}, {Name: "BodyIndex", Doc: "BodyIndex is the index of this body in the [physics.Model] Bodies list,\nonce built."}, {Name: "DynamicIndex", Doc: "DynamicIndex is the index of this dynamic body in the\n[physics.Model] Dynamics list, once built."}}})

// SetObjectIndex sets the [Body.ObjectIndex]:
// ObjectIndex is the index of body within parent [Object],
// which is used for id in [Builder] context.
func (t *Body) SetObjectIndex(v int) *Body { t.ObjectIndex = v; return t }

// SetShape sets the [Body.Shape]:
// Shape of the body.
func (t *Body) SetShape(v physics.Shapes) *Body { t.Shape = v; return t }

// SetDynamic sets the [Body.Dynamic]:
// Dynamic makes this a dynamic body.
func (t *Body) SetDynamic(v bool) *Body { t.Dynamic = v; return t }

// SetGroup sets the [Body.Group]:
// Group partitions bodies within worlds into different groups
// for collision detection. 0 does not collide with anything.
// Negative numbers are global within a world, except they don't
// collide amongst themselves (all non-dynamic bodies should go
// in -1 because they don't collide amongst each-other, but do
// potentially collide with dynamics).
// Positive numbers only collide amongst themselves, and with
// negative groups, but not other positive groups. To avoid
// unwanted collisions, put bodies into separate groups.
// There is an automatic constraint that the two objects
// within a single joint do not collide with each other, so this
// does not need to be handled here.
func (t *Body) SetGroup(v int) *Body { t.Group = v; return t }

// SetHSize sets the [Body.HSize]:
// HSize is the half-size (e.g., radius) of the body.
// Values depend on shape type: X is generally radius,
// Y is half-height.
func (t *Body) SetHSize(v math32.Vector3) *Body { t.HSize = v; return t }

// SetThick sets the [Body.Thick]:
// Thick is the thickness of the body, as a hollow shape.
// If 0, then it is a solid shape (default).
func (t *Body) SetThick(v float32) *Body { t.Thick = v; return t }

// SetMass sets the [Body.Mass]:
// Mass of the object. Only relevant for Dynamic bodies.
func (t *Body) SetMass(v float32) *Body { t.Mass = v; return t }

// SetPose sets the [Body.Pose]:
// Pose has the position and rotation.
func (t *Body) SetPose(v Pose) *Body { t.Pose = v; return t }

// SetCom sets the [Body.Com]:
// Com is the center-of-mass offset from the Pose.Pos.
func (t *Body) SetCom(v math32.Vector3) *Body { t.Com = v; return t }

// SetBounce sets the [Body.Bounce]:
// Bounce specifies the COR or coefficient of restitution (0..1),
// which determines how elastic the collision is,
// i.e., final velocity / initial velocity.
func (t *Body) SetBounce(v float32) *Body { t.Bounce = v; return t }

// SetFriction sets the [Body.Friction]:
// Friction is the standard coefficient for linear friction (mu).
func (t *Body) SetFriction(v float32) *Body { t.Friction = v; return t }

// SetFrictionTortion sets the [Body.FrictionTortion]:
// FrictionTortion is resistance to spinning at the contact point.
func (t *Body) SetFrictionTortion(v float32) *Body { t.FrictionTortion = v; return t }

// SetFrictionRolling sets the [Body.FrictionRolling]:
// FrictionRolling is resistance to rolling motion at contact.
func (t *Body) SetFrictionRolling(v float32) *Body { t.FrictionRolling = v; return t }

// SetSkin sets the [Body.Skin]:
// Optional [phyxyz.Skin] for visualizing the body.
func (t *Body) SetSkin(v *phyxyz.Skin) *Body { t.Skin = v; return t }

// SetBodyIndex sets the [Body.BodyIndex]:
// BodyIndex is the index of this body in the [physics.Model] Bodies list,
// once built.
func (t *Body) SetBodyIndex(v int32) *Body { t.BodyIndex = v; return t }

// SetDynamicIndex sets the [Body.DynamicIndex]:
// DynamicIndex is the index of this dynamic body in the
// [physics.Model] Dynamics list, once built.
func (t *Body) SetDynamicIndex(v int32) *Body { t.DynamicIndex = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Builder", IDName: "builder", Doc: "Builder is the global container of [physics.Model] elements,\norganized into worlds that are independently updated.", Fields: []types.Field{{Name: "Worlds", Doc: "Worlds are the independent world elements."}, {Name: "ReplicasStart", Doc: "ReplicasStart is the starting Worlds index for replicated world bodies.\nSet by ReplicateWorld, and used to set corresponding value in Model."}, {Name: "ReplicasN", Doc: "ReplicasN is the total number of replicated Worlds (including source).\nSet by ReplicateWorld, and used to set corresponding value in Model."}}})

// SetWorlds sets the [Builder.Worlds]:
// Worlds are the independent world elements.
func (t *Builder) SetWorlds(v ...*World) *Builder { t.Worlds = v; return t }

// SetReplicasStart sets the [Builder.ReplicasStart]:
// ReplicasStart is the starting Worlds index for replicated world bodies.
// Set by ReplicateWorld, and used to set corresponding value in Model.
func (t *Builder) SetReplicasStart(v int) *Builder { t.ReplicasStart = v; return t }

// SetReplicasN sets the [Builder.ReplicasN]:
// ReplicasN is the total number of replicated Worlds (including source).
// Set by ReplicateWorld, and used to set corresponding value in Model.
func (t *Builder) SetReplicasN(v int) *Builder { t.ReplicasN = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Joint", IDName: "joint", Doc: "Joint describes a joint between two bodies.", Fields: []types.Field{{Name: "Parent", Doc: "Parent is index within an Object for parent body.\n-1 for world-anchored parent."}, {Name: "Child", Doc: "Parent is index within an Object for parent body."}, {Name: "Type", Doc: "Type is the type of the joint."}, {Name: "PPose", Doc: "PPose is the parent position and orientation of the joint\nin the parent's body-centered coordinates."}, {Name: "CPose", Doc: "CPose is the child position and orientation of the joint\nin the parent's body-centered coordinates."}, {Name: "ParentFixed", Doc: "ParentFixed does not update the parent side of the joint."}, {Name: "NoLinearRotation", Doc: "NoLinearRotation ignores the rotational (angular) effects of\nlinear joint position constraints (i.e., Coriolis and centrifugal forces)\nwhich can otherwise interfere with rotational position constraints in\njoints with both linear and angular DoFs\n(e.g., [PlaneXZ], for which this is on by default)."}, {Name: "LinearDoFN", Doc: "LinearDoFN is the number of linear degrees of freedom (3 max)."}, {Name: "AngularDoFN", Doc: "AngularDoFN is the number of linear degrees of freedom (3 max)."}, {Name: "DoFs", Doc: "DoFs are the degrees-of-freedom for this joint."}, {Name: "JointIndex", Doc: "JointIndex is the index of this joint in [physics.Joints] when built."}}})

// SetParent sets the [Joint.Parent]:
// Parent is index within an Object for parent body.
// -1 for world-anchored parent.
func (t *Joint) SetParent(v int) *Joint { t.Parent = v; return t }

// SetChild sets the [Joint.Child]:
// Parent is index within an Object for parent body.
func (t *Joint) SetChild(v int) *Joint { t.Child = v; return t }

// SetType sets the [Joint.Type]:
// Type is the type of the joint.
func (t *Joint) SetType(v physics.JointTypes) *Joint { t.Type = v; return t }

// SetPPose sets the [Joint.PPose]:
// PPose is the parent position and orientation of the joint
// in the parent's body-centered coordinates.
func (t *Joint) SetPPose(v Pose) *Joint { t.PPose = v; return t }

// SetCPose sets the [Joint.CPose]:
// CPose is the child position and orientation of the joint
// in the parent's body-centered coordinates.
func (t *Joint) SetCPose(v Pose) *Joint { t.CPose = v; return t }

// SetParentFixed sets the [Joint.ParentFixed]:
// ParentFixed does not update the parent side of the joint.
func (t *Joint) SetParentFixed(v bool) *Joint { t.ParentFixed = v; return t }

// SetNoLinearRotation sets the [Joint.NoLinearRotation]:
// NoLinearRotation ignores the rotational (angular) effects of
// linear joint position constraints (i.e., Coriolis and centrifugal forces)
// which can otherwise interfere with rotational position constraints in
// joints with both linear and angular DoFs
// (e.g., [PlaneXZ], for which this is on by default).
func (t *Joint) SetNoLinearRotation(v bool) *Joint { t.NoLinearRotation = v; return t }

// SetLinearDoFN sets the [Joint.LinearDoFN]:
// LinearDoFN is the number of linear degrees of freedom (3 max).
func (t *Joint) SetLinearDoFN(v int) *Joint { t.LinearDoFN = v; return t }

// SetAngularDoFN sets the [Joint.AngularDoFN]:
// AngularDoFN is the number of linear degrees of freedom (3 max).
func (t *Joint) SetAngularDoFN(v int) *Joint { t.AngularDoFN = v; return t }

// SetDoFs sets the [Joint.DoFs]:
// DoFs are the degrees-of-freedom for this joint.
func (t *Joint) SetDoFs(v ...*DoF) *Joint { t.DoFs = v; return t }

// SetJointIndex sets the [Joint.JointIndex]:
// JointIndex is the index of this joint in [physics.Joints] when built.
func (t *Joint) SetJointIndex(v int32) *Joint { t.JointIndex = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Controls", IDName: "controls", Doc: "Controls are the per degrees-of-freedom (DoF) joint control inputs.", Fields: []types.Field{{Name: "Force", Doc: "Force is the force input driving the joint."}, {Name: "Pos", Doc: "Pos is the position target value, where 0 is the initial\nposition. For angular joints, this is in radians."}, {Name: "Stiff", Doc: "Stiff determines how strongly the target position\nis enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher).\nSet to 0 to allow the joint to be fully flexible."}, {Name: "Vel", Doc: "Vel is the velocity target value. For example, 0\neffectively damps joint movement in proportion to Damp parameter."}, {Name: "Damp", Doc: "Damp determines how strongly the target velocity is enforced:\n0 = not at all; larger = stronger (e.g., 1 is reasonable).\nSet to 0 to allow the joint to be fully flexible."}}})

// SetForce sets the [Controls.Force]:
// Force is the force input driving the joint.
func (t *Controls) SetForce(v float32) *Controls { t.Force = v; return t }

// SetPos sets the [Controls.Pos]:
// Pos is the position target value, where 0 is the initial
// position. For angular joints, this is in radians.
func (t *Controls) SetPos(v float32) *Controls { t.Pos = v; return t }

// SetStiff sets the [Controls.Stiff]:
// Stiff determines how strongly the target position
// is enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher).
// Set to 0 to allow the joint to be fully flexible.
func (t *Controls) SetStiff(v float32) *Controls { t.Stiff = v; return t }

// SetVel sets the [Controls.Vel]:
// Vel is the velocity target value. For example, 0
// effectively damps joint movement in proportion to Damp parameter.
func (t *Controls) SetVel(v float32) *Controls { t.Vel = v; return t }

// SetDamp sets the [Controls.Damp]:
// Damp determines how strongly the target velocity is enforced:
// 0 = not at all; larger = stronger (e.g., 1 is reasonable).
// Set to 0 to allow the joint to be fully flexible.
func (t *Controls) SetDamp(v float32) *Controls { t.Damp = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.DoF", IDName: "do-f", Doc: "DoF is a degree-of-freedom for a [Joint].", Fields: []types.Field{{Name: "Axis", Doc: "Axis is the axis of articulation."}, {Name: "Limit", Doc: "Limit has the limits for motion of this DoF."}, {Name: "Init", Doc: "Init are the initial control values."}, {Name: "Current", Doc: "Current are the current control values (based on method calls)."}}})

// SetAxis sets the [DoF.Axis]:
// Axis is the axis of articulation.
func (t *DoF) SetAxis(v math32.Vector3) *DoF { t.Axis = v; return t }

// SetLimit sets the [DoF.Limit]:
// Limit has the limits for motion of this DoF.
func (t *DoF) SetLimit(v minmax.F32) *DoF { t.Limit = v; return t }

// SetInit sets the [DoF.Init]:
// Init are the initial control values.
func (t *DoF) SetInit(v Controls) *DoF { t.Init = v; return t }

// SetCurrent sets the [DoF.Current]:
// Current are the current control values (based on method calls).
func (t *DoF) SetCurrent(v Controls) *DoF { t.Current = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Object", IDName: "object", Doc: "Object is an object within the [World].\nEach object is a coherent collection of bodies, typically\nconnected by joints. This is an organizational convenience\nfor positioning elements; has no physical implications.", Fields: []types.Field{{Name: "Bodies", Doc: "Bodies are the bodies in the object."}, {Name: "Joints", Doc: "Joints are joints connecting object bodies.\nJoint indexes here refer strictly within bodies."}, {Name: "Sensors", Doc: "Sensors are functions that can be configured to report arbitrary values\non given body element. The output must be stored directly somewhere via\nthe closure function: the utility of the sensor function is being able\nto capture all the configuration-time parameters needed to make it work,\nand to have it automatically called on replicated objects."}}})

// SetBodies sets the [Object.Bodies]:
// Bodies are the bodies in the object.
func (t *Object) SetBodies(v ...*Body) *Object { t.Bodies = v; return t }

// SetJoints sets the [Object.Joints]:
// Joints are joints connecting object bodies.
// Joint indexes here refer strictly within bodies.
func (t *Object) SetJoints(v ...*Joint) *Object { t.Joints = v; return t }

// SetSensors sets the [Object.Sensors]:
// Sensors are functions that can be configured to report arbitrary values
// on given body element. The output must be stored directly somewhere via
// the closure function: the utility of the sensor function is being able
// to capture all the configuration-time parameters needed to make it work,
// and to have it automatically called on replicated objects.
func (t *Object) SetSensors(v ...func(obj *Object)) *Object { t.Sensors = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Physics", IDName: "physics", Doc: "Physics provides a container and manager for the main physics elements:\n[Builder], [physics.Model], and [phyxyz.Scene]. This is helpful for\nmodels used within other apps (e.g., an AI simulation), whereas\n[phyxyz.Editor] provides a standalone GUI interface for testing models.", Fields: []types.Field{{Name: "Model", Doc: "Model has the physics Model."}, {Name: "Builder", Doc: "Builder for configuring the Model."}, {Name: "Scene", Doc: "Scene for visualizing the Model"}}})

// SetModel sets the [Physics.Model]:
// Model has the physics Model.
func (t *Physics) SetModel(v *physics.Model) *Physics { t.Model = v; return t }

// SetBuilder sets the [Physics.Builder]:
// Builder for configuring the Model.
func (t *Physics) SetBuilder(v *Builder) *Physics { t.Builder = v; return t }

// SetScene sets the [Physics.Scene]:
// Scene for visualizing the Model
func (t *Physics) SetScene(v *phyxyz.Scene) *Physics { t.Scene = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Pose", IDName: "pose", Doc: "Pose represents the 3D position and rotation.", Methods: []types.Method{{Name: "MoveOnAxis", Doc: "MoveOnAxis moves (translates) the specified distance on the specified local axis,\nrelative to the current rotation orientation.\nThe axis is normalized prior to aplying the distance factor.\nSets the LinVel to motion vector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "dist"}}, {Name: "MoveOnAxisAbs", Doc: "MoveOnAxisAbs moves (translates) the specified distance on the specified local axis,\nin absolute X,Y,Z coordinates (does not apply the Quat rotation factor.\nThe axis is normalized prior to aplying the distance factor.\nSets the LinVel to motion vector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "dist"}}, {Name: "SetEulerRotation", Doc: "SetEulerRotation sets the rotation in Euler angles (degrees).", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z"}}, {Name: "EulerRotation", Doc: "EulerRotation returns the current rotation in Euler angles (degrees).", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"Vector3"}}, {Name: "SetAxisRotation", Doc: "SetAxisRotation sets rotation from local axis and angle in degrees.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "angle"}}, {Name: "RotateOnAxis", Doc: "RotateOnAxis rotates around the specified local axis the specified angle in degrees.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "angle"}}, {Name: "RotateEuler", Doc: "RotateEuler rotates by given Euler angles (in degrees) relative to existing rotation.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z"}}}, Fields: []types.Field{{Name: "Pos", Doc: "Pos is the position of center of mass of object."}, {Name: "Quat", Doc: "Quat is the rotation specified as a quaternion."}}})

// SetPos sets the [Pose.Pos]:
// Pos is the position of center of mass of object.
func (t *Pose) SetPos(v math32.Vector3) *Pose { t.Pos = v; return t }

// SetQuat sets the [Pose.Quat]:
// Quat is the rotation specified as a quaternion.
func (t *Pose) SetQuat(v math32.Quat) *Pose { t.Quat = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.World", IDName: "world", Doc: "World is one world within the Builder.", Fields: []types.Field{{Name: "World", Doc: "World is the world index. -1 = globals, else positive.. are distinct\nnon-interacting worlds."}, {Name: "Objects", Doc: "Objects are the objects within the [World].\nEach object is a coherent collection of bodies, typically\nconnected by joints. This is an organizational convenience\nfor positioning elements; has no physical implications."}}})

// SetWorld sets the [World.World]:
// World is the world index. -1 = globals, else positive.. are distinct
// non-interacting worlds.
func (t *World) SetWorld(v int) *World { t.World = v; return t }

// SetObjects sets the [World.Objects]:
// Objects are the objects within the [World].
// Each object is a coherent collection of bodies, typically
// connected by joints. This is an organizational convenience
// for positioning elements; has no physical implications.
func (t *World) SetObjects(v ...*Object) *World { t.Objects = v; return t }
