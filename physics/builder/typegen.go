// Code generated by "core generate -add-types -setters"; DO NOT EDIT.

package builder

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/core/math32/minmax"
	"cogentcore.org/core/types"
	"cogentcore.org/lab/physics"
	"cogentcore.org/lab/physics/phyxyz"
)

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Body", IDName: "body", Doc: "Body is a rigid body.", Fields: []types.Field{{Name: "ObjectIndex", Doc: "ObjectIndex is the index of body within parent [Object],\nwhich is used for id in [Builder] context."}, {Name: "Shape", Doc: "Shape of the body."}, {Name: "Dynamic", Doc: "Dynamic makes this a dynamic body."}, {Name: "Group", Doc: "Group partitions bodies within worlds into different groups\nfor collision detection. 0 does not collide with anything.\nNegative numbers are global within a world, except they don't\ncollide amongst themselves (all non-dynamic bodies should go\nin -1 because they don't collide amongst each-other, but do\npotentially collide with dynamics).\nPositive numbers only collide amongst themselves, and with\nnegative groups, but not other positive groups. To avoid\nunwanted collisions, put bodies into separate groups.\nThere is an automatic constraint that the two objects\nwithin a single joint do not collide with each other, so this\ndoes not need to be handled here."}, {Name: "HSize", Doc: "HSize is the half-size (e.g., radius) of the body.\nValues depend on shape type: X is generally radius,\nY is half-height."}, {Name: "Thick", Doc: "Thick is the thickness of the body, as a hollow shape.\nIf 0, then it is a solid shape (default)."}, {Name: "Mass", Doc: "Mass of the object. Only relevant for Dynamic bodies."}, {Name: "Pose", Doc: "Pose has the position and rotation."}, {Name: "Com", Doc: "Com is the center-of-mass offset from the Pose.Pos."}, {Name: "Bounce", Doc: "Bounce specifies the COR or coefficient of restitution (0..1),\nwhich determines how elastic the collision is,\ni.e., final velocity / initial velocity."}, {Name: "Friction", Doc: "Friction is the standard coefficient for linear friction (mu)."}, {Name: "FrictionTortion", Doc: "FrictionTortion is resistance to spinning at the contact point."}, {Name: "FrictionRolling", Doc: "FrictionRolling is resistance to rolling motion at contact."}, {Name: "Skin", Doc: "Optional [phyxyz.Skin] for visualizing the body."}, {Name: "BodyIndex", Doc: "BodyIndex is the index of this body in the [physics.Model] Bodies list,\nonce built."}, {Name: "DynamicIndex", Doc: "DynamicIndex is the index of this dynamic body in the\n[physics.Model] Dynamics list, once built."}}})

// SetObjectIndex sets the [Body.ObjectIndex]:
// ObjectIndex is the index of body within parent [Object],
// which is used for id in [Builder] context.
func (t *Body) SetObjectIndex(v int) *Body { t.ObjectIndex = v; return t }

// SetShape sets the [Body.Shape]:
// Shape of the body.
func (t *Body) SetShape(v physics.Shapes) *Body { t.Shape = v; return t }

// SetDynamic sets the [Body.Dynamic]:
// Dynamic makes this a dynamic body.
func (t *Body) SetDynamic(v bool) *Body { t.Dynamic = v; return t }

// SetGroup sets the [Body.Group]:
// Group partitions bodies within worlds into different groups
// for collision detection. 0 does not collide with anything.
// Negative numbers are global within a world, except they don't
// collide amongst themselves (all non-dynamic bodies should go
// in -1 because they don't collide amongst each-other, but do
// potentially collide with dynamics).
// Positive numbers only collide amongst themselves, and with
// negative groups, but not other positive groups. To avoid
// unwanted collisions, put bodies into separate groups.
// There is an automatic constraint that the two objects
// within a single joint do not collide with each other, so this
// does not need to be handled here.
func (t *Body) SetGroup(v int) *Body { t.Group = v; return t }

// SetHSize sets the [Body.HSize]:
// HSize is the half-size (e.g., radius) of the body.
// Values depend on shape type: X is generally radius,
// Y is half-height.
func (t *Body) SetHSize(v math32.Vector3) *Body { t.HSize = v; return t }

// SetThick sets the [Body.Thick]:
// Thick is the thickness of the body, as a hollow shape.
// If 0, then it is a solid shape (default).
func (t *Body) SetThick(v float32) *Body { t.Thick = v; return t }

// SetMass sets the [Body.Mass]:
// Mass of the object. Only relevant for Dynamic bodies.
func (t *Body) SetMass(v float32) *Body { t.Mass = v; return t }

// SetPose sets the [Body.Pose]:
// Pose has the position and rotation.
func (t *Body) SetPose(v Pose) *Body { t.Pose = v; return t }

// SetCom sets the [Body.Com]:
// Com is the center-of-mass offset from the Pose.Pos.
func (t *Body) SetCom(v math32.Vector3) *Body { t.Com = v; return t }

// SetBounce sets the [Body.Bounce]:
// Bounce specifies the COR or coefficient of restitution (0..1),
// which determines how elastic the collision is,
// i.e., final velocity / initial velocity.
func (t *Body) SetBounce(v float32) *Body { t.Bounce = v; return t }

// SetFriction sets the [Body.Friction]:
// Friction is the standard coefficient for linear friction (mu).
func (t *Body) SetFriction(v float32) *Body { t.Friction = v; return t }

// SetFrictionTortion sets the [Body.FrictionTortion]:
// FrictionTortion is resistance to spinning at the contact point.
func (t *Body) SetFrictionTortion(v float32) *Body { t.FrictionTortion = v; return t }

// SetFrictionRolling sets the [Body.FrictionRolling]:
// FrictionRolling is resistance to rolling motion at contact.
func (t *Body) SetFrictionRolling(v float32) *Body { t.FrictionRolling = v; return t }

// SetSkin sets the [Body.Skin]:
// Optional [phyxyz.Skin] for visualizing the body.
func (t *Body) SetSkin(v *phyxyz.Skin) *Body { t.Skin = v; return t }

// SetBodyIndex sets the [Body.BodyIndex]:
// BodyIndex is the index of this body in the [physics.Model] Bodies list,
// once built.
func (t *Body) SetBodyIndex(v int32) *Body { t.BodyIndex = v; return t }

// SetDynamicIndex sets the [Body.DynamicIndex]:
// DynamicIndex is the index of this dynamic body in the
// [physics.Model] Dynamics list, once built.
func (t *Body) SetDynamicIndex(v int32) *Body { t.DynamicIndex = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Builder", IDName: "builder", Doc: "Builder is the global container of [physics.Model] elements,\norganized into worlds that are independently updated.", Fields: []types.Field{{Name: "Worlds", Doc: "Worlds are the independent world elements."}}})

// SetWorlds sets the [Builder.Worlds]:
// Worlds are the independent world elements.
func (t *Builder) SetWorlds(v ...World) *Builder { t.Worlds = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Joint", IDName: "joint", Doc: "Joint describes a joint between two bodies.", Fields: []types.Field{{Name: "Parent", Doc: "Parent is index within an Object for parent body."}, {Name: "Child", Doc: "Parent is index within an Object for parent body."}, {Name: "Type", Doc: "Type is the type of the joint."}, {Name: "PPose", Doc: "PPose is the parent position and orientation of the joint\nin the parent's body-centered coordinates."}, {Name: "CPose", Doc: "CPose is the child position and orientation of the joint\nin the parent's body-centered coordinates."}, {Name: "LinearDoFN", Doc: "LinearDoFN is the number of linear degrees of freedom (3 max)."}, {Name: "AngularDoFN", Doc: "AngularDoFN is the number of linear degrees of freedom (3 max)."}, {Name: "DoFs", Doc: "DoFs are the degrees-of-freedom for this joint."}, {Name: "JointIndex", Doc: "JointIndex is the index of this joint in [physics.Joints] when built."}}})

// SetParent sets the [Joint.Parent]:
// Parent is index within an Object for parent body.
func (t *Joint) SetParent(v int) *Joint { t.Parent = v; return t }

// SetChild sets the [Joint.Child]:
// Parent is index within an Object for parent body.
func (t *Joint) SetChild(v int) *Joint { t.Child = v; return t }

// SetType sets the [Joint.Type]:
// Type is the type of the joint.
func (t *Joint) SetType(v physics.JointTypes) *Joint { t.Type = v; return t }

// SetPPose sets the [Joint.PPose]:
// PPose is the parent position and orientation of the joint
// in the parent's body-centered coordinates.
func (t *Joint) SetPPose(v Pose) *Joint { t.PPose = v; return t }

// SetCPose sets the [Joint.CPose]:
// CPose is the child position and orientation of the joint
// in the parent's body-centered coordinates.
func (t *Joint) SetCPose(v Pose) *Joint { t.CPose = v; return t }

// SetLinearDoFN sets the [Joint.LinearDoFN]:
// LinearDoFN is the number of linear degrees of freedom (3 max).
func (t *Joint) SetLinearDoFN(v int) *Joint { t.LinearDoFN = v; return t }

// SetAngularDoFN sets the [Joint.AngularDoFN]:
// AngularDoFN is the number of linear degrees of freedom (3 max).
func (t *Joint) SetAngularDoFN(v int) *Joint { t.AngularDoFN = v; return t }

// SetDoFs sets the [Joint.DoFs]:
// DoFs are the degrees-of-freedom for this joint.
func (t *Joint) SetDoFs(v ...DoF) *Joint { t.DoFs = v; return t }

// SetJointIndex sets the [Joint.JointIndex]:
// JointIndex is the index of this joint in [physics.Joints] when built.
func (t *Joint) SetJointIndex(v int32) *Joint { t.JointIndex = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.DoF", IDName: "do-f", Doc: "DoF is a degree-of-freedom for a [Joint].", Fields: []types.Field{{Name: "Axis", Doc: "Axis is the axis of articulation."}, {Name: "Limit", Doc: "Limit has the limits for motion of this DoF."}, {Name: "TargetPos", Doc: "TargetPos is the position target value, where 0 is the initial\nposition. For angular joints, this is in radians."}, {Name: "TargetStiff", Doc: "TargetStiff determines how strongly the target position\nis enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher).\nSet to 0 to allow the joint to be fully flexible."}, {Name: "TargetVel", Doc: "TargetVel is the velocity target value. For example, 0\neffectively damps joint movement in proportion to Damp parameter."}, {Name: "TargetDamp", Doc: "TargetDamp determines how strongly the target velocity is enforced:\n0 = not at all; larger = stronger (e.g., 1 is reasonable).\nSet to 0 to allow the joint to be fully flexible."}}})

// SetAxis sets the [DoF.Axis]:
// Axis is the axis of articulation.
func (t *DoF) SetAxis(v math32.Vector3) *DoF { t.Axis = v; return t }

// SetLimit sets the [DoF.Limit]:
// Limit has the limits for motion of this DoF.
func (t *DoF) SetLimit(v minmax.F32) *DoF { t.Limit = v; return t }

// SetTargetPos sets the [DoF.TargetPos]:
// TargetPos is the position target value, where 0 is the initial
// position. For angular joints, this is in radians.
func (t *DoF) SetTargetPos(v float32) *DoF { t.TargetPos = v; return t }

// SetTargetStiff sets the [DoF.TargetStiff]:
// TargetStiff determines how strongly the target position
// is enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher).
// Set to 0 to allow the joint to be fully flexible.
func (t *DoF) SetTargetStiff(v float32) *DoF { t.TargetStiff = v; return t }

// SetTargetVel sets the [DoF.TargetVel]:
// TargetVel is the velocity target value. For example, 0
// effectively damps joint movement in proportion to Damp parameter.
func (t *DoF) SetTargetVel(v float32) *DoF { t.TargetVel = v; return t }

// SetTargetDamp sets the [DoF.TargetDamp]:
// TargetDamp determines how strongly the target velocity is enforced:
// 0 = not at all; larger = stronger (e.g., 1 is reasonable).
// Set to 0 to allow the joint to be fully flexible.
func (t *DoF) SetTargetDamp(v float32) *DoF { t.TargetDamp = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Object", IDName: "object", Doc: "Object is an object within the [World].\nEach object is a coherent collection of bodies, typically\nconnected by joints. This is an organizational convenience\nfor positioning elements; has no physical implications.", Fields: []types.Field{{Name: "Bodies", Doc: "Bodies are the bodies in the object."}, {Name: "Joints", Doc: "Joints are joints connecting object bodies.\nJoint indexes here refer strictly within bodies."}}})

// SetBodies sets the [Object.Bodies]:
// Bodies are the bodies in the object.
func (t *Object) SetBodies(v ...Body) *Object { t.Bodies = v; return t }

// SetJoints sets the [Object.Joints]:
// Joints are joints connecting object bodies.
// Joint indexes here refer strictly within bodies.
func (t *Object) SetJoints(v ...Joint) *Object { t.Joints = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.Pose", IDName: "pose", Doc: "Pose represents the 3D position and rotation.", Methods: []types.Method{{Name: "MoveOnAxis", Doc: "MoveOnAxis moves (translates) the specified distance on the specified local axis,\nrelative to the current rotation orientation.\nThe axis is normalized prior to aplying the distance factor.\nSets the LinVel to motion vector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "dist"}}, {Name: "MoveOnAxisAbs", Doc: "MoveOnAxisAbs moves (translates) the specified distance on the specified local axis,\nin absolute X,Y,Z coordinates (does not apply the Quat rotation factor.\nThe axis is normalized prior to aplying the distance factor.\nSets the LinVel to motion vector.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "dist"}}, {Name: "SetEulerRotation", Doc: "SetEulerRotation sets the rotation in Euler angles (degrees).", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z"}}, {Name: "EulerRotation", Doc: "EulerRotation returns the current rotation in Euler angles (degrees).", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Returns: []string{"Vector3"}}, {Name: "SetAxisRotation", Doc: "SetAxisRotation sets rotation from local axis and angle in degrees.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "angle"}}, {Name: "RotateOnAxis", Doc: "RotateOnAxis rotates around the specified local axis the specified angle in degrees.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z", "angle"}}, {Name: "RotateEuler", Doc: "RotateEuler rotates by given Euler angles (in degrees) relative to existing rotation.", Directives: []types.Directive{{Tool: "types", Directive: "add"}}, Args: []string{"x", "y", "z"}}}, Fields: []types.Field{{Name: "Pos", Doc: "Pos is the position of center of mass of object."}, {Name: "Quat", Doc: "Quat is the rotation specified as a quaternion."}}})

// SetPos sets the [Pose.Pos]:
// Pos is the position of center of mass of object.
func (t *Pose) SetPos(v math32.Vector3) *Pose { t.Pos = v; return t }

// SetQuat sets the [Pose.Quat]:
// Quat is the rotation specified as a quaternion.
func (t *Pose) SetQuat(v math32.Quat) *Pose { t.Quat = v; return t }

var _ = types.AddType(&types.Type{Name: "cogentcore.org/lab/physics/builder.World", IDName: "world", Doc: "World is one world within the Builder.", Fields: []types.Field{{Name: "World", Doc: "World is the world index. -1 = globals, else positive.. are distinct\nnon-interacting worlds."}, {Name: "Objects", Doc: "Objects are the objects within the [World].\nEach object is a coherent collection of bodies, typically\nconnected by joints. This is an organizational convenience\nfor positioning elements; has no physical implications."}}})

// SetWorld sets the [World.World]:
// World is the world index. -1 = globals, else positive.. are distinct
// non-interacting worlds.
func (t *World) SetWorld(v int) *World { t.World = v; return t }

// SetObjects sets the [World.Objects]:
// Objects are the objects within the [World].
// Each object is a coherent collection of bodies, typically
// connected by joints. This is an organizational convenience
// for positioning elements; has no physical implications.
func (t *World) SetObjects(v ...Object) *World { t.Objects = v; return t }
