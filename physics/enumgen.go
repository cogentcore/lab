// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package physics

import (
	"cogentcore.org/core/enums"
)

var _BodyVarsValues = []BodyVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

// BodyVarsN is the highest valid value for type BodyVars, plus one.
//
//gosl:start
const BodyVarsN BodyVars = 37

//gosl:end

var _BodyVarsValueMap = map[string]BodyVars{`Shape`: 0, `WorldIndex`: 1, `SizeX`: 2, `SizeY`: 3, `SizeZ`: 4, `Mass`: 5, `InvMass`: 6, `Bounce`: 7, `Friction`: 8, `BodyPosX`: 9, `BodyPosY`: 10, `BodyPosZ`: 11, `BodyRotX`: 12, `BodyRotY`: 13, `BodyRotZ`: 14, `BodyRotW`: 15, `BodyComX`: 16, `BodyComY`: 17, `BodyComZ`: 18, `InertiaXX`: 19, `InertiaYX`: 20, `InertiaZX`: 21, `InertiaXY`: 22, `InertiaYY`: 23, `InertiaZY`: 24, `InertiaXZ`: 25, `InertiaYZ`: 26, `InertiaZZ`: 27, `InvInertiaXX`: 28, `InvInertiaYX`: 29, `InvInertiaZX`: 30, `InvInertiaXY`: 31, `InvInertiaYY`: 32, `InvInertiaZY`: 33, `InvInertiaXZ`: 34, `InvInertiaYZ`: 35, `InvInertiaZZ`: 36}

var _BodyVarsDescMap = map[BodyVars]string{0: `Shape is the shape type of the object, as a Shapes type.`, 1: `WorldIndex partitions body into different worlds; Global are -1`, 2: `Size is the size of the object (values depend on shape type).`, 3: ``, 4: ``, 5: `Mass is the mass of the object.`, 6: `InvMass is 1/mass of the object or 0 if no mass.`, 7: `Bounce specifies the COR or coefficient of restitution (0..1), which determines how elastic the collision is, i.e., final velocity / initial velocity.`, 8: `Friction coefficient: how much friction is generated by transverse motion. Additive across the two surfaces.`, 9: `3D position of body (structural center).`, 10: ``, 11: ``, 12: `Quaternion rotation of body.`, 13: ``, 14: ``, 15: ``, 16: `Relative center-of-mass offset from 3D position of body.`, 17: ``, 18: ``, 19: `Inertia 3x3 matrix (column matrix organization, r,c labels).`, 20: ``, 21: ``, 22: ``, 23: ``, 24: ``, 25: ``, 26: ``, 27: ``, 28: `InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).`, 29: ``, 30: ``, 31: ``, 32: ``, 33: ``, 34: ``, 35: ``, 36: ``}

var _BodyVarsMap = map[BodyVars]string{0: `Shape`, 1: `WorldIndex`, 2: `SizeX`, 3: `SizeY`, 4: `SizeZ`, 5: `Mass`, 6: `InvMass`, 7: `Bounce`, 8: `Friction`, 9: `BodyPosX`, 10: `BodyPosY`, 11: `BodyPosZ`, 12: `BodyRotX`, 13: `BodyRotY`, 14: `BodyRotZ`, 15: `BodyRotW`, 16: `BodyComX`, 17: `BodyComY`, 18: `BodyComZ`, 19: `InertiaXX`, 20: `InertiaYX`, 21: `InertiaZX`, 22: `InertiaXY`, 23: `InertiaYY`, 24: `InertiaZY`, 25: `InertiaXZ`, 26: `InertiaYZ`, 27: `InertiaZZ`, 28: `InvInertiaXX`, 29: `InvInertiaYX`, 30: `InvInertiaZX`, 31: `InvInertiaXY`, 32: `InvInertiaYY`, 33: `InvInertiaZY`, 34: `InvInertiaXZ`, 35: `InvInertiaYZ`, 36: `InvInertiaZZ`}

// String returns the string representation of this BodyVars value.
func (i BodyVars) String() string { return enums.String(i, _BodyVarsMap) }

// SetString sets the BodyVars value from its string representation,
// and returns an error if the string is invalid.
func (i *BodyVars) SetString(s string) error {
	return enums.SetString(i, s, _BodyVarsValueMap, "BodyVars")
}

// Int64 returns the BodyVars value as an int64.
func (i BodyVars) Int64() int64 { return int64(i) }

// SetInt64 sets the BodyVars value from an int64.
func (i *BodyVars) SetInt64(in int64) { *i = BodyVars(in) }

// Desc returns the description of the BodyVars value.
func (i BodyVars) Desc() string { return enums.Desc(i, _BodyVarsDescMap) }

// BodyVarsValues returns all possible values for the type BodyVars.
func BodyVarsValues() []BodyVars { return _BodyVarsValues }

// Values returns all possible values for the type BodyVars.
func (i BodyVars) Values() []enums.Enum { return enums.Values(_BodyVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BodyVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BodyVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "BodyVars") }

var _DynamicVarsValues = []DynamicVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}

// DynamicVarsN is the highest valid value for type DynamicVars, plus one.
//
//gosl:start
const DynamicVarsN DynamicVars = 32

//gosl:end

var _DynamicVarsValueMap = map[string]DynamicVars{`Index`: 0, `PosX`: 1, `PosY`: 2, `PosZ`: 3, `RotX`: 4, `RotY`: 5, `RotZ`: 6, `RotW`: 7, `VelX`: 8, `VelY`: 9, `VelZ`: 10, `AngVelX`: 11, `AngVelY`: 12, `AngVelZ`: 13, `AccX`: 14, `AccY`: 15, `AccZ`: 16, `AngAccX`: 17, `AngAccY`: 18, `AngAccZ`: 19, `ForceX`: 20, `ForceY`: 21, `ForceZ`: 22, `TorqueX`: 23, `TorqueY`: 24, `TorqueZ`: 25, `DeltaX`: 26, `DeltaY`: 27, `DeltaZ`: 28, `AngDeltaX`: 29, `AngDeltaY`: 30, `AngDeltaZ`: 31}

var _DynamicVarsDescMap = map[DynamicVars]string{0: `Index of body in list of bodies.`, 1: `3D position of center of mass.`, 2: ``, 3: ``, 4: `Quaternion rotation.`, 5: ``, 6: ``, 7: ``, 8: `Linear velocity.`, 9: ``, 10: ``, 11: `Angular velocity.`, 12: ``, 13: ``, 14: `Linear acceleration.`, 15: ``, 16: ``, 17: `Angular acceleration due to applied torques.`, 18: ``, 19: ``, 20: `Linear force driving linear acceleration (from joints, etc).`, 21: ``, 22: ``, 23: `Torque driving angular acceleration (from joints, etc).`, 24: ``, 25: ``, 26: `Linear deltas.`, 27: ``, 28: ``, 29: `Angular deltas.`, 30: ``, 31: ``}

var _DynamicVarsMap = map[DynamicVars]string{0: `Index`, 1: `PosX`, 2: `PosY`, 3: `PosZ`, 4: `RotX`, 5: `RotY`, 6: `RotZ`, 7: `RotW`, 8: `VelX`, 9: `VelY`, 10: `VelZ`, 11: `AngVelX`, 12: `AngVelY`, 13: `AngVelZ`, 14: `AccX`, 15: `AccY`, 16: `AccZ`, 17: `AngAccX`, 18: `AngAccY`, 19: `AngAccZ`, 20: `ForceX`, 21: `ForceY`, 22: `ForceZ`, 23: `TorqueX`, 24: `TorqueY`, 25: `TorqueZ`, 26: `DeltaX`, 27: `DeltaY`, 28: `DeltaZ`, 29: `AngDeltaX`, 30: `AngDeltaY`, 31: `AngDeltaZ`}

// String returns the string representation of this DynamicVars value.
func (i DynamicVars) String() string { return enums.String(i, _DynamicVarsMap) }

// SetString sets the DynamicVars value from its string representation,
// and returns an error if the string is invalid.
func (i *DynamicVars) SetString(s string) error {
	return enums.SetString(i, s, _DynamicVarsValueMap, "DynamicVars")
}

// Int64 returns the DynamicVars value as an int64.
func (i DynamicVars) Int64() int64 { return int64(i) }

// SetInt64 sets the DynamicVars value from an int64.
func (i *DynamicVars) SetInt64(in int64) { *i = DynamicVars(in) }

// Desc returns the description of the DynamicVars value.
func (i DynamicVars) Desc() string { return enums.Desc(i, _DynamicVarsDescMap) }

// DynamicVarsValues returns all possible values for the type DynamicVars.
func DynamicVarsValues() []DynamicVars { return _DynamicVarsValues }

// Values returns all possible values for the type DynamicVars.
func (i DynamicVars) Values() []enums.Enum { return enums.Values(_DynamicVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DynamicVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DynamicVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DynamicVars")
}

var _ContactVarsValues = []ContactVars{0, 1, 2, 3, 4, 5, 6, 7, 8}

// ContactVarsN is the highest valid value for type ContactVars, plus one.
//
//gosl:start
const ContactVarsN ContactVars = 9

//gosl:end

var _ContactVarsValueMap = map[string]ContactVars{`ContactA`: 0, `ContactB`: 1, `ContactNormX`: 2, `ContactNormY`: 3, `ContactNormZ`: 4, `ContactPointX`: 5, `ContactPointY`: 6, `ContactPointZ`: 7, `ContactDist`: 8}

var _ContactVarsDescMap = map[ContactVars]string{0: `first body`, 1: `the other body`, 2: `normal pointing from center of B to center of A`, 3: ``, 4: ``, 5: `point on spherical shell of B where A is contacting`, 6: ``, 7: ``, 8: `ContactDist is the distance from PtB along NormB to contact point on spherical shell of A.`}

var _ContactVarsMap = map[ContactVars]string{0: `ContactA`, 1: `ContactB`, 2: `ContactNormX`, 3: `ContactNormY`, 4: `ContactNormZ`, 5: `ContactPointX`, 6: `ContactPointY`, 7: `ContactPointZ`, 8: `ContactDist`}

// String returns the string representation of this ContactVars value.
func (i ContactVars) String() string { return enums.String(i, _ContactVarsMap) }

// SetString sets the ContactVars value from its string representation,
// and returns an error if the string is invalid.
func (i *ContactVars) SetString(s string) error {
	return enums.SetString(i, s, _ContactVarsValueMap, "ContactVars")
}

// Int64 returns the ContactVars value as an int64.
func (i ContactVars) Int64() int64 { return int64(i) }

// SetInt64 sets the ContactVars value from an int64.
func (i *ContactVars) SetInt64(in int64) { *i = ContactVars(in) }

// Desc returns the description of the ContactVars value.
func (i ContactVars) Desc() string { return enums.Desc(i, _ContactVarsDescMap) }

// ContactVarsValues returns all possible values for the type ContactVars.
func ContactVarsValues() []ContactVars { return _ContactVarsValues }

// Values returns all possible values for the type ContactVars.
func (i ContactVars) Values() []enums.Enum { return enums.Values(_ContactVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ContactVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ContactVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ContactVars")
}

var _JointControlVarsValues = []JointControlVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}

// JointControlVarsN is the highest valid value for type JointControlVars, plus one.
//
//gosl:start
const JointControlVarsN JointControlVars = 19

//gosl:end

var _JointControlVarsValueMap = map[string]JointControlVars{`JointForceX`: 0, `JointForceY`: 1, `JointForceZ`: 2, `JointTorqueX`: 3, `JointTorqueY`: 4, `JointTorqueZ`: 5, `JointTargetPosX`: 6, `JointTargetPosY`: 7, `JointTargetPosZ`: 8, `JointTargetRotX`: 9, `JointTargetRotY`: 10, `JointTargetRotZ`: 11, `JointTargetRotW`: 12, `JointTargetVelX`: 13, `JointTargetVelY`: 14, `JointTargetVelZ`: 15, `JointTargetAngVelX`: 16, `JointTargetAngVelY`: 17, `JointTargetAngVelZ`: 18}

var _JointControlVarsDescMap = map[JointControlVars]string{0: `Joint force and torque inputs`, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: `target values (1 DoF use JointTargetPosX)`, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``, 12: ``, 13: `target velocity`, 14: ``, 15: ``, 16: `target angular velocity`, 17: ``, 18: ``}

var _JointControlVarsMap = map[JointControlVars]string{0: `JointForceX`, 1: `JointForceY`, 2: `JointForceZ`, 3: `JointTorqueX`, 4: `JointTorqueY`, 5: `JointTorqueZ`, 6: `JointTargetPosX`, 7: `JointTargetPosY`, 8: `JointTargetPosZ`, 9: `JointTargetRotX`, 10: `JointTargetRotY`, 11: `JointTargetRotZ`, 12: `JointTargetRotW`, 13: `JointTargetVelX`, 14: `JointTargetVelY`, 15: `JointTargetVelZ`, 16: `JointTargetAngVelX`, 17: `JointTargetAngVelY`, 18: `JointTargetAngVelZ`}

// String returns the string representation of this JointControlVars value.
func (i JointControlVars) String() string { return enums.String(i, _JointControlVarsMap) }

// SetString sets the JointControlVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointControlVars) SetString(s string) error {
	return enums.SetString(i, s, _JointControlVarsValueMap, "JointControlVars")
}

// Int64 returns the JointControlVars value as an int64.
func (i JointControlVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointControlVars value from an int64.
func (i *JointControlVars) SetInt64(in int64) { *i = JointControlVars(in) }

// Desc returns the description of the JointControlVars value.
func (i JointControlVars) Desc() string { return enums.Desc(i, _JointControlVarsDescMap) }

// JointControlVarsValues returns all possible values for the type JointControlVars.
func JointControlVarsValues() []JointControlVars { return _JointControlVarsValues }

// Values returns all possible values for the type JointControlVars.
func (i JointControlVars) Values() []enums.Enum { return enums.Values(_JointControlVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointControlVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointControlVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointControlVars")
}

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 7

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`ParamsVar`: 0, `BodiesVar`: 1, `JointsVar`: 2, `BodyJointsVar`: 3, `DynamicsVar`: 4, `ContactsVar`: 5, `JointControlsVar`: 6}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``}

var _GPUVarsMap = map[GPUVars]string{0: `ParamsVar`, 1: `BodiesVar`, 2: `JointsVar`, 3: `BodyJointsVar`, 4: `DynamicsVar`, 5: `ContactsVar`, 6: `JointControlsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _JointVarsValues = []JointVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34}

// JointVarsN is the highest valid value for type JointVars, plus one.
//
//gosl:start
const JointVarsN JointVars = 35

//gosl:end

var _JointVarsValueMap = map[string]JointVars{`JointType`: 0, `JointEnabled`: 1, `JointParent`: 2, `JointChild`: 3, `JointPPosX`: 4, `JointPPosY`: 5, `JointPPosZ`: 6, `JointPRotX`: 7, `JointPRotY`: 8, `JointPRotZ`: 9, `JointPRotW`: 10, `JointCPosX`: 11, `JointCPosY`: 12, `JointCPosZ`: 13, `JointCRotX`: 14, `JointCRotY`: 15, `JointCRotZ`: 16, `JointCRotW`: 17, `JointAxisX`: 18, `JointAxisY`: 19, `JointAxisZ`: 20, `JointLimitLower`: 21, `JointLimitUpper`: 22, `JointPForceX`: 23, `JointPForceY`: 24, `JointPForceZ`: 25, `JointPTorqueX`: 26, `JointPTorqueY`: 27, `JointPTorqueZ`: 28, `JointCForceX`: 29, `JointCForceY`: 30, `JointCForceZ`: 31, `JointCTorqueX`: 32, `JointCTorqueY`: 33, `JointCTorqueZ`: 34}

var _JointVarsDescMap = map[JointVars]string{0: `JointType (as an int32 from bits).`, 1: `JointEnabled allows joints to be dynamically enabled.`, 2: `JointParent is the dynamic body index for parent body. Can be -1 for a fixed parent for absolute anchor.`, 3: `JointChild is the dynamic body index for child body.`, 4: `position of joint, in parent frame.`, 5: ``, 6: ``, 7: `orientation of joint, in parent frame.`, 8: ``, 9: ``, 10: ``, 11: `position of joint, in child frame.`, 12: ``, 13: ``, 14: `orientation of joint, in child frame.`, 15: ``, 16: ``, 17: ``, 18: ``, 19: ``, 20: ``, 21: `joint limits`, 22: ``, 23: `Computed parent joint force value.`, 24: ``, 25: ``, 26: `Computed parent joint torque value.`, 27: ``, 28: ``, 29: `Computed child joint force value.`, 30: ``, 31: ``, 32: `Computed child joint torque value.`, 33: ``, 34: ``}

var _JointVarsMap = map[JointVars]string{0: `JointType`, 1: `JointEnabled`, 2: `JointParent`, 3: `JointChild`, 4: `JointPPosX`, 5: `JointPPosY`, 6: `JointPPosZ`, 7: `JointPRotX`, 8: `JointPRotY`, 9: `JointPRotZ`, 10: `JointPRotW`, 11: `JointCPosX`, 12: `JointCPosY`, 13: `JointCPosZ`, 14: `JointCRotX`, 15: `JointCRotY`, 16: `JointCRotZ`, 17: `JointCRotW`, 18: `JointAxisX`, 19: `JointAxisY`, 20: `JointAxisZ`, 21: `JointLimitLower`, 22: `JointLimitUpper`, 23: `JointPForceX`, 24: `JointPForceY`, 25: `JointPForceZ`, 26: `JointPTorqueX`, 27: `JointPTorqueY`, 28: `JointPTorqueZ`, 29: `JointCForceX`, 30: `JointCForceY`, 31: `JointCForceZ`, 32: `JointCTorqueX`, 33: `JointCTorqueY`, 34: `JointCTorqueZ`}

// String returns the string representation of this JointVars value.
func (i JointVars) String() string { return enums.String(i, _JointVarsMap) }

// SetString sets the JointVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointVars) SetString(s string) error {
	return enums.SetString(i, s, _JointVarsValueMap, "JointVars")
}

// Int64 returns the JointVars value as an int64.
func (i JointVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointVars value from an int64.
func (i *JointVars) SetInt64(in int64) { *i = JointVars(in) }

// Desc returns the description of the JointVars value.
func (i JointVars) Desc() string { return enums.Desc(i, _JointVarsDescMap) }

// JointVarsValues returns all possible values for the type JointVars.
func JointVarsValues() []JointVars { return _JointVarsValues }

// Values returns all possible values for the type JointVars.
func (i JointVars) Values() []enums.Enum { return enums.Values(_JointVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointVars")
}

var _JointTypesValues = []JointTypes{0, 1, 2, 3, 4, 5, 6}

// JointTypesN is the highest valid value for type JointTypes, plus one.
//
//gosl:start
const JointTypesN JointTypes = 7

//gosl:end

var _JointTypesValueMap = map[string]JointTypes{`Prismatic`: 0, `Revolute`: 1, `Ball`: 2, `Fixed`: 3, `Free`: 4, `Distance`: 5, `D6`: 6}

var _JointTypesDescMap = map[JointTypes]string{0: `Prismatic allows translation along a single axis (slider): 1 DoF.`, 1: `Revolute allows rotation about a single axis (axel): 1 DoF.`, 2: `Ball allows rotation about all three axes (3 DoF, quaternion).`, 3: `Fixed locks all relative motion: 0 DoF.`, 4: `Free allows full 6-DoF motion (translation and rotation).`, 5: `Distance keeps two bodies a distance within joint limits: 6 DoF.`, 6: `D6 is a generic 6-DoF joint.`}

var _JointTypesMap = map[JointTypes]string{0: `Prismatic`, 1: `Revolute`, 2: `Ball`, 3: `Fixed`, 4: `Free`, 5: `Distance`, 6: `D6`}

// String returns the string representation of this JointTypes value.
func (i JointTypes) String() string { return enums.String(i, _JointTypesMap) }

// SetString sets the JointTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *JointTypes) SetString(s string) error {
	return enums.SetString(i, s, _JointTypesValueMap, "JointTypes")
}

// Int64 returns the JointTypes value as an int64.
func (i JointTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the JointTypes value from an int64.
func (i *JointTypes) SetInt64(in int64) { *i = JointTypes(in) }

// Desc returns the description of the JointTypes value.
func (i JointTypes) Desc() string { return enums.Desc(i, _JointTypesDescMap) }

// JointTypesValues returns all possible values for the type JointTypes.
func JointTypesValues() []JointTypes { return _JointTypesValues }

// Values returns all possible values for the type JointTypes.
func (i JointTypes) Values() []enums.Enum { return enums.Values(_JointTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointTypes")
}

var _ShapesValues = []Shapes{0, 1, 2, 3}

// ShapesN is the highest valid value for type Shapes, plus one.
//
//gosl:start
const ShapesN Shapes = 4

//gosl:end

var _ShapesValueMap = map[string]Shapes{`Box`: 0, `Sphere`: 1, `Cylinder`: 2, `Capsule`: 3}

var _ShapesDescMap = map[Shapes]string{0: `Box is a 3D rectalinear shape.`, 1: `Sphere. SizeX is the radius.`, 2: `Cylinder, natively oriented vertically along the Y axis. If one radius is 0, then it is a cone. SizeX = bottom radius, SizeY = height in Y axis, SizeZ = top radius.`, 3: `Capsule, which is a cylinder with half-spheres on the ends. Natively oriented vertically along the Y axis. SizeX = bottom radius, SizeY = height, SizeZ = top radius.`}

var _ShapesMap = map[Shapes]string{0: `Box`, 1: `Sphere`, 2: `Cylinder`, 3: `Capsule`}

// String returns the string representation of this Shapes value.
func (i Shapes) String() string { return enums.String(i, _ShapesMap) }

// SetString sets the Shapes value from its string representation,
// and returns an error if the string is invalid.
func (i *Shapes) SetString(s string) error { return enums.SetString(i, s, _ShapesValueMap, "Shapes") }

// Int64 returns the Shapes value as an int64.
func (i Shapes) Int64() int64 { return int64(i) }

// SetInt64 sets the Shapes value from an int64.
func (i *Shapes) SetInt64(in int64) { *i = Shapes(in) }

// Desc returns the description of the Shapes value.
func (i Shapes) Desc() string { return enums.Desc(i, _ShapesDescMap) }

// ShapesValues returns all possible values for the type Shapes.
func ShapesValues() []Shapes { return _ShapesValues }

// Values returns all possible values for the type Shapes.
func (i Shapes) Values() []enums.Enum { return enums.Values(_ShapesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Shapes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Shapes) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Shapes") }
