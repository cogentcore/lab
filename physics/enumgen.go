// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package physics

import (
	"cogentcore.org/core/enums"
)

var _BodyVarsValues = []BodyVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43}

// BodyVarsN is the highest valid value for type BodyVars, plus one.
//
//gosl:start
const BodyVarsN BodyVars = 44

//gosl:end

var _BodyVarsValueMap = map[string]BodyVars{`BodyShape`: 0, `BodyDynamic`: 1, `BodyWorld`: 2, `BodyGroup`: 3, `BodyObject`: 4, `BodyHSizeX`: 5, `BodyHSizeY`: 6, `BodyHSizeZ`: 7, `BodyThick`: 8, `BodyMass`: 9, `BodyInvMass`: 10, `BodyBounce`: 11, `BodyFriction`: 12, `BodyFrictionTortion`: 13, `BodyFrictionRolling`: 14, `BodyPosX`: 15, `BodyPosY`: 16, `BodyPosZ`: 17, `BodyQuatX`: 18, `BodyQuatY`: 19, `BodyQuatZ`: 20, `BodyQuatW`: 21, `BodyComX`: 22, `BodyComY`: 23, `BodyComZ`: 24, `BodyInertiaXX`: 25, `BodyInertiaYX`: 26, `BodyInertiaZX`: 27, `BodyInertiaXY`: 28, `BodyInertiaYY`: 29, `BodyInertiaZY`: 30, `BodyInertiaXZ`: 31, `BodyInertiaYZ`: 32, `BodyInertiaZZ`: 33, `BodyInvInertiaXX`: 34, `BodyInvInertiaYX`: 35, `BodyInvInertiaZX`: 36, `BodyInvInertiaXY`: 37, `BodyInvInertiaYY`: 38, `BodyInvInertiaZY`: 39, `BodyInvInertiaXZ`: 40, `BodyInvInertiaYZ`: 41, `BodyInvInertiaZZ`: 42, `BodyRadius`: 43}

var _BodyVarsDescMap = map[BodyVars]string{0: `BodyShape is the shape type of the object, as a Shapes type.`, 1: `BodyDynamic is the index into Dynamics for this body, which is -1 for static bodies. Use this to get current Pos and Quat values for a dynamic body.`, 2: `BodyWorld partitions bodies into different worlds for collision detection: Global bodies = -1 can collide with everything; otherwise only items within the same world collide. NewBody uses [World.CurrentWorld] to initialize.`, 3: `BodyGroup partitions bodies within worlds into different groups for collision detection. 0 does not collide with anything. Negative numbers are global within a world, except they don&#39;t collide amongst themselves (all non-dynamic bodies should go in -1 because they don&#39;t collide amongst each-other, but do potentially collide with dynamics). Positive numbers only collide amongst themselves, and with negative groups, but not other positive groups. This is for more special-purpose dynamics: in general use 1 for all dynamic bodies. There is an automatic constraint that the two objects within a single joint do not collide with each other, so this does not need to be handled here.`, 4: `BodyObject identifies bodies that all belong to the same overall physical object (e.g., a robot or simulated animal). It has no implications for collision or physics simulation. Instead, it is used for external manipulation on entire objects at a time, e.g. via PositionObject. When using world replicas, the object indexes are copied, so objects are indexed by world and object id.`, 5: `BodyHSize is the size of the object (values depend on shape type).`, 6: ``, 7: ``, 8: `BodyThick is the thickness of the body, as a hollow shape. If 0, then it is a solid shape (default).`, 9: `BodyMass is the mass of the object.`, 10: `BodyInvMass is 1/mass of the object or 0 if no mass.`, 11: `BodyBounce specifies the COR or coefficient of restitution (0..1), which determines how elastic the collision is, i.e., final velocity / initial velocity.`, 12: `BodyFriction is the standard coefficient for linear friction (mu).`, 13: `BodyFrictionTortion is resistance to spinning at the contact point.`, 14: `BodyFrictionRolling is resistance to rolling motion at contact.`, 15: `3D position of body (structural center).`, 16: ``, 17: ``, 18: `Quaternion rotation of body.`, 19: ``, 20: ``, 21: ``, 22: `Relative center-of-mass offset from 3D position of body.`, 23: ``, 24: ``, 25: `Inertia 3x3 matrix (column matrix organization, r,c labels).`, 26: ``, 27: ``, 28: ``, 29: ``, 30: ``, 31: ``, 32: ``, 33: ``, 34: `InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).`, 35: ``, 36: ``, 37: ``, 38: ``, 39: ``, 40: ``, 41: ``, 42: ``, 43: `radius for broadphase collision`}

var _BodyVarsMap = map[BodyVars]string{0: `BodyShape`, 1: `BodyDynamic`, 2: `BodyWorld`, 3: `BodyGroup`, 4: `BodyObject`, 5: `BodyHSizeX`, 6: `BodyHSizeY`, 7: `BodyHSizeZ`, 8: `BodyThick`, 9: `BodyMass`, 10: `BodyInvMass`, 11: `BodyBounce`, 12: `BodyFriction`, 13: `BodyFrictionTortion`, 14: `BodyFrictionRolling`, 15: `BodyPosX`, 16: `BodyPosY`, 17: `BodyPosZ`, 18: `BodyQuatX`, 19: `BodyQuatY`, 20: `BodyQuatZ`, 21: `BodyQuatW`, 22: `BodyComX`, 23: `BodyComY`, 24: `BodyComZ`, 25: `BodyInertiaXX`, 26: `BodyInertiaYX`, 27: `BodyInertiaZX`, 28: `BodyInertiaXY`, 29: `BodyInertiaYY`, 30: `BodyInertiaZY`, 31: `BodyInertiaXZ`, 32: `BodyInertiaYZ`, 33: `BodyInertiaZZ`, 34: `BodyInvInertiaXX`, 35: `BodyInvInertiaYX`, 36: `BodyInvInertiaZX`, 37: `BodyInvInertiaXY`, 38: `BodyInvInertiaYY`, 39: `BodyInvInertiaZY`, 40: `BodyInvInertiaXZ`, 41: `BodyInvInertiaYZ`, 42: `BodyInvInertiaZZ`, 43: `BodyRadius`}

// String returns the string representation of this BodyVars value.
func (i BodyVars) String() string { return enums.String(i, _BodyVarsMap) }

// SetString sets the BodyVars value from its string representation,
// and returns an error if the string is invalid.
func (i *BodyVars) SetString(s string) error {
	return enums.SetString(i, s, _BodyVarsValueMap, "BodyVars")
}

// Int64 returns the BodyVars value as an int64.
func (i BodyVars) Int64() int64 { return int64(i) }

// SetInt64 sets the BodyVars value from an int64.
func (i *BodyVars) SetInt64(in int64) { *i = BodyVars(in) }

// Desc returns the description of the BodyVars value.
func (i BodyVars) Desc() string { return enums.Desc(i, _BodyVarsDescMap) }

// BodyVarsValues returns all possible values for the type BodyVars.
func BodyVarsValues() []BodyVars { return _BodyVarsValues }

// Values returns all possible values for the type BodyVars.
func (i BodyVars) Values() []enums.Enum { return enums.Values(_BodyVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BodyVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BodyVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "BodyVars") }

var _ContactVarsValues = []ContactVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}

// ContactVarsN is the highest valid value for type ContactVars, plus one.
//
//gosl:start
const ContactVarsN ContactVars = 33

//gosl:end

var _ContactVarsValueMap = map[string]ContactVars{`ContactA`: 0, `ContactB`: 1, `ContactPointIdx`: 2, `ContactAPointX`: 3, `ContactAPointY`: 4, `ContactAPointZ`: 5, `ContactBPointX`: 6, `ContactBPointY`: 7, `ContactBPointZ`: 8, `ContactAOffX`: 9, `ContactAOffY`: 10, `ContactAOffZ`: 11, `ContactBOffX`: 12, `ContactBOffY`: 13, `ContactBOffZ`: 14, `ContactAThick`: 15, `ContactBThick`: 16, `ContactNormX`: 17, `ContactNormY`: 18, `ContactNormZ`: 19, `ContactWeight`: 20, `ContactADeltaX`: 21, `ContactADeltaY`: 22, `ContactADeltaZ`: 23, `ContactAAngDeltaX`: 24, `ContactAAngDeltaY`: 25, `ContactAAngDeltaZ`: 26, `ContactBDeltaX`: 27, `ContactBDeltaY`: 28, `ContactBDeltaZ`: 29, `ContactBAngDeltaX`: 30, `ContactBAngDeltaY`: 31, `ContactBAngDeltaZ`: 32}

var _ContactVarsDescMap = map[ContactVars]string{0: `first body index`, 1: `the other body index`, 2: `contact point index for A-B pair`, 3: `contact point on body A`, 4: ``, 5: ``, 6: `contact point on body B`, 7: ``, 8: ``, 9: `contact offset on body A`, 10: ``, 11: ``, 12: `contact offset on body B`, 13: ``, 14: ``, 15: `Contact thickness`, 16: ``, 17: `normal pointing from center of B to center of A`, 18: ``, 19: ``, 20: `contact weighting -- 1 if contact made; for restitution use this to filter contacts when updating body.`, 21: `computed contact deltas, A`, 22: ``, 23: ``, 24: ``, 25: ``, 26: ``, 27: `computed contact deltas, B`, 28: ``, 29: ``, 30: ``, 31: ``, 32: ``}

var _ContactVarsMap = map[ContactVars]string{0: `ContactA`, 1: `ContactB`, 2: `ContactPointIdx`, 3: `ContactAPointX`, 4: `ContactAPointY`, 5: `ContactAPointZ`, 6: `ContactBPointX`, 7: `ContactBPointY`, 8: `ContactBPointZ`, 9: `ContactAOffX`, 10: `ContactAOffY`, 11: `ContactAOffZ`, 12: `ContactBOffX`, 13: `ContactBOffY`, 14: `ContactBOffZ`, 15: `ContactAThick`, 16: `ContactBThick`, 17: `ContactNormX`, 18: `ContactNormY`, 19: `ContactNormZ`, 20: `ContactWeight`, 21: `ContactADeltaX`, 22: `ContactADeltaY`, 23: `ContactADeltaZ`, 24: `ContactAAngDeltaX`, 25: `ContactAAngDeltaY`, 26: `ContactAAngDeltaZ`, 27: `ContactBDeltaX`, 28: `ContactBDeltaY`, 29: `ContactBDeltaZ`, 30: `ContactBAngDeltaX`, 31: `ContactBAngDeltaY`, 32: `ContactBAngDeltaZ`}

// String returns the string representation of this ContactVars value.
func (i ContactVars) String() string { return enums.String(i, _ContactVarsMap) }

// SetString sets the ContactVars value from its string representation,
// and returns an error if the string is invalid.
func (i *ContactVars) SetString(s string) error {
	return enums.SetString(i, s, _ContactVarsValueMap, "ContactVars")
}

// Int64 returns the ContactVars value as an int64.
func (i ContactVars) Int64() int64 { return int64(i) }

// SetInt64 sets the ContactVars value from an int64.
func (i *ContactVars) SetInt64(in int64) { *i = ContactVars(in) }

// Desc returns the description of the ContactVars value.
func (i ContactVars) Desc() string { return enums.Desc(i, _ContactVarsDescMap) }

// ContactVarsValues returns all possible values for the type ContactVars.
func ContactVarsValues() []ContactVars { return _ContactVarsValues }

// Values returns all possible values for the type ContactVars.
func (i ContactVars) Values() []enums.Enum { return enums.Values(_ContactVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ContactVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ContactVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ContactVars")
}

var _JointControlVarsValues = []JointControlVars{0, 1, 2, 3, 4}

// JointControlVarsN is the highest valid value for type JointControlVars, plus one.
//
//gosl:start
const JointControlVarsN JointControlVars = 5

//gosl:end

var _JointControlVarsValueMap = map[string]JointControlVars{`JointControlForce`: 0, `JointTargetStiff`: 1, `JointTargetPos`: 2, `JointTargetDamp`: 3, `JointTargetVel`: 4}

var _JointControlVarsDescMap = map[JointControlVars]string{0: `Joint force and torque inputs`, 1: `Joint target position settings: the stiffness parameter determines how strongly the target position target is enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher). Set to 0 to allow the joint to be fully flexible.`, 2: ``, 3: `Joint target velocity settings: the damping parameter determines how strongly the target velocity target is enforced: 0 = not at all; larger = stronger (e.g., 1 is reasonable). Set to 0 to allow the joint to be fully flexible.`, 4: ``}

var _JointControlVarsMap = map[JointControlVars]string{0: `JointControlForce`, 1: `JointTargetStiff`, 2: `JointTargetPos`, 3: `JointTargetDamp`, 4: `JointTargetVel`}

// String returns the string representation of this JointControlVars value.
func (i JointControlVars) String() string { return enums.String(i, _JointControlVarsMap) }

// SetString sets the JointControlVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointControlVars) SetString(s string) error {
	return enums.SetString(i, s, _JointControlVarsValueMap, "JointControlVars")
}

// Int64 returns the JointControlVars value as an int64.
func (i JointControlVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointControlVars value from an int64.
func (i *JointControlVars) SetInt64(in int64) { *i = JointControlVars(in) }

// Desc returns the description of the JointControlVars value.
func (i JointControlVars) Desc() string { return enums.Desc(i, _JointControlVarsDescMap) }

// JointControlVarsValues returns all possible values for the type JointControlVars.
func JointControlVarsValues() []JointControlVars { return _JointControlVarsValues }

// Values returns all possible values for the type JointControlVars.
func (i JointControlVars) Values() []enums.Enum { return enums.Values(_JointControlVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointControlVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointControlVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointControlVars")
}

var _DynamicVarsValues = []DynamicVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}

// DynamicVarsN is the highest valid value for type DynamicVars, plus one.
//
//gosl:start
const DynamicVarsN DynamicVars = 33

//gosl:end

var _DynamicVarsValueMap = map[string]DynamicVars{`DynBody`: 0, `DynPosX`: 1, `DynPosY`: 2, `DynPosZ`: 3, `DynQuatX`: 4, `DynQuatY`: 5, `DynQuatZ`: 6, `DynQuatW`: 7, `DynVelX`: 8, `DynVelY`: 9, `DynVelZ`: 10, `DynAngVelX`: 11, `DynAngVelY`: 12, `DynAngVelZ`: 13, `DynAccX`: 14, `DynAccY`: 15, `DynAccZ`: 16, `DynAngAccX`: 17, `DynAngAccY`: 18, `DynAngAccZ`: 19, `DynForceX`: 20, `DynForceY`: 21, `DynForceZ`: 22, `DynTorqueX`: 23, `DynTorqueY`: 24, `DynTorqueZ`: 25, `DynDeltaX`: 26, `DynDeltaY`: 27, `DynDeltaZ`: 28, `DynAngDeltaX`: 29, `DynAngDeltaY`: 30, `DynAngDeltaZ`: 31, `DynContactWeight`: 32}

var _DynamicVarsDescMap = map[DynamicVars]string{0: `Index of body in list of bodies.`, 1: `3D position of structural center.`, 2: ``, 3: ``, 4: `Quaternion rotation.`, 5: ``, 6: ``, 7: ``, 8: `Linear velocity.`, 9: ``, 10: ``, 11: `Angular velocity.`, 12: ``, 13: ``, 14: `Linear acceleration.`, 15: ``, 16: ``, 17: `Angular acceleration due to applied torques.`, 18: ``, 19: ``, 20: `Linear force driving linear acceleration (from joints, etc).`, 21: ``, 22: ``, 23: `Torque driving angular acceleration (from joints, etc).`, 24: ``, 25: ``, 26: `Linear deltas. These accumulate over time via StepBodyDeltas.`, 27: ``, 28: ``, 29: `Angular deltas. These accumulate over time via StepBodyDeltas.`, 30: ``, 31: ``, 32: `integrated weight of all contacts`}

var _DynamicVarsMap = map[DynamicVars]string{0: `DynBody`, 1: `DynPosX`, 2: `DynPosY`, 3: `DynPosZ`, 4: `DynQuatX`, 5: `DynQuatY`, 6: `DynQuatZ`, 7: `DynQuatW`, 8: `DynVelX`, 9: `DynVelY`, 10: `DynVelZ`, 11: `DynAngVelX`, 12: `DynAngVelY`, 13: `DynAngVelZ`, 14: `DynAccX`, 15: `DynAccY`, 16: `DynAccZ`, 17: `DynAngAccX`, 18: `DynAngAccY`, 19: `DynAngAccZ`, 20: `DynForceX`, 21: `DynForceY`, 22: `DynForceZ`, 23: `DynTorqueX`, 24: `DynTorqueY`, 25: `DynTorqueZ`, 26: `DynDeltaX`, 27: `DynDeltaY`, 28: `DynDeltaZ`, 29: `DynAngDeltaX`, 30: `DynAngDeltaY`, 31: `DynAngDeltaZ`, 32: `DynContactWeight`}

// String returns the string representation of this DynamicVars value.
func (i DynamicVars) String() string { return enums.String(i, _DynamicVarsMap) }

// SetString sets the DynamicVars value from its string representation,
// and returns an error if the string is invalid.
func (i *DynamicVars) SetString(s string) error {
	return enums.SetString(i, s, _DynamicVarsValueMap, "DynamicVars")
}

// Int64 returns the DynamicVars value as an int64.
func (i DynamicVars) Int64() int64 { return int64(i) }

// SetInt64 sets the DynamicVars value from an int64.
func (i *DynamicVars) SetInt64(in int64) { *i = DynamicVars(in) }

// Desc returns the description of the DynamicVars value.
func (i DynamicVars) Desc() string { return enums.Desc(i, _DynamicVarsDescMap) }

// DynamicVarsValues returns all possible values for the type DynamicVars.
func DynamicVarsValues() []DynamicVars { return _DynamicVarsValues }

// Values returns all possible values for the type DynamicVars.
func (i DynamicVars) Values() []enums.Enum { return enums.Values(_DynamicVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DynamicVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DynamicVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DynamicVars")
}

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 12

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`ParamsVar`: 0, `BodiesVar`: 1, `JointsVar`: 2, `JointDoFsVar`: 3, `BodyJointsVar`: 4, `BodyCollidePairsVar`: 5, `DynamicsVar`: 6, `BroadContactsNVar`: 7, `BroadContactsVar`: 8, `ContactsNVar`: 9, `ContactsVar`: 10, `JointControlsVar`: 11}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``}

var _GPUVarsMap = map[GPUVars]string{0: `ParamsVar`, 1: `BodiesVar`, 2: `JointsVar`, 3: `JointDoFsVar`, 4: `BodyJointsVar`, 5: `BodyCollidePairsVar`, 6: `DynamicsVar`, 7: `BroadContactsNVar`, 8: `BroadContactsVar`, 9: `ContactsNVar`, 10: `ContactsVar`, 11: `JointControlsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _JointTypesValues = []JointTypes{0, 1, 2, 3, 4, 5, 6}

// JointTypesN is the highest valid value for type JointTypes, plus one.
//
//gosl:start
const JointTypesN JointTypes = 7

//gosl:end

var _JointTypesValueMap = map[string]JointTypes{`Prismatic`: 0, `Revolute`: 1, `Ball`: 2, `Fixed`: 3, `Free`: 4, `Distance`: 5, `D6`: 6}

var _JointTypesDescMap = map[JointTypes]string{0: `Prismatic allows translation along a single axis (slider): 1 DoF.`, 1: `Revolute allows rotation about a single axis (axel): 1 DoF.`, 2: `Ball allows rotation about all three axes (3 DoF, quaternion).`, 3: `Fixed locks all relative motion: 0 DoF.`, 4: `Free allows full 6-DoF motion (translation and rotation).`, 5: `Distance keeps two bodies a distance within joint limits: 6 DoF.`, 6: `D6 is a generic 6-DoF joint.`}

var _JointTypesMap = map[JointTypes]string{0: `Prismatic`, 1: `Revolute`, 2: `Ball`, 3: `Fixed`, 4: `Free`, 5: `Distance`, 6: `D6`}

// String returns the string representation of this JointTypes value.
func (i JointTypes) String() string { return enums.String(i, _JointTypesMap) }

// SetString sets the JointTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *JointTypes) SetString(s string) error {
	return enums.SetString(i, s, _JointTypesValueMap, "JointTypes")
}

// Int64 returns the JointTypes value as an int64.
func (i JointTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the JointTypes value from an int64.
func (i *JointTypes) SetInt64(in int64) { *i = JointTypes(in) }

// Desc returns the description of the JointTypes value.
func (i JointTypes) Desc() string { return enums.Desc(i, _JointTypesDescMap) }

// JointTypesValues returns all possible values for the type JointTypes.
func JointTypesValues() []JointTypes { return _JointTypesValues }

// Values returns all possible values for the type JointTypes.
func (i JointTypes) Values() []enums.Enum { return enums.Values(_JointTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointTypes")
}

var _JointVarsValues = []JointVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49}

// JointVarsN is the highest valid value for type JointVars, plus one.
//
//gosl:start
const JointVarsN JointVars = 50

//gosl:end

var _JointVarsValueMap = map[string]JointVars{`JointType`: 0, `JointEnabled`: 1, `JointParent`: 2, `JointChild`: 3, `JointPPosX`: 4, `JointPPosY`: 5, `JointPPosZ`: 6, `JointPQuatX`: 7, `JointPQuatY`: 8, `JointPQuatZ`: 9, `JointPQuatW`: 10, `JointCPosX`: 11, `JointCPosY`: 12, `JointCPosZ`: 13, `JointCQuatX`: 14, `JointCQuatY`: 15, `JointCQuatZ`: 16, `JointCQuatW`: 17, `JointLinearDoFN`: 18, `JointAngularDoFN`: 19, `JointDoF1`: 20, `JointDoF2`: 21, `JointDoF3`: 22, `JointDoF4`: 23, `JointDoF5`: 24, `JointDoF6`: 25, `JointPForceX`: 26, `JointPForceY`: 27, `JointPForceZ`: 28, `JointPTorqueX`: 29, `JointPTorqueY`: 30, `JointPTorqueZ`: 31, `JointCForceX`: 32, `JointCForceY`: 33, `JointCForceZ`: 34, `JointCTorqueX`: 35, `JointCTorqueY`: 36, `JointCTorqueZ`: 37, `JointPDeltaX`: 38, `JointPDeltaY`: 39, `JointPDeltaZ`: 40, `JointPAngDeltaX`: 41, `JointPAngDeltaY`: 42, `JointPAngDeltaZ`: 43, `JointCDeltaX`: 44, `JointCDeltaY`: 45, `JointCDeltaZ`: 46, `JointCAngDeltaX`: 47, `JointCAngDeltaY`: 48, `JointCAngDeltaZ`: 49}

var _JointVarsDescMap = map[JointVars]string{0: `JointType (as an int32 from bits).`, 1: `JointEnabled allows joints to be dynamically enabled.`, 2: `JointParent is the dynamic body index for parent body. Can be -1 for a fixed parent for absolute anchor.`, 3: `JointChild is the dynamic body index for child body.`, 4: `relative position of joint, in parent frame.`, 5: ``, 6: ``, 7: `relative orientation of joint, in parent frame.`, 8: ``, 9: ``, 10: ``, 11: `relative position of joint, in child frame.`, 12: ``, 13: ``, 14: `relative orientation of joint, in child frame.`, 15: ``, 16: ``, 17: ``, 18: `JointLinearDoFN is the number of linear degrees-of-freedom for the joint.`, 19: `JointAngularDoFN is the number of angular degrees-of-freedom for the joint.`, 20: `indexes in JointDoFs for each DoF`, 21: ``, 22: ``, 23: `angular starts here for Free, Distance, D6`, 24: ``, 25: ``, 26: `Computed parent joint force value.`, 27: ``, 28: ``, 29: `Computed parent joint torque value.`, 30: ``, 31: ``, 32: `Computed child joint force value.`, 33: ``, 34: ``, 35: `Computed child joint torque value.`, 36: ``, 37: ``, 38: `Computed parent joint delta value.`, 39: ``, 40: ``, 41: `Computed parent joint angdelta value.`, 42: ``, 43: ``, 44: `Computed child joint delta value.`, 45: ``, 46: ``, 47: `Computed child joint angdelta value.`, 48: ``, 49: ``}

var _JointVarsMap = map[JointVars]string{0: `JointType`, 1: `JointEnabled`, 2: `JointParent`, 3: `JointChild`, 4: `JointPPosX`, 5: `JointPPosY`, 6: `JointPPosZ`, 7: `JointPQuatX`, 8: `JointPQuatY`, 9: `JointPQuatZ`, 10: `JointPQuatW`, 11: `JointCPosX`, 12: `JointCPosY`, 13: `JointCPosZ`, 14: `JointCQuatX`, 15: `JointCQuatY`, 16: `JointCQuatZ`, 17: `JointCQuatW`, 18: `JointLinearDoFN`, 19: `JointAngularDoFN`, 20: `JointDoF1`, 21: `JointDoF2`, 22: `JointDoF3`, 23: `JointDoF4`, 24: `JointDoF5`, 25: `JointDoF6`, 26: `JointPForceX`, 27: `JointPForceY`, 28: `JointPForceZ`, 29: `JointPTorqueX`, 30: `JointPTorqueY`, 31: `JointPTorqueZ`, 32: `JointCForceX`, 33: `JointCForceY`, 34: `JointCForceZ`, 35: `JointCTorqueX`, 36: `JointCTorqueY`, 37: `JointCTorqueZ`, 38: `JointPDeltaX`, 39: `JointPDeltaY`, 40: `JointPDeltaZ`, 41: `JointPAngDeltaX`, 42: `JointPAngDeltaY`, 43: `JointPAngDeltaZ`, 44: `JointCDeltaX`, 45: `JointCDeltaY`, 46: `JointCDeltaZ`, 47: `JointCAngDeltaX`, 48: `JointCAngDeltaY`, 49: `JointCAngDeltaZ`}

// String returns the string representation of this JointVars value.
func (i JointVars) String() string { return enums.String(i, _JointVarsMap) }

// SetString sets the JointVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointVars) SetString(s string) error {
	return enums.SetString(i, s, _JointVarsValueMap, "JointVars")
}

// Int64 returns the JointVars value as an int64.
func (i JointVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointVars value from an int64.
func (i *JointVars) SetInt64(in int64) { *i = JointVars(in) }

// Desc returns the description of the JointVars value.
func (i JointVars) Desc() string { return enums.Desc(i, _JointVarsDescMap) }

// JointVarsValues returns all possible values for the type JointVars.
func JointVarsValues() []JointVars { return _JointVarsValues }

// Values returns all possible values for the type JointVars.
func (i JointVars) Values() []enums.Enum { return enums.Values(_JointVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointVars")
}

var _JointDoFVarsValues = []JointDoFVars{0, 1, 2, 3, 4}

// JointDoFVarsN is the highest valid value for type JointDoFVars, plus one.
//
//gosl:start
const JointDoFVarsN JointDoFVars = 5

//gosl:end

var _JointDoFVarsValueMap = map[string]JointDoFVars{`JointAxisX`: 0, `JointAxisY`: 1, `JointAxisZ`: 2, `JointLimitLower`: 3, `JointLimitUpper`: 4}

var _JointDoFVarsDescMap = map[JointDoFVars]string{0: `axis of articulation for the DoF`, 1: ``, 2: ``, 3: `joint limits`, 4: ``}

var _JointDoFVarsMap = map[JointDoFVars]string{0: `JointAxisX`, 1: `JointAxisY`, 2: `JointAxisZ`, 3: `JointLimitLower`, 4: `JointLimitUpper`}

// String returns the string representation of this JointDoFVars value.
func (i JointDoFVars) String() string { return enums.String(i, _JointDoFVarsMap) }

// SetString sets the JointDoFVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointDoFVars) SetString(s string) error {
	return enums.SetString(i, s, _JointDoFVarsValueMap, "JointDoFVars")
}

// Int64 returns the JointDoFVars value as an int64.
func (i JointDoFVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointDoFVars value from an int64.
func (i *JointDoFVars) SetInt64(in int64) { *i = JointDoFVars(in) }

// Desc returns the description of the JointDoFVars value.
func (i JointDoFVars) Desc() string { return enums.Desc(i, _JointDoFVarsDescMap) }

// JointDoFVarsValues returns all possible values for the type JointDoFVars.
func JointDoFVarsValues() []JointDoFVars { return _JointDoFVarsValues }

// Values returns all possible values for the type JointDoFVars.
func (i JointDoFVars) Values() []enums.Enum { return enums.Values(_JointDoFVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointDoFVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointDoFVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointDoFVars")
}

var _ShapesValues = []Shapes{0, 1, 2, 3, 4, 5}

// ShapesN is the highest valid value for type Shapes, plus one.
//
//gosl:start
const ShapesN Shapes = 6

//gosl:end

var _ShapesValueMap = map[string]Shapes{`Plane`: 0, `Sphere`: 1, `Capsule`: 2, `Cylinder`: 3, `Box`: 4, `Cone`: 5}

var _ShapesDescMap = map[Shapes]string{0: `Plane cannot be a dynamic shape, but is most efficient for collision computations. Use size = 0 for an infinite plane. Natively extends in the X-Z plane: SizeX x SizeZ.`, 1: `Sphere. SizeX is the radius.`, 2: `Capsule is a cylinder with half-spheres on the ends. Natively oriented vertically along the Y axis. SizeX = radius, SizeY = half-height.`, 3: `Cylinder, natively oriented vertically along the Y axis. SizeX = radius, SizeY = half-height in Y axis. Cylinder can not collide with a Box.`, 4: `Box is a 3D rectalinear shape. The sizes are _half_ sizes along each dimension, relative to the center.`, 5: `Cone is like a cylinder with the top radius = 0, oriented up. SizeX = bottom radius, SizeY = half-height in Y. Cone does not support any collisions and is not recommended for interacting bodies.`}

var _ShapesMap = map[Shapes]string{0: `Plane`, 1: `Sphere`, 2: `Capsule`, 3: `Cylinder`, 4: `Box`, 5: `Cone`}

// String returns the string representation of this Shapes value.
func (i Shapes) String() string { return enums.String(i, _ShapesMap) }

// SetString sets the Shapes value from its string representation,
// and returns an error if the string is invalid.
func (i *Shapes) SetString(s string) error { return enums.SetString(i, s, _ShapesValueMap, "Shapes") }

// Int64 returns the Shapes value as an int64.
func (i Shapes) Int64() int64 { return int64(i) }

// SetInt64 sets the Shapes value from an int64.
func (i *Shapes) SetInt64(in int64) { *i = Shapes(in) }

// Desc returns the description of the Shapes value.
func (i Shapes) Desc() string { return enums.Desc(i, _ShapesDescMap) }

// ShapesValues returns all possible values for the type Shapes.
func ShapesValues() []Shapes { return _ShapesValues }

// Values returns all possible values for the type Shapes.
func (i Shapes) Values() []enums.Enum { return enums.Values(_ShapesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Shapes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Shapes) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Shapes") }
