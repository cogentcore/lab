// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package physics

import (
	"cogentcore.org/core/enums"
)

var _BodyVarsValues = []BodyVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39}

// BodyVarsN is the highest valid value for type BodyVars, plus one.
//
//gosl:start
const BodyVarsN BodyVars = 40

//gosl:end

var _BodyVarsValueMap = map[string]BodyVars{`BodyShape`: 0, `BodyDynamic`: 1, `BodyWorld`: 2, `BodyGroup`: 3, `BodySizeX`: 4, `BodySizeY`: 5, `BodySizeZ`: 6, `BodyMass`: 7, `BodyInvMass`: 8, `BodyBounce`: 9, `BodyFriction`: 10, `BodyPosX`: 11, `BodyPosY`: 12, `BodyPosZ`: 13, `BodyQuatX`: 14, `BodyQuatY`: 15, `BodyQuatZ`: 16, `BodyQuatW`: 17, `BodyComX`: 18, `BodyComY`: 19, `BodyComZ`: 20, `BodyInertiaXX`: 21, `BodyInertiaYX`: 22, `BodyInertiaZX`: 23, `BodyInertiaXY`: 24, `BodyInertiaYY`: 25, `BodyInertiaZY`: 26, `BodyInertiaXZ`: 27, `BodyInertiaYZ`: 28, `BodyInertiaZZ`: 29, `BodyInvInertiaXX`: 30, `BodyInvInertiaYX`: 31, `BodyInvInertiaZX`: 32, `BodyInvInertiaXY`: 33, `BodyInvInertiaYY`: 34, `BodyInvInertiaZY`: 35, `BodyInvInertiaXZ`: 36, `BodyInvInertiaYZ`: 37, `BodyInvInertiaZZ`: 38, `BodyRadius`: 39}

var _BodyVarsDescMap = map[BodyVars]string{0: `BodyShape is the shape type of the object, as a Shapes type.`, 1: `BodyDynamic is the index into Dynamics for this body, which is -1 for static bodies. Use this to get current Pos and Quat values for a dynamic body.`, 2: `BodyWorld partitions bodies into different worlds for collision detection: Global bodies = -1 can collide with everything; otherwise only items within the same world collide.`, 3: `BodyGroup partitions bodies within worlds into different groups for collision detection. 0 does not collide with anything. Negative numbers are global within a world, except they don&#39;t collide amongst themselves (all non-dynamic bodies should go in -1 because they don&#39;t collide amongst each-other, but do potentially collide with dynamics). Positive numbers only collide amongst themselves, and with negative groups, but not other positive groups. This is for more special-purpose dynamics: in general use 1 for all dynamic bodies. There is an automatic constraint that the two objects within a single joint do not collide with each other, so this does not need to be handled here.`, 4: `BodySize is the size of the object (values depend on shape type).`, 5: ``, 6: ``, 7: `BodyMass is the mass of the object.`, 8: `BodyInvMass is 1/mass of the object or 0 if no mass.`, 9: `BodyBounce specifies the COR or coefficient of restitution (0..1), which determines how elastic the collision is, i.e., final velocity / initial velocity.`, 10: `BodyFriction coefficient: how much friction is generated by transverse motion. Additive across the two surfaces.`, 11: `3D position of body (structural center).`, 12: ``, 13: ``, 14: `Quaternion rotation of body.`, 15: ``, 16: ``, 17: ``, 18: `Relative center-of-mass offset from 3D position of body.`, 19: ``, 20: ``, 21: `Inertia 3x3 matrix (column matrix organization, r,c labels).`, 22: ``, 23: ``, 24: ``, 25: ``, 26: ``, 27: ``, 28: ``, 29: ``, 30: `InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).`, 31: ``, 32: ``, 33: ``, 34: ``, 35: ``, 36: ``, 37: ``, 38: ``, 39: `radius for broadphase collision`}

var _BodyVarsMap = map[BodyVars]string{0: `BodyShape`, 1: `BodyDynamic`, 2: `BodyWorld`, 3: `BodyGroup`, 4: `BodySizeX`, 5: `BodySizeY`, 6: `BodySizeZ`, 7: `BodyMass`, 8: `BodyInvMass`, 9: `BodyBounce`, 10: `BodyFriction`, 11: `BodyPosX`, 12: `BodyPosY`, 13: `BodyPosZ`, 14: `BodyQuatX`, 15: `BodyQuatY`, 16: `BodyQuatZ`, 17: `BodyQuatW`, 18: `BodyComX`, 19: `BodyComY`, 20: `BodyComZ`, 21: `BodyInertiaXX`, 22: `BodyInertiaYX`, 23: `BodyInertiaZX`, 24: `BodyInertiaXY`, 25: `BodyInertiaYY`, 26: `BodyInertiaZY`, 27: `BodyInertiaXZ`, 28: `BodyInertiaYZ`, 29: `BodyInertiaZZ`, 30: `BodyInvInertiaXX`, 31: `BodyInvInertiaYX`, 32: `BodyInvInertiaZX`, 33: `BodyInvInertiaXY`, 34: `BodyInvInertiaYY`, 35: `BodyInvInertiaZY`, 36: `BodyInvInertiaXZ`, 37: `BodyInvInertiaYZ`, 38: `BodyInvInertiaZZ`, 39: `BodyRadius`}

// String returns the string representation of this BodyVars value.
func (i BodyVars) String() string { return enums.String(i, _BodyVarsMap) }

// SetString sets the BodyVars value from its string representation,
// and returns an error if the string is invalid.
func (i *BodyVars) SetString(s string) error {
	return enums.SetString(i, s, _BodyVarsValueMap, "BodyVars")
}

// Int64 returns the BodyVars value as an int64.
func (i BodyVars) Int64() int64 { return int64(i) }

// SetInt64 sets the BodyVars value from an int64.
func (i *BodyVars) SetInt64(in int64) { *i = BodyVars(in) }

// Desc returns the description of the BodyVars value.
func (i BodyVars) Desc() string { return enums.Desc(i, _BodyVarsDescMap) }

// BodyVarsValues returns all possible values for the type BodyVars.
func BodyVarsValues() []BodyVars { return _BodyVarsValues }

// Values returns all possible values for the type BodyVars.
func (i BodyVars) Values() []enums.Enum { return enums.Values(_BodyVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BodyVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BodyVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "BodyVars") }

var _ContactVarsValues = []ContactVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}

// ContactVarsN is the highest valid value for type ContactVars, plus one.
//
//gosl:start
const ContactVarsN ContactVars = 16

//gosl:end

var _ContactVarsValueMap = map[string]ContactVars{`ContactA`: 0, `ContactB`: 1, `ContactAPointX`: 2, `ContactAPointY`: 3, `ContactAPointZ`: 4, `ContactBPointX`: 5, `ContactBPointY`: 6, `ContactBPointZ`: 7, `ContactADepth`: 8, `ContactBDepth`: 9, `ContactNormX`: 10, `ContactNormY`: 11, `ContactNormZ`: 12, `ContactForceX`: 13, `ContactForceY`: 14, `ContactForceZ`: 15}

var _ContactVarsDescMap = map[ContactVars]string{0: `first body index`, 1: `the other body index`, 2: `contact point on body A`, 3: ``, 4: ``, 5: `contact point on body B`, 6: ``, 7: ``, 8: `Contact depths (thickness in newton)`, 9: ``, 10: `normal pointing from center of B to center of A`, 11: ``, 12: ``, 13: `computed contact force vector`, 14: ``, 15: ``}

var _ContactVarsMap = map[ContactVars]string{0: `ContactA`, 1: `ContactB`, 2: `ContactAPointX`, 3: `ContactAPointY`, 4: `ContactAPointZ`, 5: `ContactBPointX`, 6: `ContactBPointY`, 7: `ContactBPointZ`, 8: `ContactADepth`, 9: `ContactBDepth`, 10: `ContactNormX`, 11: `ContactNormY`, 12: `ContactNormZ`, 13: `ContactForceX`, 14: `ContactForceY`, 15: `ContactForceZ`}

// String returns the string representation of this ContactVars value.
func (i ContactVars) String() string { return enums.String(i, _ContactVarsMap) }

// SetString sets the ContactVars value from its string representation,
// and returns an error if the string is invalid.
func (i *ContactVars) SetString(s string) error {
	return enums.SetString(i, s, _ContactVarsValueMap, "ContactVars")
}

// Int64 returns the ContactVars value as an int64.
func (i ContactVars) Int64() int64 { return int64(i) }

// SetInt64 sets the ContactVars value from an int64.
func (i *ContactVars) SetInt64(in int64) { *i = ContactVars(in) }

// Desc returns the description of the ContactVars value.
func (i ContactVars) Desc() string { return enums.Desc(i, _ContactVarsDescMap) }

// ContactVarsValues returns all possible values for the type ContactVars.
func ContactVarsValues() []ContactVars { return _ContactVarsValues }

// Values returns all possible values for the type ContactVars.
func (i ContactVars) Values() []enums.Enum { return enums.Values(_ContactVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ContactVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ContactVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ContactVars")
}

var _JointControlVarsValues = []JointControlVars{0, 1, 2}

// JointControlVarsN is the highest valid value for type JointControlVars, plus one.
//
//gosl:start
const JointControlVarsN JointControlVars = 3

//gosl:end

var _JointControlVarsValueMap = map[string]JointControlVars{`JointControlForce`: 0, `JointTargetPos`: 1, `JointTargetVel`: 2}

var _JointControlVarsDescMap = map[JointControlVars]string{0: `Joint force and torque inputs`, 1: ``, 2: ``}

var _JointControlVarsMap = map[JointControlVars]string{0: `JointControlForce`, 1: `JointTargetPos`, 2: `JointTargetVel`}

// String returns the string representation of this JointControlVars value.
func (i JointControlVars) String() string { return enums.String(i, _JointControlVarsMap) }

// SetString sets the JointControlVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointControlVars) SetString(s string) error {
	return enums.SetString(i, s, _JointControlVarsValueMap, "JointControlVars")
}

// Int64 returns the JointControlVars value as an int64.
func (i JointControlVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointControlVars value from an int64.
func (i *JointControlVars) SetInt64(in int64) { *i = JointControlVars(in) }

// Desc returns the description of the JointControlVars value.
func (i JointControlVars) Desc() string { return enums.Desc(i, _JointControlVarsDescMap) }

// JointControlVarsValues returns all possible values for the type JointControlVars.
func JointControlVarsValues() []JointControlVars { return _JointControlVarsValues }

// Values returns all possible values for the type JointControlVars.
func (i JointControlVars) Values() []enums.Enum { return enums.Values(_JointControlVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointControlVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointControlVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointControlVars")
}

var _DynamicVarsValues = []DynamicVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}

// DynamicVarsN is the highest valid value for type DynamicVars, plus one.
//
//gosl:start
const DynamicVarsN DynamicVars = 32

//gosl:end

var _DynamicVarsValueMap = map[string]DynamicVars{`DynBody`: 0, `DynPosX`: 1, `DynPosY`: 2, `DynPosZ`: 3, `DynQuatX`: 4, `DynQuatY`: 5, `DynQuatZ`: 6, `DynQuatW`: 7, `DynVelX`: 8, `DynVelY`: 9, `DynVelZ`: 10, `DynAngVelX`: 11, `DynAngVelY`: 12, `DynAngVelZ`: 13, `DynAccX`: 14, `DynAccY`: 15, `DynAccZ`: 16, `DynAngAccX`: 17, `DynAngAccY`: 18, `DynAngAccZ`: 19, `DynForceX`: 20, `DynForceY`: 21, `DynForceZ`: 22, `DynTorqueX`: 23, `DynTorqueY`: 24, `DynTorqueZ`: 25, `DynDeltaX`: 26, `DynDeltaY`: 27, `DynDeltaZ`: 28, `DynAngDeltaX`: 29, `DynAngDeltaY`: 30, `DynAngDeltaZ`: 31}

var _DynamicVarsDescMap = map[DynamicVars]string{0: `Index of body in list of bodies.`, 1: `3D position of structural center.`, 2: ``, 3: ``, 4: `Quaternion rotation.`, 5: ``, 6: ``, 7: ``, 8: `Linear velocity.`, 9: ``, 10: ``, 11: `Angular velocity.`, 12: ``, 13: ``, 14: `Linear acceleration.`, 15: ``, 16: ``, 17: `Angular acceleration due to applied torques.`, 18: ``, 19: ``, 20: `Linear force driving linear acceleration (from joints, etc).`, 21: ``, 22: ``, 23: `Torque driving angular acceleration (from joints, etc).`, 24: ``, 25: ``, 26: `Linear deltas.`, 27: ``, 28: ``, 29: `Angular deltas.`, 30: ``, 31: ``}

var _DynamicVarsMap = map[DynamicVars]string{0: `DynBody`, 1: `DynPosX`, 2: `DynPosY`, 3: `DynPosZ`, 4: `DynQuatX`, 5: `DynQuatY`, 6: `DynQuatZ`, 7: `DynQuatW`, 8: `DynVelX`, 9: `DynVelY`, 10: `DynVelZ`, 11: `DynAngVelX`, 12: `DynAngVelY`, 13: `DynAngVelZ`, 14: `DynAccX`, 15: `DynAccY`, 16: `DynAccZ`, 17: `DynAngAccX`, 18: `DynAngAccY`, 19: `DynAngAccZ`, 20: `DynForceX`, 21: `DynForceY`, 22: `DynForceZ`, 23: `DynTorqueX`, 24: `DynTorqueY`, 25: `DynTorqueZ`, 26: `DynDeltaX`, 27: `DynDeltaY`, 28: `DynDeltaZ`, 29: `DynAngDeltaX`, 30: `DynAngDeltaY`, 31: `DynAngDeltaZ`}

// String returns the string representation of this DynamicVars value.
func (i DynamicVars) String() string { return enums.String(i, _DynamicVarsMap) }

// SetString sets the DynamicVars value from its string representation,
// and returns an error if the string is invalid.
func (i *DynamicVars) SetString(s string) error {
	return enums.SetString(i, s, _DynamicVarsValueMap, "DynamicVars")
}

// Int64 returns the DynamicVars value as an int64.
func (i DynamicVars) Int64() int64 { return int64(i) }

// SetInt64 sets the DynamicVars value from an int64.
func (i *DynamicVars) SetInt64(in int64) { *i = DynamicVars(in) }

// Desc returns the description of the DynamicVars value.
func (i DynamicVars) Desc() string { return enums.Desc(i, _DynamicVarsDescMap) }

// DynamicVarsValues returns all possible values for the type DynamicVars.
func DynamicVarsValues() []DynamicVars { return _DynamicVarsValues }

// Values returns all possible values for the type DynamicVars.
func (i DynamicVars) Values() []enums.Enum { return enums.Values(_DynamicVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DynamicVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DynamicVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DynamicVars")
}

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 10

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`ParamsVar`: 0, `BodiesVar`: 1, `JointsVar`: 2, `JointDoFsVar`: 3, `BodyJointsVar`: 4, `BodyCollidePairsVar`: 5, `DynamicsVar`: 6, `ContactCountVar`: 7, `ContactsVar`: 8, `JointControlsVar`: 9}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``}

var _GPUVarsMap = map[GPUVars]string{0: `ParamsVar`, 1: `BodiesVar`, 2: `JointsVar`, 3: `JointDoFsVar`, 4: `BodyJointsVar`, 5: `BodyCollidePairsVar`, 6: `DynamicsVar`, 7: `ContactCountVar`, 8: `ContactsVar`, 9: `JointControlsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _JointTypesValues = []JointTypes{0, 1, 2, 3, 4, 5, 6}

// JointTypesN is the highest valid value for type JointTypes, plus one.
//
//gosl:start
const JointTypesN JointTypes = 7

//gosl:end

var _JointTypesValueMap = map[string]JointTypes{`Prismatic`: 0, `Revolute`: 1, `Ball`: 2, `Fixed`: 3, `Free`: 4, `Distance`: 5, `D6`: 6}

var _JointTypesDescMap = map[JointTypes]string{0: `Prismatic allows translation along a single axis (slider): 1 DoF.`, 1: `Revolute allows rotation about a single axis (axel): 1 DoF.`, 2: `Ball allows rotation about all three axes (3 DoF, quaternion).`, 3: `Fixed locks all relative motion: 0 DoF.`, 4: `Free allows full 6-DoF motion (translation and rotation).`, 5: `Distance keeps two bodies a distance within joint limits: 6 DoF.`, 6: `D6 is a generic 6-DoF joint.`}

var _JointTypesMap = map[JointTypes]string{0: `Prismatic`, 1: `Revolute`, 2: `Ball`, 3: `Fixed`, 4: `Free`, 5: `Distance`, 6: `D6`}

// String returns the string representation of this JointTypes value.
func (i JointTypes) String() string { return enums.String(i, _JointTypesMap) }

// SetString sets the JointTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *JointTypes) SetString(s string) error {
	return enums.SetString(i, s, _JointTypesValueMap, "JointTypes")
}

// Int64 returns the JointTypes value as an int64.
func (i JointTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the JointTypes value from an int64.
func (i *JointTypes) SetInt64(in int64) { *i = JointTypes(in) }

// Desc returns the description of the JointTypes value.
func (i JointTypes) Desc() string { return enums.Desc(i, _JointTypesDescMap) }

// JointTypesValues returns all possible values for the type JointTypes.
func JointTypesValues() []JointTypes { return _JointTypesValues }

// Values returns all possible values for the type JointTypes.
func (i JointTypes) Values() []enums.Enum { return enums.Values(_JointTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointTypes")
}

var _JointVarsValues = []JointVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49}

// JointVarsN is the highest valid value for type JointVars, plus one.
//
//gosl:start
const JointVarsN JointVars = 50

//gosl:end

var _JointVarsValueMap = map[string]JointVars{`JointType`: 0, `JointEnabled`: 1, `JointParent`: 2, `JointChild`: 3, `JointPPosX`: 4, `JointPPosY`: 5, `JointPPosZ`: 6, `JointPQuatX`: 7, `JointPQuatY`: 8, `JointPQuatZ`: 9, `JointPQuatW`: 10, `JointCPosX`: 11, `JointCPosY`: 12, `JointCPosZ`: 13, `JointCQuatX`: 14, `JointCQuatY`: 15, `JointCQuatZ`: 16, `JointCQuatW`: 17, `JointLinearDoFN`: 18, `JointAngularDoFN`: 19, `JointDoF1`: 20, `JointDoF2`: 21, `JointDoF3`: 22, `JointDoF4`: 23, `JointDoF5`: 24, `JointDoF6`: 25, `JointPForceX`: 26, `JointPForceY`: 27, `JointPForceZ`: 28, `JointPTorqueX`: 29, `JointPTorqueY`: 30, `JointPTorqueZ`: 31, `JointCForceX`: 32, `JointCForceY`: 33, `JointCForceZ`: 34, `JointCTorqueX`: 35, `JointCTorqueY`: 36, `JointCTorqueZ`: 37, `JointPDeltaX`: 38, `JointPDeltaY`: 39, `JointPDeltaZ`: 40, `JointPAngDeltaX`: 41, `JointPAngDeltaY`: 42, `JointPAngDeltaZ`: 43, `JointCDeltaX`: 44, `JointCDeltaY`: 45, `JointCDeltaZ`: 46, `JointCAngDeltaX`: 47, `JointCAngDeltaY`: 48, `JointCAngDeltaZ`: 49}

var _JointVarsDescMap = map[JointVars]string{0: `JointType (as an int32 from bits).`, 1: `JointEnabled allows joints to be dynamically enabled.`, 2: `JointParent is the dynamic body index for parent body. Can be -1 for a fixed parent for absolute anchor.`, 3: `JointChild is the dynamic body index for child body.`, 4: `relative position of joint, in parent frame.`, 5: ``, 6: ``, 7: `relative orientation of joint, in parent frame.`, 8: ``, 9: ``, 10: ``, 11: `relative position of joint, in child frame.`, 12: ``, 13: ``, 14: `relative orientation of joint, in child frame.`, 15: ``, 16: ``, 17: ``, 18: `JointLinearDoFN is the number of linear degrees-of-freedom for the joint.`, 19: `JointAngularDoFN is the number of angular degrees-of-freedom for the joint.`, 20: `indexes in JointDoFs for each DoF`, 21: ``, 22: ``, 23: `angular starts here for Free, Distance, D6`, 24: ``, 25: ``, 26: `Computed parent joint force value.`, 27: ``, 28: ``, 29: `Computed parent joint torque value.`, 30: ``, 31: ``, 32: `Computed child joint force value.`, 33: ``, 34: ``, 35: `Computed child joint torque value.`, 36: ``, 37: ``, 38: `Computed parent joint delta value.`, 39: ``, 40: ``, 41: `Computed parent joint angdelta value.`, 42: ``, 43: ``, 44: `Computed child joint delta value.`, 45: ``, 46: ``, 47: `Computed child joint angdelta value.`, 48: ``, 49: ``}

var _JointVarsMap = map[JointVars]string{0: `JointType`, 1: `JointEnabled`, 2: `JointParent`, 3: `JointChild`, 4: `JointPPosX`, 5: `JointPPosY`, 6: `JointPPosZ`, 7: `JointPQuatX`, 8: `JointPQuatY`, 9: `JointPQuatZ`, 10: `JointPQuatW`, 11: `JointCPosX`, 12: `JointCPosY`, 13: `JointCPosZ`, 14: `JointCQuatX`, 15: `JointCQuatY`, 16: `JointCQuatZ`, 17: `JointCQuatW`, 18: `JointLinearDoFN`, 19: `JointAngularDoFN`, 20: `JointDoF1`, 21: `JointDoF2`, 22: `JointDoF3`, 23: `JointDoF4`, 24: `JointDoF5`, 25: `JointDoF6`, 26: `JointPForceX`, 27: `JointPForceY`, 28: `JointPForceZ`, 29: `JointPTorqueX`, 30: `JointPTorqueY`, 31: `JointPTorqueZ`, 32: `JointCForceX`, 33: `JointCForceY`, 34: `JointCForceZ`, 35: `JointCTorqueX`, 36: `JointCTorqueY`, 37: `JointCTorqueZ`, 38: `JointPDeltaX`, 39: `JointPDeltaY`, 40: `JointPDeltaZ`, 41: `JointPAngDeltaX`, 42: `JointPAngDeltaY`, 43: `JointPAngDeltaZ`, 44: `JointCDeltaX`, 45: `JointCDeltaY`, 46: `JointCDeltaZ`, 47: `JointCAngDeltaX`, 48: `JointCAngDeltaY`, 49: `JointCAngDeltaZ`}

// String returns the string representation of this JointVars value.
func (i JointVars) String() string { return enums.String(i, _JointVarsMap) }

// SetString sets the JointVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointVars) SetString(s string) error {
	return enums.SetString(i, s, _JointVarsValueMap, "JointVars")
}

// Int64 returns the JointVars value as an int64.
func (i JointVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointVars value from an int64.
func (i *JointVars) SetInt64(in int64) { *i = JointVars(in) }

// Desc returns the description of the JointVars value.
func (i JointVars) Desc() string { return enums.Desc(i, _JointVarsDescMap) }

// JointVarsValues returns all possible values for the type JointVars.
func JointVarsValues() []JointVars { return _JointVarsValues }

// Values returns all possible values for the type JointVars.
func (i JointVars) Values() []enums.Enum { return enums.Values(_JointVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointVars")
}

var _JointDoFVarsValues = []JointDoFVars{0, 1, 2, 3, 4, 5, 6}

// JointDoFVarsN is the highest valid value for type JointDoFVars, plus one.
//
//gosl:start
const JointDoFVarsN JointDoFVars = 7

//gosl:end

var _JointDoFVarsValueMap = map[string]JointDoFVars{`JointAxisX`: 0, `JointAxisY`: 1, `JointAxisZ`: 2, `JointLimitLower`: 3, `JointLimitUpper`: 4, `JointStiff`: 5, `JointDamp`: 6}

var _JointDoFVarsDescMap = map[JointDoFVars]string{0: `axis of articulation for the DoF`, 1: ``, 2: ``, 3: `joint limits`, 4: ``, 5: `joint stiffness target (ke)`, 6: `joint damping target (kd)`}

var _JointDoFVarsMap = map[JointDoFVars]string{0: `JointAxisX`, 1: `JointAxisY`, 2: `JointAxisZ`, 3: `JointLimitLower`, 4: `JointLimitUpper`, 5: `JointStiff`, 6: `JointDamp`}

// String returns the string representation of this JointDoFVars value.
func (i JointDoFVars) String() string { return enums.String(i, _JointDoFVarsMap) }

// SetString sets the JointDoFVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointDoFVars) SetString(s string) error {
	return enums.SetString(i, s, _JointDoFVarsValueMap, "JointDoFVars")
}

// Int64 returns the JointDoFVars value as an int64.
func (i JointDoFVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointDoFVars value from an int64.
func (i *JointDoFVars) SetInt64(in int64) { *i = JointDoFVars(in) }

// Desc returns the description of the JointDoFVars value.
func (i JointDoFVars) Desc() string { return enums.Desc(i, _JointDoFVarsDescMap) }

// JointDoFVarsValues returns all possible values for the type JointDoFVars.
func JointDoFVarsValues() []JointDoFVars { return _JointDoFVarsValues }

// Values returns all possible values for the type JointDoFVars.
func (i JointDoFVars) Values() []enums.Enum { return enums.Values(_JointDoFVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointDoFVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointDoFVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointDoFVars")
}

var _ShapesValues = []Shapes{0, 1, 2, 3, 4}

// ShapesN is the highest valid value for type Shapes, plus one.
//
//gosl:start
const ShapesN Shapes = 5

//gosl:end

var _ShapesValueMap = map[string]Shapes{`Plane`: 0, `Sphere`: 1, `Capsule`: 2, `Cylinder`: 3, `Box`: 4}

var _ShapesDescMap = map[Shapes]string{0: `Plane cannot be a dynamic shape, but is most efficient for collision computations. Use size = 0 for an infinite plane.`, 1: `Sphere. SizeX is the radius.`, 2: `Capsule, which is a cylinder with half-spheres on the ends. Natively oriented vertically along the Y axis. SizeX = bottom radius, SizeY = half-height, SizeZ = top radius.`, 3: `Cylinder, natively oriented vertically along the Y axis. If one radius is 0, then it is a cone. SizeX = bottom radius, SizeY = half-height in Y axis, SizeZ = top radius. Cylinder can not collide with a Box.`, 4: `Box is a 3D rectalinear shape. The sizes are _half_ sizes along each dimension, relative to the center.`}

var _ShapesMap = map[Shapes]string{0: `Plane`, 1: `Sphere`, 2: `Capsule`, 3: `Cylinder`, 4: `Box`}

// String returns the string representation of this Shapes value.
func (i Shapes) String() string { return enums.String(i, _ShapesMap) }

// SetString sets the Shapes value from its string representation,
// and returns an error if the string is invalid.
func (i *Shapes) SetString(s string) error { return enums.SetString(i, s, _ShapesValueMap, "Shapes") }

// Int64 returns the Shapes value as an int64.
func (i Shapes) Int64() int64 { return int64(i) }

// SetInt64 sets the Shapes value from an int64.
func (i *Shapes) SetInt64(in int64) { *i = Shapes(in) }

// Desc returns the description of the Shapes value.
func (i Shapes) Desc() string { return enums.Desc(i, _ShapesDescMap) }

// ShapesValues returns all possible values for the type Shapes.
func ShapesValues() []Shapes { return _ShapesValues }

// Values returns all possible values for the type Shapes.
func (i Shapes) Values() []enums.Enum { return enums.Values(_ShapesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Shapes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Shapes) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Shapes") }
