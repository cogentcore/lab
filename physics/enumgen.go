// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package physics

import (
	"cogentcore.org/core/enums"
)

var _BodyVarsValues = []BodyVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42}

// BodyVarsN is the highest valid value for type BodyVars, plus one.
//
//gosl:start
const BodyVarsN BodyVars = 43

//gosl:end

var _BodyVarsValueMap = map[string]BodyVars{`BodyShape`: 0, `BodyDynamic`: 1, `BodyWorld`: 2, `BodyGroup`: 3, `BodyHSizeX`: 4, `BodyHSizeY`: 5, `BodyHSizeZ`: 6, `BodyThick`: 7, `BodyMass`: 8, `BodyInvMass`: 9, `BodyBounce`: 10, `BodyFriction`: 11, `BodyFrictionTortion`: 12, `BodyFrictionRolling`: 13, `BodyPosX`: 14, `BodyPosY`: 15, `BodyPosZ`: 16, `BodyQuatX`: 17, `BodyQuatY`: 18, `BodyQuatZ`: 19, `BodyQuatW`: 20, `BodyComX`: 21, `BodyComY`: 22, `BodyComZ`: 23, `BodyInertiaXX`: 24, `BodyInertiaYX`: 25, `BodyInertiaZX`: 26, `BodyInertiaXY`: 27, `BodyInertiaYY`: 28, `BodyInertiaZY`: 29, `BodyInertiaXZ`: 30, `BodyInertiaYZ`: 31, `BodyInertiaZZ`: 32, `BodyInvInertiaXX`: 33, `BodyInvInertiaYX`: 34, `BodyInvInertiaZX`: 35, `BodyInvInertiaXY`: 36, `BodyInvInertiaYY`: 37, `BodyInvInertiaZY`: 38, `BodyInvInertiaXZ`: 39, `BodyInvInertiaYZ`: 40, `BodyInvInertiaZZ`: 41, `BodyRadius`: 42}

var _BodyVarsDescMap = map[BodyVars]string{0: `BodyShape is the shape type of the object, as a Shapes type.`, 1: `BodyDynamic is the index into Dynamics for this body, which is -1 for static bodies. Use this to get current Pos and Quat values for a dynamic body.`, 2: `BodyWorld partitions bodies into different worlds for collision detection: Global bodies = -1 can collide with everything; otherwise only items within the same world collide. NewBody uses [World.CurrentWorld] to initialize.`, 3: `BodyGroup partitions bodies within worlds into different groups for collision detection. 0 does not collide with anything. Negative numbers are global within a world, except they don&#39;t collide amongst themselves (all non-dynamic bodies should go in -1 because they don&#39;t collide amongst each-other, but do potentially collide with dynamics). Positive numbers only collide amongst themselves, and with negative groups, but not other positive groups. To avoid unwanted collisions, put bodies into separate groups. There is an automatic constraint that the two objects within a single joint do not collide with each other, so this does not need to be handled here.`, 4: `BodyHSize is the half-size (e.g., radius) of the body. Values depend on shape type: X is generally radius, Y is half-height.`, 5: ``, 6: ``, 7: `BodyThick is the thickness of the body, as a hollow shape. If 0, then it is a solid shape (default).`, 8: `BodyMass is the mass of the object.`, 9: `BodyInvMass is 1/mass of the object or 0 if no mass.`, 10: `BodyBounce specifies the COR or coefficient of restitution (0..1), which determines how elastic the collision is, i.e., final velocity / initial velocity.`, 11: `BodyFriction is the standard coefficient for linear friction (mu).`, 12: `BodyFrictionTortion is resistance to spinning at the contact point.`, 13: `BodyFrictionRolling is resistance to rolling motion at contact.`, 14: `3D position of body (structural center).`, 15: ``, 16: ``, 17: `Quaternion rotation of body.`, 18: ``, 19: ``, 20: ``, 21: `Relative center-of-mass offset from 3D position of body.`, 22: ``, 23: ``, 24: `Inertia 3x3 matrix (column matrix organization, r,c labels).`, 25: ``, 26: ``, 27: ``, 28: ``, 29: ``, 30: ``, 31: ``, 32: ``, 33: `InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).`, 34: ``, 35: ``, 36: ``, 37: ``, 38: ``, 39: ``, 40: ``, 41: ``, 42: `radius for broadphase collision`}

var _BodyVarsMap = map[BodyVars]string{0: `BodyShape`, 1: `BodyDynamic`, 2: `BodyWorld`, 3: `BodyGroup`, 4: `BodyHSizeX`, 5: `BodyHSizeY`, 6: `BodyHSizeZ`, 7: `BodyThick`, 8: `BodyMass`, 9: `BodyInvMass`, 10: `BodyBounce`, 11: `BodyFriction`, 12: `BodyFrictionTortion`, 13: `BodyFrictionRolling`, 14: `BodyPosX`, 15: `BodyPosY`, 16: `BodyPosZ`, 17: `BodyQuatX`, 18: `BodyQuatY`, 19: `BodyQuatZ`, 20: `BodyQuatW`, 21: `BodyComX`, 22: `BodyComY`, 23: `BodyComZ`, 24: `BodyInertiaXX`, 25: `BodyInertiaYX`, 26: `BodyInertiaZX`, 27: `BodyInertiaXY`, 28: `BodyInertiaYY`, 29: `BodyInertiaZY`, 30: `BodyInertiaXZ`, 31: `BodyInertiaYZ`, 32: `BodyInertiaZZ`, 33: `BodyInvInertiaXX`, 34: `BodyInvInertiaYX`, 35: `BodyInvInertiaZX`, 36: `BodyInvInertiaXY`, 37: `BodyInvInertiaYY`, 38: `BodyInvInertiaZY`, 39: `BodyInvInertiaXZ`, 40: `BodyInvInertiaYZ`, 41: `BodyInvInertiaZZ`, 42: `BodyRadius`}

// String returns the string representation of this BodyVars value.
func (i BodyVars) String() string { return enums.String(i, _BodyVarsMap) }

// SetString sets the BodyVars value from its string representation,
// and returns an error if the string is invalid.
func (i *BodyVars) SetString(s string) error {
	return enums.SetString(i, s, _BodyVarsValueMap, "BodyVars")
}

// Int64 returns the BodyVars value as an int64.
func (i BodyVars) Int64() int64 { return int64(i) }

// SetInt64 sets the BodyVars value from an int64.
func (i *BodyVars) SetInt64(in int64) { *i = BodyVars(in) }

// Desc returns the description of the BodyVars value.
func (i BodyVars) Desc() string { return enums.Desc(i, _BodyVarsDescMap) }

// BodyVarsValues returns all possible values for the type BodyVars.
func BodyVarsValues() []BodyVars { return _BodyVarsValues }

// Values returns all possible values for the type BodyVars.
func (i BodyVars) Values() []enums.Enum { return enums.Values(_BodyVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BodyVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BodyVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "BodyVars") }

var _ContactVarsValues = []ContactVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}

// ContactVarsN is the highest valid value for type ContactVars, plus one.
//
//gosl:start
const ContactVarsN ContactVars = 33

//gosl:end

var _ContactVarsValueMap = map[string]ContactVars{`ContactA`: 0, `ContactB`: 1, `ContactPointIdx`: 2, `ContactAPointX`: 3, `ContactAPointY`: 4, `ContactAPointZ`: 5, `ContactBPointX`: 6, `ContactBPointY`: 7, `ContactBPointZ`: 8, `ContactAOffX`: 9, `ContactAOffY`: 10, `ContactAOffZ`: 11, `ContactBOffX`: 12, `ContactBOffY`: 13, `ContactBOffZ`: 14, `ContactAThick`: 15, `ContactBThick`: 16, `ContactNormX`: 17, `ContactNormY`: 18, `ContactNormZ`: 19, `ContactWeight`: 20, `ContactADeltaX`: 21, `ContactADeltaY`: 22, `ContactADeltaZ`: 23, `ContactAAngDeltaX`: 24, `ContactAAngDeltaY`: 25, `ContactAAngDeltaZ`: 26, `ContactBDeltaX`: 27, `ContactBDeltaY`: 28, `ContactBDeltaZ`: 29, `ContactBAngDeltaX`: 30, `ContactBAngDeltaY`: 31, `ContactBAngDeltaZ`: 32}

var _ContactVarsDescMap = map[ContactVars]string{0: `first body index`, 1: `the other body index`, 2: `contact point index for A-B pair`, 3: `contact point on body A`, 4: ``, 5: ``, 6: `contact point on body B`, 7: ``, 8: ``, 9: `contact offset on body A`, 10: ``, 11: ``, 12: `contact offset on body B`, 13: ``, 14: ``, 15: `Contact thickness`, 16: ``, 17: `normal pointing from center of B to center of A`, 18: ``, 19: ``, 20: `contact weighting -- 1 if contact made; for restitution use this to filter contacts when updating body.`, 21: `computed contact deltas, A`, 22: ``, 23: ``, 24: ``, 25: ``, 26: ``, 27: `computed contact deltas, B`, 28: ``, 29: ``, 30: ``, 31: ``, 32: ``}

var _ContactVarsMap = map[ContactVars]string{0: `ContactA`, 1: `ContactB`, 2: `ContactPointIdx`, 3: `ContactAPointX`, 4: `ContactAPointY`, 5: `ContactAPointZ`, 6: `ContactBPointX`, 7: `ContactBPointY`, 8: `ContactBPointZ`, 9: `ContactAOffX`, 10: `ContactAOffY`, 11: `ContactAOffZ`, 12: `ContactBOffX`, 13: `ContactBOffY`, 14: `ContactBOffZ`, 15: `ContactAThick`, 16: `ContactBThick`, 17: `ContactNormX`, 18: `ContactNormY`, 19: `ContactNormZ`, 20: `ContactWeight`, 21: `ContactADeltaX`, 22: `ContactADeltaY`, 23: `ContactADeltaZ`, 24: `ContactAAngDeltaX`, 25: `ContactAAngDeltaY`, 26: `ContactAAngDeltaZ`, 27: `ContactBDeltaX`, 28: `ContactBDeltaY`, 29: `ContactBDeltaZ`, 30: `ContactBAngDeltaX`, 31: `ContactBAngDeltaY`, 32: `ContactBAngDeltaZ`}

// String returns the string representation of this ContactVars value.
func (i ContactVars) String() string { return enums.String(i, _ContactVarsMap) }

// SetString sets the ContactVars value from its string representation,
// and returns an error if the string is invalid.
func (i *ContactVars) SetString(s string) error {
	return enums.SetString(i, s, _ContactVarsValueMap, "ContactVars")
}

// Int64 returns the ContactVars value as an int64.
func (i ContactVars) Int64() int64 { return int64(i) }

// SetInt64 sets the ContactVars value from an int64.
func (i *ContactVars) SetInt64(in int64) { *i = ContactVars(in) }

// Desc returns the description of the ContactVars value.
func (i ContactVars) Desc() string { return enums.Desc(i, _ContactVarsDescMap) }

// ContactVarsValues returns all possible values for the type ContactVars.
func ContactVarsValues() []ContactVars { return _ContactVarsValues }

// Values returns all possible values for the type ContactVars.
func (i ContactVars) Values() []enums.Enum { return enums.Values(_ContactVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ContactVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ContactVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ContactVars")
}

var _JointControlVarsValues = []JointControlVars{0, 1, 2, 3, 4, 5}

// JointControlVarsN is the highest valid value for type JointControlVars, plus one.
//
//gosl:start
const JointControlVarsN JointControlVars = 6

//gosl:end

var _JointControlVarsValueMap = map[string]JointControlVars{`JointControlForce`: 0, `JointTargetPos`: 1, `JointTargetPosCur`: 2, `JointTargetStiff`: 3, `JointTargetVel`: 4, `JointTargetDamp`: 5}

var _JointControlVarsDescMap = map[JointControlVars]string{0: `Joint force and torque inputs`, 1: `JointTargetPos is the position target value input to the model, where 0 is the initial position. For angular joints, this is in radians. This is subject to a graded transition over time, [JointTargetPosCur] has the current effective value.`, 2: `JointTargetPosCur is the current position target value, updated from [JointTargetPos] input using the [Params.ControlDt] time constant.`, 3: `JointTargetStiff determines how strongly the target position is enforced: 0 = not at all; larger = stronger (e.g., 1000 or higher). Set to 0 to allow the joint to be fully flexible.`, 4: `JointTargetVel is the velocity target value. For example, 0 effectively damps joint movement in proportion to Damp parameter.`, 5: `JointTargetDamp determines how strongly the target velocity is enforced: 0 = not at all; larger = stronger (e.g., 1 is reasonable). Set to 0 to allow the joint to be fully flexible.`}

var _JointControlVarsMap = map[JointControlVars]string{0: `JointControlForce`, 1: `JointTargetPos`, 2: `JointTargetPosCur`, 3: `JointTargetStiff`, 4: `JointTargetVel`, 5: `JointTargetDamp`}

// String returns the string representation of this JointControlVars value.
func (i JointControlVars) String() string { return enums.String(i, _JointControlVarsMap) }

// SetString sets the JointControlVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointControlVars) SetString(s string) error {
	return enums.SetString(i, s, _JointControlVarsValueMap, "JointControlVars")
}

// Int64 returns the JointControlVars value as an int64.
func (i JointControlVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointControlVars value from an int64.
func (i *JointControlVars) SetInt64(in int64) { *i = JointControlVars(in) }

// Desc returns the description of the JointControlVars value.
func (i JointControlVars) Desc() string { return enums.Desc(i, _JointControlVarsDescMap) }

// JointControlVarsValues returns all possible values for the type JointControlVars.
func JointControlVarsValues() []JointControlVars { return _JointControlVarsValues }

// Values returns all possible values for the type JointControlVars.
func (i JointControlVars) Values() []enums.Enum { return enums.Values(_JointControlVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointControlVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointControlVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointControlVars")
}

var _DynamicVarsValues = []DynamicVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32}

// DynamicVarsN is the highest valid value for type DynamicVars, plus one.
//
//gosl:start
const DynamicVarsN DynamicVars = 33

//gosl:end

var _DynamicVarsValueMap = map[string]DynamicVars{`DynBody`: 0, `DynPosX`: 1, `DynPosY`: 2, `DynPosZ`: 3, `DynQuatX`: 4, `DynQuatY`: 5, `DynQuatZ`: 6, `DynQuatW`: 7, `DynVelX`: 8, `DynVelY`: 9, `DynVelZ`: 10, `DynAngVelX`: 11, `DynAngVelY`: 12, `DynAngVelZ`: 13, `DynAccX`: 14, `DynAccY`: 15, `DynAccZ`: 16, `DynAngAccX`: 17, `DynAngAccY`: 18, `DynAngAccZ`: 19, `DynForceX`: 20, `DynForceY`: 21, `DynForceZ`: 22, `DynTorqueX`: 23, `DynTorqueY`: 24, `DynTorqueZ`: 25, `DynDeltaX`: 26, `DynDeltaY`: 27, `DynDeltaZ`: 28, `DynAngDeltaX`: 29, `DynAngDeltaY`: 30, `DynAngDeltaZ`: 31, `DynContactWeight`: 32}

var _DynamicVarsDescMap = map[DynamicVars]string{0: `Index of body in list of bodies.`, 1: `3D position of structural center.`, 2: ``, 3: ``, 4: `Quaternion rotation.`, 5: ``, 6: ``, 7: ``, 8: `Linear velocity.`, 9: ``, 10: ``, 11: `Angular velocity.`, 12: ``, 13: ``, 14: `Linear acceleration.`, 15: ``, 16: ``, 17: `Angular acceleration due to applied torques.`, 18: ``, 19: ``, 20: `Linear force driving linear acceleration (from joints, etc).`, 21: ``, 22: ``, 23: `Torque driving angular acceleration (from joints, etc).`, 24: ``, 25: ``, 26: `Linear deltas. These accumulate over time via StepBodyDeltas.`, 27: ``, 28: ``, 29: `Angular deltas. These accumulate over time via StepBodyDeltas.`, 30: ``, 31: ``, 32: `integrated weight of all contacts`}

var _DynamicVarsMap = map[DynamicVars]string{0: `DynBody`, 1: `DynPosX`, 2: `DynPosY`, 3: `DynPosZ`, 4: `DynQuatX`, 5: `DynQuatY`, 6: `DynQuatZ`, 7: `DynQuatW`, 8: `DynVelX`, 9: `DynVelY`, 10: `DynVelZ`, 11: `DynAngVelX`, 12: `DynAngVelY`, 13: `DynAngVelZ`, 14: `DynAccX`, 15: `DynAccY`, 16: `DynAccZ`, 17: `DynAngAccX`, 18: `DynAngAccY`, 19: `DynAngAccZ`, 20: `DynForceX`, 21: `DynForceY`, 22: `DynForceZ`, 23: `DynTorqueX`, 24: `DynTorqueY`, 25: `DynTorqueZ`, 26: `DynDeltaX`, 27: `DynDeltaY`, 28: `DynDeltaZ`, 29: `DynAngDeltaX`, 30: `DynAngDeltaY`, 31: `DynAngDeltaZ`, 32: `DynContactWeight`}

// String returns the string representation of this DynamicVars value.
func (i DynamicVars) String() string { return enums.String(i, _DynamicVarsMap) }

// SetString sets the DynamicVars value from its string representation,
// and returns an error if the string is invalid.
func (i *DynamicVars) SetString(s string) error {
	return enums.SetString(i, s, _DynamicVarsValueMap, "DynamicVars")
}

// Int64 returns the DynamicVars value as an int64.
func (i DynamicVars) Int64() int64 { return int64(i) }

// SetInt64 sets the DynamicVars value from an int64.
func (i *DynamicVars) SetInt64(in int64) { *i = DynamicVars(in) }

// Desc returns the description of the DynamicVars value.
func (i DynamicVars) Desc() string { return enums.Desc(i, _DynamicVarsDescMap) }

// DynamicVarsValues returns all possible values for the type DynamicVars.
func DynamicVarsValues() []DynamicVars { return _DynamicVarsValues }

// Values returns all possible values for the type DynamicVars.
func (i DynamicVars) Values() []enums.Enum { return enums.Values(_DynamicVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DynamicVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DynamicVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DynamicVars")
}

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 13

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`ParamsVar`: 0, `BodiesVar`: 1, `ObjectsVar`: 2, `BodyJointsVar`: 3, `JointsVar`: 4, `JointDoFsVar`: 5, `BodyCollidePairsVar`: 6, `DynamicsVar`: 7, `BroadContactsNVar`: 8, `BroadContactsVar`: 9, `ContactsNVar`: 10, `ContactsVar`: 11, `JointControlsVar`: 12}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``, 12: ``}

var _GPUVarsMap = map[GPUVars]string{0: `ParamsVar`, 1: `BodiesVar`, 2: `ObjectsVar`, 3: `BodyJointsVar`, 4: `JointsVar`, 5: `JointDoFsVar`, 6: `BodyCollidePairsVar`, 7: `DynamicsVar`, 8: `BroadContactsNVar`, 9: `BroadContactsVar`, 10: `ContactsNVar`, 11: `ContactsVar`, 12: `JointControlsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _JointTypesValues = []JointTypes{0, 1, 2, 3, 4, 5, 6, 7}

// JointTypesN is the highest valid value for type JointTypes, plus one.
//
//gosl:start
const JointTypesN JointTypes = 8

//gosl:end

var _JointTypesValueMap = map[string]JointTypes{`Prismatic`: 0, `Revolute`: 1, `Ball`: 2, `Fixed`: 3, `Free`: 4, `Distance`: 5, `D6`: 6, `PlaneXZ`: 7}

var _JointTypesDescMap = map[JointTypes]string{0: `Prismatic allows translation along a single axis (slider): 1 DoF.`, 1: `Revolute allows rotation about a single axis (axel): 1 DoF.`, 2: `Ball allows rotation about all three axes (3 DoF, quaternion).`, 3: `Fixed locks all relative motion: 0 DoF.`, 4: `Free allows full 6-DoF motion (translation and rotation).`, 5: `Distance keeps two bodies a distance within joint limits: 6 DoF.`, 6: `D6 is a generic 6-DoF joint.`, 7: `PlaneXZ is a version of D6 for navigation in the X-Z plane, which creates 2 linear DoF (X, Z) for movement.`}

var _JointTypesMap = map[JointTypes]string{0: `Prismatic`, 1: `Revolute`, 2: `Ball`, 3: `Fixed`, 4: `Free`, 5: `Distance`, 6: `D6`, 7: `PlaneXZ`}

// String returns the string representation of this JointTypes value.
func (i JointTypes) String() string { return enums.String(i, _JointTypesMap) }

// SetString sets the JointTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *JointTypes) SetString(s string) error {
	return enums.SetString(i, s, _JointTypesValueMap, "JointTypes")
}

// Int64 returns the JointTypes value as an int64.
func (i JointTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the JointTypes value from an int64.
func (i *JointTypes) SetInt64(in int64) { *i = JointTypes(in) }

// Desc returns the description of the JointTypes value.
func (i JointTypes) Desc() string { return enums.Desc(i, _JointTypesDescMap) }

// JointTypesValues returns all possible values for the type JointTypes.
func JointTypesValues() []JointTypes { return _JointTypesValues }

// Values returns all possible values for the type JointTypes.
func (i JointTypes) Values() []enums.Enum { return enums.Values(_JointTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointTypes")
}

var _JointVarsValues = []JointVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45}

// JointVarsN is the highest valid value for type JointVars, plus one.
//
//gosl:start
const JointVarsN JointVars = 46

//gosl:end

var _JointVarsValueMap = map[string]JointVars{`JointType`: 0, `JointEnabled`: 1, `JointParentFixed`: 2, `JointNoLinearRotation`: 3, `JointParent`: 4, `JointChild`: 5, `JointPPosX`: 6, `JointPPosY`: 7, `JointPPosZ`: 8, `JointPQuatX`: 9, `JointPQuatY`: 10, `JointPQuatZ`: 11, `JointPQuatW`: 12, `JointCPosX`: 13, `JointCPosY`: 14, `JointCPosZ`: 15, `JointCQuatX`: 16, `JointCQuatY`: 17, `JointCQuatZ`: 18, `JointCQuatW`: 19, `JointLinearDoFN`: 20, `JointAngularDoFN`: 21, `JointDoF1`: 22, `JointDoF2`: 23, `JointDoF3`: 24, `JointDoF4`: 25, `JointDoF5`: 26, `JointDoF6`: 27, `JointPForceX`: 28, `JointPForceY`: 29, `JointPForceZ`: 30, `JointPTorqueX`: 31, `JointPTorqueY`: 32, `JointPTorqueZ`: 33, `JointCForceX`: 34, `JointCForceY`: 35, `JointCForceZ`: 36, `JointCTorqueX`: 37, `JointCTorqueY`: 38, `JointCTorqueZ`: 39, `JointLinLambdaX`: 40, `JointLinLambdaY`: 41, `JointLinLambdaZ`: 42, `JointAngLambdaX`: 43, `JointAngLambdaY`: 44, `JointAngLambdaZ`: 45}

var _JointVarsDescMap = map[JointVars]string{0: `JointType (as an int32 from bits).`, 1: `JointEnabled allows joints to be dynamically enabled.`, 2: `JointParentFixed means that the parent is NOT updated based on the forces and positions for this joint. This can make dynamics cleaner when full accuracy is not necessary.`, 3: `JointNoLinearRotation ignores the rotational (angular) effects of linear joint position constraints (i.e., Coriolis and centrifugal forces) which can otherwise interfere with rotational position constraints in joints with both linear and angular DoFs (e.g., [PlaneXZ], for which this is on by default).`, 4: `JointParent is the dynamic body index for parent body. Can be -1 for a fixed parent for absolute anchor.`, 5: `JointChild is the dynamic body index for child body.`, 6: `relative position of joint, in parent frame. This is prior to parent body rotation.`, 7: ``, 8: ``, 9: `relative orientation of joint, in parent frame. This is prior to parent body rotation.`, 10: ``, 11: ``, 12: ``, 13: `relative position of joint, in child frame. This is prior to child body rotation.`, 14: ``, 15: ``, 16: `relative orientation of joint, in child frame. This is prior to parent body rotation.`, 17: ``, 18: ``, 19: ``, 20: `JointLinearDoFN is the number of linear degrees-of-freedom for the joint.`, 21: `JointAngularDoFN is the number of angular degrees-of-freedom for the joint.`, 22: `indexes in JointDoFs for each DoF`, 23: ``, 24: ``, 25: `angular starts here for Free, Distance, D6`, 26: ``, 27: ``, 28: `Computed parent joint force value.`, 29: ``, 30: ``, 31: `Computed parent joint torque value.`, 32: ``, 33: ``, 34: `Computed child joint force value.`, 35: ``, 36: ``, 37: `Computed child joint torque value.`, 38: ``, 39: ``, 40: `Computed linear lambdas.`, 41: ``, 42: ``, 43: `Computed angular lambdas.`, 44: ``, 45: ``}

var _JointVarsMap = map[JointVars]string{0: `JointType`, 1: `JointEnabled`, 2: `JointParentFixed`, 3: `JointNoLinearRotation`, 4: `JointParent`, 5: `JointChild`, 6: `JointPPosX`, 7: `JointPPosY`, 8: `JointPPosZ`, 9: `JointPQuatX`, 10: `JointPQuatY`, 11: `JointPQuatZ`, 12: `JointPQuatW`, 13: `JointCPosX`, 14: `JointCPosY`, 15: `JointCPosZ`, 16: `JointCQuatX`, 17: `JointCQuatY`, 18: `JointCQuatZ`, 19: `JointCQuatW`, 20: `JointLinearDoFN`, 21: `JointAngularDoFN`, 22: `JointDoF1`, 23: `JointDoF2`, 24: `JointDoF3`, 25: `JointDoF4`, 26: `JointDoF5`, 27: `JointDoF6`, 28: `JointPForceX`, 29: `JointPForceY`, 30: `JointPForceZ`, 31: `JointPTorqueX`, 32: `JointPTorqueY`, 33: `JointPTorqueZ`, 34: `JointCForceX`, 35: `JointCForceY`, 36: `JointCForceZ`, 37: `JointCTorqueX`, 38: `JointCTorqueY`, 39: `JointCTorqueZ`, 40: `JointLinLambdaX`, 41: `JointLinLambdaY`, 42: `JointLinLambdaZ`, 43: `JointAngLambdaX`, 44: `JointAngLambdaY`, 45: `JointAngLambdaZ`}

// String returns the string representation of this JointVars value.
func (i JointVars) String() string { return enums.String(i, _JointVarsMap) }

// SetString sets the JointVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointVars) SetString(s string) error {
	return enums.SetString(i, s, _JointVarsValueMap, "JointVars")
}

// Int64 returns the JointVars value as an int64.
func (i JointVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointVars value from an int64.
func (i *JointVars) SetInt64(in int64) { *i = JointVars(in) }

// Desc returns the description of the JointVars value.
func (i JointVars) Desc() string { return enums.Desc(i, _JointVarsDescMap) }

// JointVarsValues returns all possible values for the type JointVars.
func JointVarsValues() []JointVars { return _JointVarsValues }

// Values returns all possible values for the type JointVars.
func (i JointVars) Values() []enums.Enum { return enums.Values(_JointVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointVars")
}

var _JointDoFVarsValues = []JointDoFVars{0, 1, 2, 3, 4}

// JointDoFVarsN is the highest valid value for type JointDoFVars, plus one.
//
//gosl:start
const JointDoFVarsN JointDoFVars = 5

//gosl:end

var _JointDoFVarsValueMap = map[string]JointDoFVars{`JointAxisX`: 0, `JointAxisY`: 1, `JointAxisZ`: 2, `JointLimitLower`: 3, `JointLimitUpper`: 4}

var _JointDoFVarsDescMap = map[JointDoFVars]string{0: `axis of articulation for the DoF`, 1: ``, 2: ``, 3: `joint limits`, 4: ``}

var _JointDoFVarsMap = map[JointDoFVars]string{0: `JointAxisX`, 1: `JointAxisY`, 2: `JointAxisZ`, 3: `JointLimitLower`, 4: `JointLimitUpper`}

// String returns the string representation of this JointDoFVars value.
func (i JointDoFVars) String() string { return enums.String(i, _JointDoFVarsMap) }

// SetString sets the JointDoFVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointDoFVars) SetString(s string) error {
	return enums.SetString(i, s, _JointDoFVarsValueMap, "JointDoFVars")
}

// Int64 returns the JointDoFVars value as an int64.
func (i JointDoFVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointDoFVars value from an int64.
func (i *JointDoFVars) SetInt64(in int64) { *i = JointDoFVars(in) }

// Desc returns the description of the JointDoFVars value.
func (i JointDoFVars) Desc() string { return enums.Desc(i, _JointDoFVarsDescMap) }

// JointDoFVarsValues returns all possible values for the type JointDoFVars.
func JointDoFVarsValues() []JointDoFVars { return _JointDoFVarsValues }

// Values returns all possible values for the type JointDoFVars.
func (i JointDoFVars) Values() []enums.Enum { return enums.Values(_JointDoFVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointDoFVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointDoFVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointDoFVars")
}

var _ShapesValues = []Shapes{0, 1, 2, 3, 4, 5}

// ShapesN is the highest valid value for type Shapes, plus one.
//
//gosl:start
const ShapesN Shapes = 6

//gosl:end

var _ShapesValueMap = map[string]Shapes{`Plane`: 0, `Sphere`: 1, `Capsule`: 2, `Cylinder`: 3, `Box`: 4, `Cone`: 5}

var _ShapesDescMap = map[Shapes]string{0: `Plane cannot be a dynamic shape, but is most efficient for collision computations. Use size = 0 for an infinite plane. Natively extends in the X-Z plane: SizeX x SizeZ.`, 1: `Sphere. SizeX is the radius.`, 2: `Capsule is a cylinder with half-spheres on the ends. Natively oriented vertically along the Y axis. SizeX = radius, SizeY = half-height.`, 3: `Cylinder, natively oriented vertically along the Y axis. SizeX = radius, SizeY = half-height in Y axis. Cylinder can not collide with a Box.`, 4: `Box is a 3D rectalinear shape. The sizes are _half_ sizes along each dimension, relative to the center.`, 5: `Cone is like a cylinder with the top radius = 0, oriented up. SizeX = bottom radius, SizeY = half-height in Y. Cone does not support any collisions and is not recommended for interacting bodies.`}

var _ShapesMap = map[Shapes]string{0: `Plane`, 1: `Sphere`, 2: `Capsule`, 3: `Cylinder`, 4: `Box`, 5: `Cone`}

// String returns the string representation of this Shapes value.
func (i Shapes) String() string { return enums.String(i, _ShapesMap) }

// SetString sets the Shapes value from its string representation,
// and returns an error if the string is invalid.
func (i *Shapes) SetString(s string) error { return enums.SetString(i, s, _ShapesValueMap, "Shapes") }

// Int64 returns the Shapes value as an int64.
func (i Shapes) Int64() int64 { return int64(i) }

// SetInt64 sets the Shapes value from an int64.
func (i *Shapes) SetInt64(in int64) { *i = Shapes(in) }

// Desc returns the description of the Shapes value.
func (i Shapes) Desc() string { return enums.Desc(i, _ShapesDescMap) }

// ShapesValues returns all possible values for the type Shapes.
func ShapesValues() []Shapes { return _ShapesValues }

// Values returns all possible values for the type Shapes.
func (i Shapes) Values() []enums.Enum { return enums.Values(_ShapesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Shapes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Shapes) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Shapes") }
