// Code generated by "core generate -add-types -gosl"; DO NOT EDIT.

package physics

import (
	"cogentcore.org/core/enums"
)

var _BodyVarsValues = []BodyVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36}

// BodyVarsN is the highest valid value for type BodyVars, plus one.
//
//gosl:start
const BodyVarsN BodyVars = 37

//gosl:end

var _BodyVarsValueMap = map[string]BodyVars{`BodyShape`: 0, `BodyWorldIndex`: 1, `BodySizeX`: 2, `BodySizeY`: 3, `BodySizeZ`: 4, `BodyMass`: 5, `BodyInvMass`: 6, `BodyBounce`: 7, `BodyFriction`: 8, `BodyPosX`: 9, `BodyPosY`: 10, `BodyPosZ`: 11, `BodyRotX`: 12, `BodyRotY`: 13, `BodyRotZ`: 14, `BodyRotW`: 15, `BodyComX`: 16, `BodyComY`: 17, `BodyComZ`: 18, `BodyInertiaXX`: 19, `BodyInertiaYX`: 20, `BodyInertiaZX`: 21, `BodyInertiaXY`: 22, `BodyInertiaYY`: 23, `BodyInertiaZY`: 24, `BodyInertiaXZ`: 25, `BodyInertiaYZ`: 26, `BodyInertiaZZ`: 27, `BodyInvInertiaXX`: 28, `BodyInvInertiaYX`: 29, `BodyInvInertiaZX`: 30, `BodyInvInertiaXY`: 31, `BodyInvInertiaYY`: 32, `BodyInvInertiaZY`: 33, `BodyInvInertiaXZ`: 34, `BodyInvInertiaYZ`: 35, `BodyInvInertiaZZ`: 36}

var _BodyVarsDescMap = map[BodyVars]string{0: `BodyShape is the shape type of the object, as a Shapes type.`, 1: `BodyWorldIndex partitions body into different worlds; Global are -1`, 2: `BodySize is the size of the object (values depend on shape type).`, 3: ``, 4: ``, 5: `BodyMass is the mass of the object.`, 6: `BodyInvMass is 1/mass of the object or 0 if no mass.`, 7: `BodyBounce specifies the COR or coefficient of restitution (0..1), which determines how elastic the collision is, i.e., final velocity / initial velocity.`, 8: `BodyFriction coefficient: how much friction is generated by transverse motion. Additive across the two surfaces.`, 9: `3D position of body (structural center).`, 10: ``, 11: ``, 12: `Quaternion rotation of body.`, 13: ``, 14: ``, 15: ``, 16: `Relative center-of-mass offset from 3D position of body.`, 17: ``, 18: ``, 19: `Inertia 3x3 matrix (column matrix organization, r,c labels).`, 20: ``, 21: ``, 22: ``, 23: ``, 24: ``, 25: ``, 26: ``, 27: ``, 28: `InvInertia inverse inertia 3x3 matrix (column matrix organization, r,c labels).`, 29: ``, 30: ``, 31: ``, 32: ``, 33: ``, 34: ``, 35: ``, 36: ``}

var _BodyVarsMap = map[BodyVars]string{0: `BodyShape`, 1: `BodyWorldIndex`, 2: `BodySizeX`, 3: `BodySizeY`, 4: `BodySizeZ`, 5: `BodyMass`, 6: `BodyInvMass`, 7: `BodyBounce`, 8: `BodyFriction`, 9: `BodyPosX`, 10: `BodyPosY`, 11: `BodyPosZ`, 12: `BodyRotX`, 13: `BodyRotY`, 14: `BodyRotZ`, 15: `BodyRotW`, 16: `BodyComX`, 17: `BodyComY`, 18: `BodyComZ`, 19: `BodyInertiaXX`, 20: `BodyInertiaYX`, 21: `BodyInertiaZX`, 22: `BodyInertiaXY`, 23: `BodyInertiaYY`, 24: `BodyInertiaZY`, 25: `BodyInertiaXZ`, 26: `BodyInertiaYZ`, 27: `BodyInertiaZZ`, 28: `BodyInvInertiaXX`, 29: `BodyInvInertiaYX`, 30: `BodyInvInertiaZX`, 31: `BodyInvInertiaXY`, 32: `BodyInvInertiaYY`, 33: `BodyInvInertiaZY`, 34: `BodyInvInertiaXZ`, 35: `BodyInvInertiaYZ`, 36: `BodyInvInertiaZZ`}

// String returns the string representation of this BodyVars value.
func (i BodyVars) String() string { return enums.String(i, _BodyVarsMap) }

// SetString sets the BodyVars value from its string representation,
// and returns an error if the string is invalid.
func (i *BodyVars) SetString(s string) error {
	return enums.SetString(i, s, _BodyVarsValueMap, "BodyVars")
}

// Int64 returns the BodyVars value as an int64.
func (i BodyVars) Int64() int64 { return int64(i) }

// SetInt64 sets the BodyVars value from an int64.
func (i *BodyVars) SetInt64(in int64) { *i = BodyVars(in) }

// Desc returns the description of the BodyVars value.
func (i BodyVars) Desc() string { return enums.Desc(i, _BodyVarsDescMap) }

// BodyVarsValues returns all possible values for the type BodyVars.
func BodyVarsValues() []BodyVars { return _BodyVarsValues }

// Values returns all possible values for the type BodyVars.
func (i BodyVars) Values() []enums.Enum { return enums.Values(_BodyVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i BodyVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *BodyVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "BodyVars") }

var _ContactVarsValues = []ContactVars{0, 1, 2, 3, 4, 5, 6, 7, 8}

// ContactVarsN is the highest valid value for type ContactVars, plus one.
//
//gosl:start
const ContactVarsN ContactVars = 9

//gosl:end

var _ContactVarsValueMap = map[string]ContactVars{`ContactA`: 0, `ContactB`: 1, `ContactNormX`: 2, `ContactNormY`: 3, `ContactNormZ`: 4, `ContactPointX`: 5, `ContactPointY`: 6, `ContactPointZ`: 7, `ContactDist`: 8}

var _ContactVarsDescMap = map[ContactVars]string{0: `first body`, 1: `the other body`, 2: `normal pointing from center of B to center of A`, 3: ``, 4: ``, 5: `point on spherical shell of B where A is contacting`, 6: ``, 7: ``, 8: `ContactDist is the distance from PtB along NormB to contact point on spherical shell of A.`}

var _ContactVarsMap = map[ContactVars]string{0: `ContactA`, 1: `ContactB`, 2: `ContactNormX`, 3: `ContactNormY`, 4: `ContactNormZ`, 5: `ContactPointX`, 6: `ContactPointY`, 7: `ContactPointZ`, 8: `ContactDist`}

// String returns the string representation of this ContactVars value.
func (i ContactVars) String() string { return enums.String(i, _ContactVarsMap) }

// SetString sets the ContactVars value from its string representation,
// and returns an error if the string is invalid.
func (i *ContactVars) SetString(s string) error {
	return enums.SetString(i, s, _ContactVarsValueMap, "ContactVars")
}

// Int64 returns the ContactVars value as an int64.
func (i ContactVars) Int64() int64 { return int64(i) }

// SetInt64 sets the ContactVars value from an int64.
func (i *ContactVars) SetInt64(in int64) { *i = ContactVars(in) }

// Desc returns the description of the ContactVars value.
func (i ContactVars) Desc() string { return enums.Desc(i, _ContactVarsDescMap) }

// ContactVarsValues returns all possible values for the type ContactVars.
func ContactVarsValues() []ContactVars { return _ContactVarsValues }

// Values returns all possible values for the type ContactVars.
func (i ContactVars) Values() []enums.Enum { return enums.Values(_ContactVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i ContactVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *ContactVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "ContactVars")
}

var _JointControlVarsValues = []JointControlVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}

// JointControlVarsN is the highest valid value for type JointControlVars, plus one.
//
//gosl:start
const JointControlVarsN JointControlVars = 19

//gosl:end

var _JointControlVarsValueMap = map[string]JointControlVars{`JointCtrlForceX`: 0, `JointCtrlForceY`: 1, `JointCtrlForceZ`: 2, `JointCtrlTorqueX`: 3, `JointCtrlTorqueY`: 4, `JointCtrlTorqueZ`: 5, `JointTargetPosX`: 6, `JointTargetPosY`: 7, `JointTargetPosZ`: 8, `JointTargetRotX`: 9, `JointTargetRotY`: 10, `JointTargetRotZ`: 11, `JointTargetRotW`: 12, `JointTargetVelX`: 13, `JointTargetVelY`: 14, `JointTargetVelZ`: 15, `JointTargetAngVelX`: 16, `JointTargetAngVelY`: 17, `JointTargetAngVelZ`: 18}

var _JointControlVarsDescMap = map[JointControlVars]string{0: `Joint force and torque inputs`, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: `target values (1 DoF use JointTargetPosX)`, 7: ``, 8: ``, 9: ``, 10: ``, 11: ``, 12: ``, 13: `target velocity`, 14: ``, 15: ``, 16: `target angular velocity`, 17: ``, 18: ``}

var _JointControlVarsMap = map[JointControlVars]string{0: `JointCtrlForceX`, 1: `JointCtrlForceY`, 2: `JointCtrlForceZ`, 3: `JointCtrlTorqueX`, 4: `JointCtrlTorqueY`, 5: `JointCtrlTorqueZ`, 6: `JointTargetPosX`, 7: `JointTargetPosY`, 8: `JointTargetPosZ`, 9: `JointTargetRotX`, 10: `JointTargetRotY`, 11: `JointTargetRotZ`, 12: `JointTargetRotW`, 13: `JointTargetVelX`, 14: `JointTargetVelY`, 15: `JointTargetVelZ`, 16: `JointTargetAngVelX`, 17: `JointTargetAngVelY`, 18: `JointTargetAngVelZ`}

// String returns the string representation of this JointControlVars value.
func (i JointControlVars) String() string { return enums.String(i, _JointControlVarsMap) }

// SetString sets the JointControlVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointControlVars) SetString(s string) error {
	return enums.SetString(i, s, _JointControlVarsValueMap, "JointControlVars")
}

// Int64 returns the JointControlVars value as an int64.
func (i JointControlVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointControlVars value from an int64.
func (i *JointControlVars) SetInt64(in int64) { *i = JointControlVars(in) }

// Desc returns the description of the JointControlVars value.
func (i JointControlVars) Desc() string { return enums.Desc(i, _JointControlVarsDescMap) }

// JointControlVarsValues returns all possible values for the type JointControlVars.
func JointControlVarsValues() []JointControlVars { return _JointControlVarsValues }

// Values returns all possible values for the type JointControlVars.
func (i JointControlVars) Values() []enums.Enum { return enums.Values(_JointControlVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointControlVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointControlVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointControlVars")
}

var _DynamicVarsValues = []DynamicVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}

// DynamicVarsN is the highest valid value for type DynamicVars, plus one.
//
//gosl:start
const DynamicVarsN DynamicVars = 32

//gosl:end

var _DynamicVarsValueMap = map[string]DynamicVars{`DynIndex`: 0, `DynPosX`: 1, `DynPosY`: 2, `DynPosZ`: 3, `DynRotX`: 4, `DynRotY`: 5, `DynRotZ`: 6, `DynRotW`: 7, `DynVelX`: 8, `DynVelY`: 9, `DynVelZ`: 10, `DynAngVelX`: 11, `DynAngVelY`: 12, `DynAngVelZ`: 13, `DynAccX`: 14, `DynAccY`: 15, `DynAccZ`: 16, `DynAngAccX`: 17, `DynAngAccY`: 18, `DynAngAccZ`: 19, `DynForceX`: 20, `DynForceY`: 21, `DynForceZ`: 22, `DynTorqueX`: 23, `DynTorqueY`: 24, `DynTorqueZ`: 25, `DynDeltaX`: 26, `DynDeltaY`: 27, `DynDeltaZ`: 28, `DynAngDeltaX`: 29, `DynAngDeltaY`: 30, `DynAngDeltaZ`: 31}

var _DynamicVarsDescMap = map[DynamicVars]string{0: `Index of body in list of bodies.`, 1: `3D position of center of mass.`, 2: ``, 3: ``, 4: `Quaternion rotation.`, 5: ``, 6: ``, 7: ``, 8: `Linear velocity.`, 9: ``, 10: ``, 11: `Angular velocity.`, 12: ``, 13: ``, 14: `Linear acceleration.`, 15: ``, 16: ``, 17: `Angular acceleration due to applied torques.`, 18: ``, 19: ``, 20: `Linear force driving linear acceleration (from joints, etc).`, 21: ``, 22: ``, 23: `Torque driving angular acceleration (from joints, etc).`, 24: ``, 25: ``, 26: `Linear deltas.`, 27: ``, 28: ``, 29: `Angular deltas.`, 30: ``, 31: ``}

var _DynamicVarsMap = map[DynamicVars]string{0: `DynIndex`, 1: `DynPosX`, 2: `DynPosY`, 3: `DynPosZ`, 4: `DynRotX`, 5: `DynRotY`, 6: `DynRotZ`, 7: `DynRotW`, 8: `DynVelX`, 9: `DynVelY`, 10: `DynVelZ`, 11: `DynAngVelX`, 12: `DynAngVelY`, 13: `DynAngVelZ`, 14: `DynAccX`, 15: `DynAccY`, 16: `DynAccZ`, 17: `DynAngAccX`, 18: `DynAngAccY`, 19: `DynAngAccZ`, 20: `DynForceX`, 21: `DynForceY`, 22: `DynForceZ`, 23: `DynTorqueX`, 24: `DynTorqueY`, 25: `DynTorqueZ`, 26: `DynDeltaX`, 27: `DynDeltaY`, 28: `DynDeltaZ`, 29: `DynAngDeltaX`, 30: `DynAngDeltaY`, 31: `DynAngDeltaZ`}

// String returns the string representation of this DynamicVars value.
func (i DynamicVars) String() string { return enums.String(i, _DynamicVarsMap) }

// SetString sets the DynamicVars value from its string representation,
// and returns an error if the string is invalid.
func (i *DynamicVars) SetString(s string) error {
	return enums.SetString(i, s, _DynamicVarsValueMap, "DynamicVars")
}

// Int64 returns the DynamicVars value as an int64.
func (i DynamicVars) Int64() int64 { return int64(i) }

// SetInt64 sets the DynamicVars value from an int64.
func (i *DynamicVars) SetInt64(in int64) { *i = DynamicVars(in) }

// Desc returns the description of the DynamicVars value.
func (i DynamicVars) Desc() string { return enums.Desc(i, _DynamicVarsDescMap) }

// DynamicVarsValues returns all possible values for the type DynamicVars.
func DynamicVarsValues() []DynamicVars { return _DynamicVarsValues }

// Values returns all possible values for the type DynamicVars.
func (i DynamicVars) Values() []enums.Enum { return enums.Values(_DynamicVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i DynamicVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *DynamicVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "DynamicVars")
}

var _GPUVarsValues = []GPUVars{0, 1, 2, 3, 4, 5, 6}

// GPUVarsN is the highest valid value for type GPUVars, plus one.
//
//gosl:start
const GPUVarsN GPUVars = 7

//gosl:end

var _GPUVarsValueMap = map[string]GPUVars{`ParamsVar`: 0, `BodiesVar`: 1, `JointsVar`: 2, `BodyJointsVar`: 3, `DynamicsVar`: 4, `ContactsVar`: 5, `JointControlsVar`: 6}

var _GPUVarsDescMap = map[GPUVars]string{0: ``, 1: ``, 2: ``, 3: ``, 4: ``, 5: ``, 6: ``}

var _GPUVarsMap = map[GPUVars]string{0: `ParamsVar`, 1: `BodiesVar`, 2: `JointsVar`, 3: `BodyJointsVar`, 4: `DynamicsVar`, 5: `ContactsVar`, 6: `JointControlsVar`}

// String returns the string representation of this GPUVars value.
func (i GPUVars) String() string { return enums.String(i, _GPUVarsMap) }

// SetString sets the GPUVars value from its string representation,
// and returns an error if the string is invalid.
func (i *GPUVars) SetString(s string) error {
	return enums.SetString(i, s, _GPUVarsValueMap, "GPUVars")
}

// Int64 returns the GPUVars value as an int64.
func (i GPUVars) Int64() int64 { return int64(i) }

// SetInt64 sets the GPUVars value from an int64.
func (i *GPUVars) SetInt64(in int64) { *i = GPUVars(in) }

// Desc returns the description of the GPUVars value.
func (i GPUVars) Desc() string { return enums.Desc(i, _GPUVarsDescMap) }

// GPUVarsValues returns all possible values for the type GPUVars.
func GPUVarsValues() []GPUVars { return _GPUVarsValues }

// Values returns all possible values for the type GPUVars.
func (i GPUVars) Values() []enums.Enum { return enums.Values(_GPUVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i GPUVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *GPUVars) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "GPUVars") }

var _JointVarsValues = []JointVars{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52}

// JointVarsN is the highest valid value for type JointVars, plus one.
//
//gosl:start
const JointVarsN JointVars = 53

//gosl:end

var _JointVarsValueMap = map[string]JointVars{`JointType`: 0, `JointEnabled`: 1, `JointParent`: 2, `JointChild`: 3, `JointPPosX`: 4, `JointPPosY`: 5, `JointPPosZ`: 6, `JointPRotX`: 7, `JointPRotY`: 8, `JointPRotZ`: 9, `JointPRotW`: 10, `JointCPosX`: 11, `JointCPosY`: 12, `JointCPosZ`: 13, `JointCRotX`: 14, `JointCRotY`: 15, `JointCRotZ`: 16, `JointCRotW`: 17, `JointAxisX`: 18, `JointAxisY`: 19, `JointAxisZ`: 20, `JointLimitLower`: 21, `JointLimitUpper`: 22, `JointStiffX`: 23, `JointStiffY`: 24, `JointStiffZ`: 25, `JointDampX`: 26, `JointDampY`: 27, `JointDampZ`: 28, `JointPForceX`: 29, `JointPForceY`: 30, `JointPForceZ`: 31, `JointPTorqueX`: 32, `JointPTorqueY`: 33, `JointPTorqueZ`: 34, `JointCForceX`: 35, `JointCForceY`: 36, `JointCForceZ`: 37, `JointCTorqueX`: 38, `JointCTorqueY`: 39, `JointCTorqueZ`: 40, `JointPDeltaX`: 41, `JointPDeltaY`: 42, `JointPDeltaZ`: 43, `JointPAngDeltaX`: 44, `JointPAngDeltaY`: 45, `JointPAngDeltaZ`: 46, `JointCDeltaX`: 47, `JointCDeltaY`: 48, `JointCDeltaZ`: 49, `JointCAngDeltaX`: 50, `JointCAngDeltaY`: 51, `JointCAngDeltaZ`: 52}

var _JointVarsDescMap = map[JointVars]string{0: `JointType (as an int32 from bits).`, 1: `JointEnabled allows joints to be dynamically enabled.`, 2: `JointParent is the dynamic body index for parent body. Can be -1 for a fixed parent for absolute anchor.`, 3: `JointChild is the dynamic body index for child body.`, 4: `relative position of joint, in parent frame.`, 5: ``, 6: ``, 7: `relative orientation of joint, in parent frame.`, 8: ``, 9: ``, 10: ``, 11: `relative position of joint, in child frame.`, 12: ``, 13: ``, 14: `relative orientation of joint, in child frame.`, 15: ``, 16: ``, 17: ``, 18: `axis of articulation for the joint`, 19: ``, 20: ``, 21: `joint limits`, 22: ``, 23: `joint stiffness target (ke)`, 24: ``, 25: ``, 26: `joint damping target (kd)`, 27: ``, 28: ``, 29: `Computed parent joint force value.`, 30: ``, 31: ``, 32: `Computed parent joint torque value.`, 33: ``, 34: ``, 35: `Computed child joint force value.`, 36: ``, 37: ``, 38: `Computed child joint torque value.`, 39: ``, 40: ``, 41: `Computed parent joint delta value.`, 42: ``, 43: ``, 44: `Computed parent joint angdelta value.`, 45: ``, 46: ``, 47: `Computed child joint delta value.`, 48: ``, 49: ``, 50: `Computed child joint angdelta value.`, 51: ``, 52: ``}

var _JointVarsMap = map[JointVars]string{0: `JointType`, 1: `JointEnabled`, 2: `JointParent`, 3: `JointChild`, 4: `JointPPosX`, 5: `JointPPosY`, 6: `JointPPosZ`, 7: `JointPRotX`, 8: `JointPRotY`, 9: `JointPRotZ`, 10: `JointPRotW`, 11: `JointCPosX`, 12: `JointCPosY`, 13: `JointCPosZ`, 14: `JointCRotX`, 15: `JointCRotY`, 16: `JointCRotZ`, 17: `JointCRotW`, 18: `JointAxisX`, 19: `JointAxisY`, 20: `JointAxisZ`, 21: `JointLimitLower`, 22: `JointLimitUpper`, 23: `JointStiffX`, 24: `JointStiffY`, 25: `JointStiffZ`, 26: `JointDampX`, 27: `JointDampY`, 28: `JointDampZ`, 29: `JointPForceX`, 30: `JointPForceY`, 31: `JointPForceZ`, 32: `JointPTorqueX`, 33: `JointPTorqueY`, 34: `JointPTorqueZ`, 35: `JointCForceX`, 36: `JointCForceY`, 37: `JointCForceZ`, 38: `JointCTorqueX`, 39: `JointCTorqueY`, 40: `JointCTorqueZ`, 41: `JointPDeltaX`, 42: `JointPDeltaY`, 43: `JointPDeltaZ`, 44: `JointPAngDeltaX`, 45: `JointPAngDeltaY`, 46: `JointPAngDeltaZ`, 47: `JointCDeltaX`, 48: `JointCDeltaY`, 49: `JointCDeltaZ`, 50: `JointCAngDeltaX`, 51: `JointCAngDeltaY`, 52: `JointCAngDeltaZ`}

// String returns the string representation of this JointVars value.
func (i JointVars) String() string { return enums.String(i, _JointVarsMap) }

// SetString sets the JointVars value from its string representation,
// and returns an error if the string is invalid.
func (i *JointVars) SetString(s string) error {
	return enums.SetString(i, s, _JointVarsValueMap, "JointVars")
}

// Int64 returns the JointVars value as an int64.
func (i JointVars) Int64() int64 { return int64(i) }

// SetInt64 sets the JointVars value from an int64.
func (i *JointVars) SetInt64(in int64) { *i = JointVars(in) }

// Desc returns the description of the JointVars value.
func (i JointVars) Desc() string { return enums.Desc(i, _JointVarsDescMap) }

// JointVarsValues returns all possible values for the type JointVars.
func JointVarsValues() []JointVars { return _JointVarsValues }

// Values returns all possible values for the type JointVars.
func (i JointVars) Values() []enums.Enum { return enums.Values(_JointVarsValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointVars) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointVars) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointVars")
}

var _JointTypesValues = []JointTypes{0, 1, 2, 3, 4, 5, 6}

// JointTypesN is the highest valid value for type JointTypes, plus one.
//
//gosl:start
const JointTypesN JointTypes = 7

//gosl:end

var _JointTypesValueMap = map[string]JointTypes{`Prismatic`: 0, `Revolute`: 1, `Ball`: 2, `Fixed`: 3, `Free`: 4, `Distance`: 5, `D6`: 6}

var _JointTypesDescMap = map[JointTypes]string{0: `Prismatic allows translation along a single axis (slider): 1 DoF.`, 1: `Revolute allows rotation about a single axis (axel): 1 DoF.`, 2: `Ball allows rotation about all three axes (3 DoF, quaternion).`, 3: `Fixed locks all relative motion: 0 DoF.`, 4: `Free allows full 6-DoF motion (translation and rotation).`, 5: `Distance keeps two bodies a distance within joint limits: 6 DoF.`, 6: `D6 is a generic 6-DoF joint.`}

var _JointTypesMap = map[JointTypes]string{0: `Prismatic`, 1: `Revolute`, 2: `Ball`, 3: `Fixed`, 4: `Free`, 5: `Distance`, 6: `D6`}

// String returns the string representation of this JointTypes value.
func (i JointTypes) String() string { return enums.String(i, _JointTypesMap) }

// SetString sets the JointTypes value from its string representation,
// and returns an error if the string is invalid.
func (i *JointTypes) SetString(s string) error {
	return enums.SetString(i, s, _JointTypesValueMap, "JointTypes")
}

// Int64 returns the JointTypes value as an int64.
func (i JointTypes) Int64() int64 { return int64(i) }

// SetInt64 sets the JointTypes value from an int64.
func (i *JointTypes) SetInt64(in int64) { *i = JointTypes(in) }

// Desc returns the description of the JointTypes value.
func (i JointTypes) Desc() string { return enums.Desc(i, _JointTypesDescMap) }

// JointTypesValues returns all possible values for the type JointTypes.
func JointTypesValues() []JointTypes { return _JointTypesValues }

// Values returns all possible values for the type JointTypes.
func (i JointTypes) Values() []enums.Enum { return enums.Values(_JointTypesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i JointTypes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *JointTypes) UnmarshalText(text []byte) error {
	return enums.UnmarshalText(i, text, "JointTypes")
}

var _ShapesValues = []Shapes{0, 1, 2, 3}

// ShapesN is the highest valid value for type Shapes, plus one.
//
//gosl:start
const ShapesN Shapes = 4

//gosl:end

var _ShapesValueMap = map[string]Shapes{`Box`: 0, `Sphere`: 1, `Cylinder`: 2, `Capsule`: 3}

var _ShapesDescMap = map[Shapes]string{0: `Box is a 3D rectalinear shape.`, 1: `Sphere. SizeX is the radius.`, 2: `Cylinder, natively oriented vertically along the Y axis. If one radius is 0, then it is a cone. SizeX = bottom radius, SizeY = height in Y axis, SizeZ = top radius.`, 3: `Capsule, which is a cylinder with half-spheres on the ends. Natively oriented vertically along the Y axis. SizeX = bottom radius, SizeY = height, SizeZ = top radius.`}

var _ShapesMap = map[Shapes]string{0: `Box`, 1: `Sphere`, 2: `Cylinder`, 3: `Capsule`}

// String returns the string representation of this Shapes value.
func (i Shapes) String() string { return enums.String(i, _ShapesMap) }

// SetString sets the Shapes value from its string representation,
// and returns an error if the string is invalid.
func (i *Shapes) SetString(s string) error { return enums.SetString(i, s, _ShapesValueMap, "Shapes") }

// Int64 returns the Shapes value as an int64.
func (i Shapes) Int64() int64 { return int64(i) }

// SetInt64 sets the Shapes value from an int64.
func (i *Shapes) SetInt64(in int64) { *i = Shapes(in) }

// Desc returns the description of the Shapes value.
func (i Shapes) Desc() string { return enums.Desc(i, _ShapesDescMap) }

// ShapesValues returns all possible values for the type Shapes.
func ShapesValues() []Shapes { return _ShapesValues }

// Values returns all possible values for the type Shapes.
func (i Shapes) Values() []enums.Enum { return enums.Values(_ShapesValues) }

// MarshalText implements the [encoding.TextMarshaler] interface.
func (i Shapes) MarshalText() ([]byte, error) { return []byte(i.String()), nil }

// UnmarshalText implements the [encoding.TextUnmarshaler] interface.
func (i *Shapes) UnmarshalText(text []byte) error { return enums.UnmarshalText(i, text, "Shapes") }
