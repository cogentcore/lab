// Code generated by "goal build"; DO NOT EDIT.
//line step_joint.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

// notation convention:
// spatial transform: R = position, Q = quat rotation
// P = parent, C = child
// x = transform, w = world
// d = moment arm

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// StepJointForces computes joint forces.
func StepJointForces(i uint32) { //gosl:kernel
	params := GetParams(0)
	ji := int32(i)
	if ji >= params.JointsN {
		return
	}
	jt := GetJointType(ji)
	if !GetJointEnabled(ji) {
		return
	}

	jPi := JointParentIndex(ji)
	jPbi := int32(-1)
	if jPi >= 0 {
		jPbi = DynamicIndex(jPi, params.Cur)
	}
	jCi := JointChildIndex(ji)
	jCbi := DynamicIndex(jCi, params.Cur)

	jLinearN := GetJointLinearDoFN(ji)
	jAngularN := GetJointAngularDoFN(ji)

	jPR := JointPPos(ji)
	jPQ := JointPQuat(ji)

	// parent world transform
	xwPR := jPR
	xwPQ := jPQ
	posePR := jPR
	posePQ := jPQ
	comP := math32.Vec3(0, 0, 0)

	if jPi >= 0 { // can be fixed
		posePR = DynamicPos(jPi, params.Cur)
		posePQ = DynamicQuat(jPi, params.Cur)
		slmath.MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ)
		comP = BodyCom(jPbi)
	}
	dP := xwPR.Sub(slmath.MulSpatialPoint(posePR, posePQ, comP)) // parent moment arm

	// child world transform
	poseCR := DynamicPos(jCi, params.Cur)
	poseCQ := DynamicQuat(jCi, params.Cur)
	// note: NOT doing this: slmath.MulSpatialTransforms(poseCR, poseCQ, jCR, jCQ, &xwCR, &xwCQ)
	// https://github.com/newton-physics/newton/issues/1261
	comC := BodyCom(jCbi)
	dC := poseCR.Sub(slmath.MulSpatialPoint(poseCR, poseCQ, comC)) // child moment arm

	var f, t math32.Vector3
	switch jt {
	case Free, Distance:
		f = math32.Vec3(JointControl(ji, 0, JointControlForce), JointControl(ji, 1, JointControlForce), JointControl(ji, 2, JointControlForce))
		t = math32.Vec3(JointControl(ji, 3, JointControlForce), JointControl(ji, 4, JointControlForce), JointControl(ji, 5, JointControlForce))
	case Ball:
		// note: assuming the axes are x, y, z
		t = math32.Vec3(JointControl(ji, 0, JointControlForce), JointControl(ji, 1, JointControlForce), JointControl(ji, 2, JointControlForce))
	case Revolute:
		axis := JointAxis(ji, 0)
		t = slmath.MulScalar3(slmath.MulQuatVector(xwPQ, axis), JointControl(ji, 0, JointControlForce))
	case Prismatic:
		axis := JointAxis(ji, 0)
		f = slmath.MulScalar3(slmath.MulQuatVector(xwPQ, axis), JointControl(ji, 0, JointControlForce))
	default:
		for dof := range jLinearN {
			axis := JointAxis(ji, int32(dof))
			f = f.Add(slmath.MulScalar3(slmath.MulQuatVector(xwPQ, axis), JointControl(ji, int32(dof), JointControlForce)))
		}
		for dof := range jAngularN {
			di := int32(jLinearN) + int32(dof)
			axis := JointAxis(ji, di)
			t = t.Add(slmath.MulScalar3(slmath.MulQuatVector(xwPQ, axis), JointControl(ji, di, JointControlForce)))
		}
	}
	// These are unique to joint: aggregate into dynamics Next in [ForcesFromJoints]
	SetJointPForce(ji, f)
	SetJointCForce(ji, f)
	SetJointPTorque(ji, t.Add(slmath.Cross3(dP, f)))
	SetJointCTorque(ji, t.Add(slmath.Cross3(dC, f)))
}

// StepSolveJoints fixes joints after updating bodies.
func StepSolveJoints(i uint32) { //gosl:kernel
	params := GetParams(0)
	ji := int32(i)
	if ji >= params.JointsN {
		return
	}
	jt := GetJointType(ji)
	if jt == Free || !GetJointEnabled(ji) {
		return
	}
	jPi := JointParentIndex(ji)
	jPbi := int32(-1)
	if jPi >= 0 {
		jPbi = DynamicIndex(jPi, params.Cur)
	}
	jCi := JointChildIndex(ji)
	jCbi := DynamicIndex(jCi, params.Cur)

	jLinearN := GetJointLinearDoFN(ji)
	jAngularN := GetJointAngularDoFN(ji)

	jPR := JointPPos(ji)
	jPQ := JointPQuat(ji)
	xwPR := jPR // world xform, parent, pos
	xwPQ := jPQ // quat
	mInvP := float32(0.0)
	iInvP := math32.Mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
	posePR := jPR
	posePQ := jPQ

	var comP, vP, wP math32.Vector3

	// parent transform and moment arm
	if jPi >= 0 {
		posePR = DynamicPos(jPi, params.Next) // now using next
		posePQ = DynamicQuat(jPi, params.Next)
		slmath.MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ)
		comP = BodyCom(jPbi)
		mInvP = Bodies.Value(int(jPbi), int(BodyInvMass))
		iInvP = BodyInvInertia(jPbi)
		vP = DynamicDelta(jPi, params.Next)
		wP = DynamicAngDelta(jPi, params.Next)
	}

	// child transform and moment arm
	poseCR := DynamicPos(jCi, params.Next)
	poseCQ := DynamicQuat(jCi, params.Next)
	jCR := JointCPos(ji)
	jCQ := JointCQuat(ji)
	xwCR := jCR
	xwCQ := jCQ
	slmath.MulSpatialTransforms(poseCR, poseCQ, jCR, jCQ, &xwCR, &xwCQ)
	comC := BodyCom(jCbi)
	mInvC := Bodies.Value(int(jCbi), int(BodyInvMass))
	iInvC := BodyInvInertia(jCbi)
	vC := DynamicDelta(jCi, params.Next)
	wC := DynamicAngDelta(jCi, params.Next)

	if mInvP == 0.0 && mInvC == 0.0 { // connection between two immovable bodies
		return
	}

	// accumulate constraint deltas
	var linDeltaP, angDeltaP, linDeltaC, angDeltaC math32.Vector3

	relPoseR := xwPR
	relPoseQ := xwPQ
	slmath.SpatialTransformInverse(xwPR, xwPQ, &relPoseR, &relPoseQ)
	slmath.MulSpatialTransforms(relPoseR, relPoseQ, xwCR, xwCQ, &relPoseR, &relPoseQ)

	wComP := slmath.MulSpatialPoint(posePR, posePQ, comP)
	wComC := slmath.MulSpatialPoint(poseCR, poseCQ, comC)

	// handle positional constraints
	if jt == Distance {
		dP := xwPR.Sub(wComP)
		dC := xwCR.Sub(wComC)
		lo := JointDoF(ji, 0, JointLimitLower) // only first one has constraint
		up := JointDoF(ji, 0, JointLimitUpper)
		if lo < 0 && up < 0 { // not limited
			return
		}
		d := slmath.Length3(relPoseR)
		err := float32(0.0)
		if lo >= 0.0 && d < lo {
			err = d - lo
			// use a more descriptive direction vector for the constraint
			// in case the joint parent and child anchors are very close
			relPoseR = slmath.Normal3(wComC.Sub(wComP)).MulScalar(err)
		} else if up >= 0.0 && d > up {
			err = d - up
		}
		if math32.Abs(err) > 1e-9 {
			// compute gradients
			linearC := relPoseR
			linearP := slmath.Negate3(linearC)
			dC = xwCR.Sub(wComC)
			angularP := slmath.Negate3(slmath.Cross3(dP, linearC))
			angularC := slmath.Cross3(dC, linearC)
			// constraint time derivative
			derr := slmath.Dot3(linearP, vP) + slmath.Dot3(linearC, vC) + slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)
			lambdaIn := float32(0.0)
			compliance := params.JointLinearComply
			ke := JointDoF(ji, 0, JointStiff)
			kd := JointDoF(ji, 0, JointDamp)
			if ke > 0.0 {
				compliance = 1.0 / ke
			}
			dLambda := PositionalCorrection(err, derr, posePQ, poseCQ, mInvP, mInvC,
				iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, kd, params.Dt)
			linDeltaP = linDeltaP.Add(linearP.MulScalar(dLambda * params.JointLinearRelax))
			angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda * params.JointAngularRelax))
			linDeltaC = linDeltaC.Add(linearC.MulScalar(dLambda * params.JointLinearRelax))
			angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda * params.JointAngularRelax))
		}
	} else { // compute joint target, stiffness, damping
		var axisLimitsD, axisLimitsA math32.Vector3
		var axisTargetPosKeD, axisTargetPosKeA math32.Vector3
		var axisTargetVelKdD, axisTargetVelKdA math32.Vector3

		for dof := range jLinearN {
			axis := JointAxis(ji, dof)
			JointAxisLimitsUpdate(dof, axis, JointDoF(ji, dof, JointLimitLower), JointDoF(ji, dof, JointLimitUpper), &axisLimitsD, &axisLimitsA)
			ke := JointDoF(ji, dof, JointStiff)
			kd := JointDoF(ji, dof, JointDamp)
			targetPos := JointControl(ji, dof, JointTargetPos)
			targetVel := JointControl(ji, dof, JointTargetVel)
			if ke > 0.0 { // has position control
				JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA)
			}
			if kd > 0.0 { // has velocity control
				JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA)
			}
		}

		axisStiffness := axisTargetPosKeA
		axisDamping := axisTargetVelKdA
		axisTargetPosKeD = slmath.DivSafe3(axisTargetPosKeD, axisStiffness)
		axisTargetVelKdD = slmath.DivSafe3(axisTargetVelKdD, axisDamping)
		axisLimitsLower := axisLimitsD
		axisLimitsUpper := axisLimitsA
		// note that xwCR appearing in both is correct:
		dP := xwCR.Sub(wComP)
		dC := xwCR.Sub(slmath.MulSpatialPoint(poseCR, poseCQ, comC))

		for dim := range int32(3) {
			e := slmath.Dim3(relPoseR, dim)
			// compute gradients
			// matrix indexing is [row, col] here: dim = col
			// quat_to_matrix cols are q rotations of axis vectors
			dima := slmath.SetDim3(math32.Vec3(0, 0, 0), dim, 1) // axis for dim
			linearC := slmath.MulQuatVector(xwPQ, dima)
			linearP := slmath.Negate3(linearC)
			angularP := slmath.Negate3(slmath.Cross3(dP, linearC))
			angularC := slmath.Cross3(dC, linearC)
			// constraint time derivative
			derr := slmath.Dot3(linearP, vP) + slmath.Dot3(linearC, vC) + slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)

			err := float32(0.0)
			compliance := params.JointLinearComply
			damping := float32(0.0)

			targetVel := slmath.Dim3(axisTargetVelKdD, dim)
			derrRel := derr - targetVel

			// consider joint limits irrespective of axis mode
			lower := slmath.Dim3(axisLimitsLower, dim)
			upper := slmath.Dim3(axisLimitsUpper, dim)
			if e < lower {
				err = e - lower
			} else if e > upper {
				err = e - upper
			} else {
				targetPos := slmath.Dim3(axisTargetPosKeD, dim)
				targetPos = math32.Clamp(targetPos, lower, upper)

				ke := slmath.Dim3(axisStiffness, dim)
				kd := slmath.Dim3(axisDamping, dim)
				if ke > 0.0 {
					err = e - targetPos
					compliance = 1.0 / ke
					damping = slmath.Dim3(axisDamping, dim)
				} else if kd > 0.0 {
					compliance = 1.0 / kd
					damping = kd
				}
			}
			if math32.Abs(err) > 1e-9 || math32.Abs(derrRel) > 1e-9 {
				lambdaIn := float32(0.0)
				dLambda := PositionalCorrection(err, derrRel, posePQ, poseCQ, mInvP, mInvC,
					iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, damping, params.Dt)

				linDeltaP = linDeltaP.Add(linearP.MulScalar(dLambda * params.JointLinearRelax))
				angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda * params.JointAngularRelax))
				linDeltaC = linDeltaC.Add(linearC.MulScalar(dLambda * params.JointLinearRelax))
				angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda * params.JointAngularRelax))
			}
		}
	}
	// todo: does it make sense to have prismatic, fixed here?
	if jt == Fixed || jt == Prismatic || jt == Revolute || jt == D6 { // angular
		qP := xwPQ
		qC := xwCQ
		// make quats lie in same hemisphere
		if slmath.QuatDot(qP, qC) < 0 {
			qC = slmath.QuatMulScalar(qC, -1.0)
		}
		relQ := slmath.MulQuats(slmath.QuatInverse(qP), qC)
		qtwist := slmath.QuatNormalize(math32.NewQuat(relQ.X, 0.0, 0.0, relQ.W))
		qswing := slmath.MulQuats(relQ, slmath.QuatInverse(qtwist))

		// decompose to a compound rotation each axis
		s := math32.Sqrt(relQ.X*relQ.X + relQ.W*relQ.W)
		invs := 1.0 / s
		invscube := invs * invs * invs

		// handle axis-angle joints
		// rescale twist from quaternion space to angular
		err0 := 2.0 * math32.Asin(math32.Clamp(qtwist.X, -1.0, 1.0))
		err1 := qswing.Y
		err2 := qswing.Z
		// analytic gradients of swing-twist decomposition
		grad0 := math32.NewQuat(invs-relQ.X*relQ.X*invscube, 0.0, 0.0, -(relQ.W*relQ.X)*invscube)
		grad1 := math32.NewQuat(
			-relQ.W*(relQ.W*relQ.Z+relQ.X*relQ.Y)*invscube,
			relQ.W*invs,
			-relQ.X*invs,
			relQ.X*(relQ.W*relQ.Z+relQ.X*relQ.Y)*invscube)
		grad2 := math32.NewQuat(
			relQ.W*(relQ.W*relQ.Y-relQ.X*relQ.Z)*invscube,
			relQ.X*invs,
			relQ.W*invs,
			relQ.X*(relQ.Z*relQ.X-relQ.W*relQ.Y)*invscube)
		grad0 = slmath.QuatMulScalar(grad0, 2.0/math32.Abs(qtwist.W))
		//         # grad0 *= 2.0 / wp.sqrt(1.0-qtwist[0]*qtwist[0])	# derivative of asin(x) = 1/sqrt(1-x^2)

		// rescale swing
		swing_sq := qswing.W * qswing.W
		// if swing axis magnitude close to zero vector, just treat in quaternion space
		angularEps := float32(1.0e-4)
		if swing_sq+angularEps < 1.0 {
			d := math32.Sqrt(1.0 - qswing.W*qswing.W)
			theta := 2.0 * math32.Acos(math32.Clamp(qswing.W, -1.0, 1.0))
			scale := theta / d
			err1 *= scale
			err2 *= scale
			grad1 = slmath.QuatMulScalar(grad1, scale)
			grad2 = slmath.QuatMulScalar(grad2, scale)
		}
		errs := math32.Vec3(err0, err1, err2)
		gradX := math32.Vec3(grad0.X, grad1.X, grad2.X)
		gradY := math32.Vec3(grad0.Y, grad1.Y, grad2.Y)
		gradZ := math32.Vec3(grad0.Z, grad1.Z, grad2.Z)
		gradW := math32.Vec3(grad0.W, grad1.W, grad2.W)

		// compute joint target, stiffness, damping
		var axisLimitsD, axisLimitsA math32.Vector3
		var axisTargetPosKeD, axisTargetPosKeA math32.Vector3
		var axisTargetVelKdD, axisTargetVelKdA math32.Vector3

		for dof := range jAngularN {
			di := dof + jLinearN
			axis := JointAxis(ji, di)
			JointAxisLimitsUpdate(dof, axis, JointDoF(ji, di, JointLimitLower), JointDoF(ji, di, JointLimitUpper), &axisLimitsD, &axisLimitsA)
			ke := JointDoF(ji, di, JointStiff)
			kd := JointDoF(ji, di, JointDamp)
			targetPos := JointControl(ji, di, JointTargetPos)
			targetVel := JointControl(ji, di, JointTargetVel)
			if ke > 0.0 { // has position control
				JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA)
			}
			if kd > 0.0 { // has velocity control
				JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA)
			}
		}

		axisStiffness := axisTargetPosKeA
		axisDamping := axisTargetVelKdA
		axisTargetPosKeD = slmath.DivSafe3(axisTargetPosKeD, axisStiffness)
		axisTargetVelKdD = slmath.DivSafe3(axisTargetVelKdD, axisDamping)
		axisLimitsLower := axisLimitsD
		axisLimitsUpper := axisLimitsA

		for dim := range int32(3) {
			e := slmath.Dim3(errs, dim)

			// analytic gradients of swing-twist decomposition
			grad := math32.NewQuat(slmath.Dim3(gradX, dim), slmath.Dim3(gradY, dim), slmath.Dim3(gradZ, dim), slmath.Dim3(gradW, dim))
			// todo: verify -- does the 0.5 go inside??
			// quat_c = 0.5 * q_p * grad * wp.quat_inverse(q_c)
			quatC := slmath.MulQuats(slmath.MulQuats(slmath.QuatMulScalar(qP, 0.5), grad), slmath.QuatInverse(qC))

			angularC := math32.Vec3(quatC.X, quatC.Y, quatC.Z)
			angularP := slmath.Negate3(angularC)
			// constraint time derivative
			derr := slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)

			err := float32(0.0)
			compliance := params.JointLinearComply
			damping := float32(0.0)

			targetVel := slmath.Dim3(axisTargetVelKdD, dim)
			derrRel := derr - targetVel

			// consider joint limits irrespective of axis mode
			lower := slmath.Dim3(axisLimitsLower, dim)
			upper := slmath.Dim3(axisLimitsUpper, dim)
			if e < lower {
				err = e - lower
			} else if e > upper {
				err = e - upper
			} else {
				targetPos := slmath.Dim3(axisTargetPosKeD, dim)
				targetPos = math32.Clamp(targetPos, lower, upper)

				ke := slmath.Dim3(axisStiffness, dim)
				kd := slmath.Dim3(axisDamping, dim)
				if ke > 0.0 {
					err = e - targetPos
					compliance = 1.0 / ke
					damping = slmath.Dim3(axisDamping, dim)
				} else if kd > 0.0 {
					compliance = 1.0 / kd
					damping = kd
				}
			}
			lambdaIn := float32(0)
			dLambda := AngularCorrection(err, derrRel, posePQ, poseCQ, iInvP, iInvC, angularP, angularC, lambdaIn, compliance, damping, params.Dt)

			// note: no relaxation factors here:
			angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda))
			angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda))
		}
	}

	// These are unique to joint: aggregate into dynamics Next in separate step.
	SetJointPDelta(ji, linDeltaP)
	SetJointPAngDelta(ji, angDeltaP)
	SetJointCDelta(ji, linDeltaC)
	SetJointCAngDelta(ji, angDeltaC)
}

func JointAxisTarget(axis math32.Vector3, targ, weight float32, axisTargets, axisWeights *math32.Vector3) {
	weightedAxis := axis.MulScalar(weight)
	*axisTargets = (*axisTargets).Add(weightedAxis.MulScalar(targ)) // weighted target (to be normalized later by sum of weights)
	*axisWeights = (*axisWeights).Add(slmath.Abs3(weightedAxis))
}

func PositionalCorrection(err, derr float32, tfaQ, tfbQ math32.Quat, mInva, mInvb float32, iInva, iInvb math32.Matrix3, lineara, linearb, angulara, angularb math32.Vector3, lambdaIn, compliance, damping, dt float32) float32 {
	denom := float32(0.0)
	denom += slmath.LengthSquared3(lineara) * mInva
	denom += slmath.LengthSquared3(linearb) * mInvb

	// # Eq. 2-3 (make sure to project into the frame of the body)
	rotAngulara := slmath.MulQuatVectorInverse(tfaQ, angulara)
	rotAngularb := slmath.MulQuatVectorInverse(tfbQ, angularb)

	denom += slmath.Dot3(rotAngulara, iInva.MulVector3(rotAngulara))
	denom += slmath.Dot3(rotAngularb, iInvb.MulVector3(rotAngularb))

	alpha := compliance
	gamma := compliance * damping

	deltaLambda := -(err + alpha*lambdaIn + gamma*derr)
	if denom+alpha > 0.0 {
		deltaLambda /= (dt+gamma)*denom + alpha/dt
	}

	return deltaLambda
}

func AngularCorrection(err, derr float32, tfaQ, tfbQ math32.Quat, iInva, iInvb math32.Matrix3, angulara, angularb math32.Vector3, lambdaIn, compliance, damping, dt float32) float32 {
	// # Eq. 2-3 (make sure to project into the frame of the body)
	rotAngulara := slmath.MulQuatVectorInverse(tfaQ, angulara)
	rotAngularb := slmath.MulQuatVectorInverse(tfbQ, angularb)

	denom := float32(0.0)
	denom += slmath.Dot3(rotAngulara, iInva.MulVector3(rotAngulara))
	denom += slmath.Dot3(rotAngularb, iInvb.MulVector3(rotAngularb))

	alpha := compliance
	gamma := compliance * damping

	deltaLambda := -(err + alpha*lambdaIn + gamma*derr)
	if denom+alpha > 0.0 {
		deltaLambda /= (dt+gamma)*denom + alpha/dt
	}

	return deltaLambda
}

// update the 3D linear/angular limits (spatial_vector [lower, upper])
// given the axis vector and limits
func JointAxisLimitsUpdate(dof int32, axis math32.Vector3, lower, upper float32, axisLimitsD, axisLimitsA *math32.Vector3) {
	loTemp := axis.MulScalar(lower)
	upTemp := axis.MulScalar(upper)
	lo := slmath.Min3(loTemp, upTemp)
	up := slmath.Max3(loTemp, upTemp)
	if dof == 0 {
		*axisLimitsD = lo
		*axisLimitsA = up
	} else {
		*axisLimitsD = slmath.Min3(*axisLimitsD, lo)
		*axisLimitsA = slmath.Max3(*axisLimitsD, up)
	}
}

//gosl:end
