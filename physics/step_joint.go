// Code generated by "goal build"; DO NOT EDIT.
//line step_joint.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// StepJointForces computes joint forces.
func StepJointForces(i uint32) { //gosl:kernel
	params := GetParams(0)
	ji := int32(i)
	if ji >= params.JointsN {
		return
	}
	// todo: enabled
	jpi := JointParentIndex(ji)
	jpbi := DynamicIndex(jpi, params.Cur)
	jci := JointChildIndex(ji)
	jcbi := DynamicIndex(jci, params.Cur)
	jt := GetJointType(ji)

	jpP := JointPPos(ji)
	jpQ := JointPRot(ji)

	// parent world transform
	xwpP := jpP
	xwpQ := jpQ
	posepP := jpP
	posepQ := jpQ
	var comp math32.Vector3

	if jpi >= 0 { // can be fixed
		posepP = DynamicPos(jpi, params.Cur)
		posepQ = DynamicRot(jpi, params.Cur)
		slmath.MulQPTransforms(posepP, posepQ, jpP, jpQ, &xwpP, &xwpQ)
		comp = BodyCom(jpbi)
	}
	rp := xwpP.Sub(slmath.MulQPPoint(posepP, posepQ, comp)) // parent moment arm

	// child world transform
	posecP := DynamicPos(jci, params.Cur)
	posecQ := DynamicRot(jci, params.Cur)
	xwcP := posecP
	// xwcQ := posecQ
	comc := BodyCom(jcbi)
	rc := xwcP.Sub(slmath.MulQPPoint(posecP, posecQ, comc)) // child moment arm

	// from controls:
	jf := JointControlForce(ji)
	jtq := JointControlTorque(ji)

	var f, t math32.Vector3
	switch jt {
	case Free, Distance:
		// todo: distance doesn't seem to be supported here?
		f = jf
		t = jtq
	case Ball:
		t = jtq
	case Revolute, Prismatic:
		axis := JointAxis(ji)
		ap := slmath.MulQuatVector(xwpQ, axis)
		f = f.Add(slmath.MulScalar3(ap, jf.X))
	default:
		// todo: D6 requires more iteration!
	}
	// These are unique to joint: aggregate into dynamics Next in separate step.
	SetJointPForce(ji, f)
	SetJointCForce(ji, f)
	SetJointPTorque(ji, t.Add(slmath.Cross3(rp, f)))
	SetJointCTorque(ji, t.Add(slmath.Cross3(rc, f)))
}

// StepSolveJoints fixes joints after updating bodies.
func StepSolveJoints(i uint32) { //gosl:kernel
	params := GetParams(0)
	ji := int32(i)
	if ji >= params.JointsN {
		return
	}

	// todo: enabled
	jpi := JointParentIndex(ji)
	jpbi := DynamicIndex(jpi, params.Cur)
	jci := JointChildIndex(ji)
	jcbi := DynamicIndex(jci, params.Cur)
	jt := GetJointType(ji)

	if jt == Free {
		return
	}

	jpP := JointPPos(ji)
	jpQ := JointPRot(ji)
	xwpP := jpP // world xform, parent, pos
	xwpQ := jpQ // quat
	mInvp := float32(0.0)
	iInvp := math32.Mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
	posepP := jpP
	posepQ := jpQ

	var comp, velp, omegap math32.Vector3

	// parent transform and moment arm
	if jpi >= 0 {
		posepP = DynamicPos(jpi, params.Next) // now using next
		posepQ = DynamicRot(jpi, params.Next)
		slmath.MulQPTransforms(posepP, posepQ, jpP, jpQ, &xwpP, &xwpQ)
		comp = BodyCom(jpbi)
		mInvp = Bodies.Value(int(jpbi), int(BodyInvMass))
		iInvp = BodyInvInertia(jpbi)
		velp = DynamicDelta(jpi, params.Next)
		omegap = DynamicAngDelta(jpi, params.Next)
	}

	// child transform and moment arm
	posecP := DynamicPos(jci, params.Next)
	posecQ := DynamicRot(jci, params.Next)
	jcP := JointCPos(ji)
	jcQ := JointCRot(ji)
	xwcP := jcP
	xwcQ := jcQ
	slmath.MulQPTransforms(posecP, posecQ, jcP, jcQ, &xwcP, &xwcQ)
	comc := BodyCom(jcbi)
	mInvc := Bodies.Value(int(jcbi), int(BodyInvMass))
	iInvc := BodyInvInertia(jcbi)
	velc := DynamicDelta(jci, params.Next)
	omegac := DynamicAngDelta(jci, params.Next)

	if mInvp == 0.0 && mInvc == 0.0 { // connection between two immovable bodies
		return
	}

	// accumulate constraint deltas
	var linDeltaP, angDeltaP, linDeltaC, angDeltaC math32.Vector3

	relPoseP := xwpP
	relPoseQ := xwpQ
	slmath.QPTransformInverse(xwpP, xwpQ, &relPoseP, &relPoseQ)
	slmath.MulQPTransforms(relPoseP, relPoseQ, xwcP, xwcQ, &relPoseP, &relPoseQ)

	// joint connection points
	xc := xwcP

	//    axis_start = joint_qd_start[tid]
	//    lin_axis_count = joint_dof_dim[tid, 0]
	//    ang_axis_count = joint_dof_dim[tid, 1]

	worldComp := slmath.MulQPPoint(posepP, posepQ, comp)
	worldComc := slmath.MulQPPoint(posecP, posecQ, comc)
	_ = worldComc

	// handle positional constraints
	if jt == Distance {
		// r_p = wp.transform_get_translation(X_wp) - world_com_p
		// r_c = wp.transform_get_translation(X_wc) - world_com_c
		// lower = joint_limit_lower[axis_start]
		// upper = joint_limit_upper[axis_start]
		// if lower < 0.0 and upper < 0.0:
		//
		//	# no limits
		//	return
		//
		// d = wp.length(rel_p)
		// err = 0.0
		// if lower >= 0.0 and d < lower:
		//
		//	err = d - lower
		//	# use a more descriptive direction vector for the constraint
		//	# in case the joint parent and child anchors are very close
		//	rel_p = err * wp.normalize(world_com_c - world_com_p)
		//
		// elif upper >= 0.0 and d > upper:
		//
		//	err = d - upper
		//
		// if wp.abs(err) > 1e-9:
		//
		//	# compute gradients
		//	linear_c = rel_p
		//	linear_p = -linear_c
		//	r_c = x_c - world_com_c
		//	angular_p = -wp.cross(r_p, linear_c)
		//	angular_c = wp.cross(r_c, linear_c)
		//	# constraint time derivative
		//	derr = (
		//	    wp.dot(linear_p, vel_p)
		//	    + wp.dot(linear_c, vel_c)
		//	    + wp.dot(angular_p, omega_p)
		//	    + wp.dot(angular_c, omega_c)
		//	)
		//	lambda_in = 0.0
		//	compliance = linear_compliance
		//	ke = joint_target_ke[axis_start]
		//	if ke > 0.0:
		//	   compliance = 1.0 / ke
		//	 damping = joint_target_kd[axis_start]
		//	 d_lambda = compute_positional_correction(
		//	     err,
		//	     derr,
		//	     pose_p,
		//	     pose_c,
		//	     m_inv_p,
		//	     m_inv_c,
		//	     I_inv_p,
		//	     I_inv_c,
		//	     linear_p,
		//	     linear_c,
		//	     angular_p,
		//	     angular_c,
		//	     lambda_in,
		//	     compliance,
		//	     damping,
		//	     dt,
		//	 )
		//
		//	 linDelta_p += linear_p * (d_lambda * params.JointLinearRelax)
		//	 angDelta_p += angular_p * (d_lambda * angular_relaxation)
		//	 linDelta_c += linear_c * (d_lambda * params.JointLinearRelax)
		//	 angDelta_c += angular_c * (d_lambda * angular_relaxation)
	} else { // compute joint target, stiffness, damping
		var axisLimitsD, axisLimitsA math32.Vector3
		var axisTargetPosKeD, axisTargetPosKeA math32.Vector3
		var axisTargetVelKdD, axisTargetVelKdA math32.Vector3

		//	axis_target_pos_ke = wp.spatial_vector()
		//	axis_target_vel_kd = wp.spatial_vector()
		//
		// avoid a for loop here since local variables would need to be modified
		// which is not yet differentiable
		axis := JointAxis(ji)
		loTemp := axis.MulScalar(Joints.Value(int(ji), int(JointLimitLower)))
		upTemp := axis.MulScalar(Joints.Value(int(ji), int(JointLimitUpper)))
		axisLimitsD = slmath.Min3(loTemp, upTemp)
		axisLimitsA = slmath.Max3(loTemp, upTemp)
		ke := JointStiff(ji)
		kd := JointDamp(ji)
		targetPos := JointTargetPos(ji)
		targetVel := JointTargetVel(ji)
		if ke.X > 0.0 { // has position control
			UpdateJointAxisWeightedTarget(axis, targetPos.X, ke.X, &axisTargetPosKeD, &axisTargetPosKeA)
		}
		if kd.X > 0.0 { // has velocity control
			UpdateJointAxisWeightedTarget(axis, targetVel.X, kd.X, &axisTargetVelKdD, &axisTargetVelKdA)
		}
		//       if lin_axis_count > 1:
		//           axis_idx = axis_start + 1
		//           axis = joint_axis[axis_idx]
		//           lower = joint_limit_lower[axis_idx]
		//           upper = joint_limit_upper[axis_idx]
		//           axis_limits = update_joint_axis_limits(axis, lower, upper, axis_limits)
		//           ke = joint_target_ke[axis_idx]
		//           kd = joint_target_kd[axis_idx]
		//           target_pos = joint_target_pos[axis_idx]
		//           target_vel = joint_target_vel[axis_idx]
		//           if ke > 0.0:  # has position control
		//               axis_target_pos_ke = update_joint_axis_weighted_target(axis, target_pos, ke, axis_target_pos_ke)
		//           if kd > 0.0:  # has velocity control
		//               axis_target_vel_kd = update_joint_axis_weighted_target(axis, target_vel, kd, axis_target_vel_kd)
		//       if lin_axis_count > 2:
		//           axis_idx = axis_start + 2
		//           axis = joint_axis[axis_idx]
		//           lower = joint_limit_lower[axis_idx]
		//           upper = joint_limit_upper[axis_idx]
		//           axis_limits = update_joint_axis_limits(axis, lower, upper, axis_limits)
		//           ke = joint_target_ke[axis_idx]
		//           kd = joint_target_kd[axis_idx]
		//           target_pos = joint_target_pos[axis_idx]
		//           target_vel = joint_target_vel[axis_idx]
		//           if ke > 0.0:  # has position control
		//               axis_target_pos_ke = update_joint_axis_weighted_target(axis, target_pos, ke, axis_target_pos_ke)
		//           if kd > 0.0:  # has velocity control
		//               axis_target_vel_kd = update_joint_axis_weighted_target(axis, target_vel, kd, axis_target_vel_kd)

		axisStiffness := axisTargetPosKeA
		axisDamping := axisTargetVelKdA
		// for i := range 3 {
		if axisStiffness.X > 0.0 { // todo: Dim(i) access
			axisTargetPosKeD.X /= axisStiffness.X
		}
		// }
		// for i := range 3 {
		if axisDamping.X > 0.0 { // todo Dim
			axisTargetVelKdD.X /= axisDamping.X
		}
		// }
		axisLimitsLower := axisLimitsD
		axisLimitsUpper := axisLimitsA
		// todo:
		//
		//	frame_p = wp.quat_to_matrix(wp.transform_get_rotation(X_wp))
		//
		// note that xc appearing in both is correct:
		rp := xc.Sub(worldComp)
		rc := xc.Sub(slmath.MulQPPoint(posecP, posecQ, comc))

		//	for loop will be unrolled, so we can modify local variables
		//
		// for dim := range 3 {
		{
			e := relPoseP.X // rel_p[dim]

			// compute gradients
			// linearc := math32.Vec3(frame_p[0, dim], frame_p[1, dim], frame_p[2, dim]) // todo
			linearc := math32.Vec3(0, 0, 0)
			linearp := slmath.Negate3(linearc)
			angularp := slmath.Cross3(rp, linearc)
			angularc := slmath.Cross3(rc, linearc)
			// constraint time derivative
			derr := slmath.Dot3(linearp, velp) + slmath.Dot3(linearc, velc) + slmath.Dot3(angularp, omegap) + slmath.Dot3(angularc, omegac)

			err := float32(0.0)
			compliance := params.JointLinearComply
			damping := float32(0.0)

			targetVel := axisTargetVelKdD.X // [dim]
			derrRel := derr - targetVel

			// consider joint limits irrespective of axis mode
			lower := axisLimitsLower.X // [dim]
			upper := axisLimitsUpper.X // [dim]
			if e < lower {
				err = e - lower
			} else if e > upper {
				err = e - upper
			} else {
				targetPos := axisTargetPosKeD.X // [dim]
				targetPos = math32.Clamp(targetPos, lower, upper)

				if axisStiffness.X > 0.0 {
					err = e - targetPos
					compliance = 1.0 / axisStiffness.X // [dim]
					damping = axisDamping.X            // [dim]
				} else if axisDamping.X > 0.0 {
					compliance = 1.0 / axisDamping.X // [dim]
					damping = axisDamping.X          // [dim]
				}
			}
			if math32.Abs(err) > 1e-9 || math32.Abs(derrRel) > 1e-9 {
				lambdaIn := float32(0.0)
				dLambda := PositionalCorrection(err, derrRel, posepQ, posecQ, mInvp, mInvc,
					iInvp, iInvc, linearp, linearc, angularp, angularc, lambdaIn, compliance, damping, params.Dt)

				linDeltaP = linDeltaP.Add(linearp.MulScalar(dLambda * params.JointLinearRelax))
				angDeltaP = angDeltaP.Add(angularp.MulScalar(dLambda * params.JointAngularRelax))
				linDeltaC = linDeltaC.Add(linearc.MulScalar(dLambda * params.JointLinearRelax))
				angDeltaC = angDeltaC.Add(angularc.MulScalar(dLambda * params.JointAngularRelax))
			}
		}
	}
	//
	//     if type == JointType.FIXED or type == JointType.PRISMATIC or type == JointType.REVOLUTE or type == JointType.D6:
	//         # handle angular constraints
	//
	//         # local joint rotations
	//         q_p = wp.transform_get_rotation(X_wp)
	//         q_c = wp.transform_get_rotation(X_wc)
	//
	//         # make quats lie in same hemisphere
	//         if slmath.Dot3(q_p, q_c) < 0.0:
	//             q_c *= -1.0
	//
	//         rel_q = wp.quat_inverse(q_p) * q_c
	//
	//         qtwist = wp.normalize(wp.quat(rel_q[0], 0.0, 0.0, rel_q[3]))
	//         qswing = rel_q * wp.quat_inverse(qtwist)
	//
	//         # decompose to a compound rotation each axis
	//         s = wp.sqrt(rel_q[0] * rel_q[0] + rel_q[3] * rel_q[3])
	//         invs = 1.0 / s
	//         invscube = invs * invs * invs
	//
	//         # handle axis-angle joints
	//
	//         # rescale twist from quaternion space to angular
	//         err_0 = 2.0 * wp.asin(wp.clamp(qtwist[0], -1.0, 1.0))
	//         err_1 = qswing[1]
	//         err_2 = qswing[2]
	//         # analytic gradients of swing-twist decomposition
	//         grad_0 = wp.quat(invs - rel_q[0] * rel_q[0] * invscube, 0.0, 0.0, -(rel_q[3] * rel_q[0]) * invscube)
	//         grad_1 = wp.quat(
	//             -rel_q[3] * (rel_q[3] * rel_q[2] + rel_q[0] * rel_q[1]) * invscube,
	//             rel_q[3] * invs,
	//             -rel_q[0] * invs,
	//             rel_q[0] * (rel_q[3] * rel_q[2] + rel_q[0] * rel_q[1]) * invscube,
	//         )
	//         grad_2 = wp.quat(
	//             rel_q[3] * (rel_q[3] * rel_q[1] - rel_q[0] * rel_q[2]) * invscube,
	//             rel_q[0] * invs,
	//             rel_q[3] * invs,
	//             rel_q[0] * (rel_q[2] * rel_q[0] - rel_q[3] * rel_q[1]) * invscube,
	//         )
	//         grad_0 *= 2.0 / wp.abs(qtwist[3])
	//         # grad_0 *= 2.0 / wp.sqrt(1.0-qtwist[0]*qtwist[0])	# derivative of asin(x) = 1/sqrt(1-x^2)
	//
	//         # rescale swing
	//         swing_sq = qswing[3] * qswing[3]
	//         # if swing axis magnitude close to zero vector, just treat in quaternion space
	//         angularEps = 1.0e-4
	//         if swing_sq + angularEps < 1.0:
	//             d = wp.sqrt(1.0 - qswing[3] * qswing[3])
	//             theta = 2.0 * wp.acos(wp.clamp(qswing[3], -1.0, 1.0))
	//             scale = theta / d
	//
	//             err_1 *= scale
	//             err_2 *= scale
	//
	//             grad_1 *= scale
	//             grad_2 *= scale
	//
	//         errs = wp.vec3(err_0, err_1, err_2)
	//         grad_x = wp.vec3(grad_0[0], grad_1[0], grad_2[0])
	//         grad_y = wp.vec3(grad_0[1], grad_1[1], grad_2[1])
	//         grad_z = wp.vec3(grad_0[2], grad_1[2], grad_2[2])
	//         grad_w = wp.vec3(grad_0[3], grad_1[3], grad_2[3])
	//
	//         # compute joint target, stiffness, damping
	//         axis_limits = wp.spatial_vector(0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
	//
	//         axis_target_pos_ke = wp.spatial_vector()  # [weighted_target_pos, ke_weights]
	//         axis_target_vel_kd = wp.spatial_vector()  # [weighted_target_vel, kd_weights]
	//         # avoid a for loop here since local variables would need to be modified which is not yet differentiable
	//         if ang_axis_count > 0:
	//             axis_idx = axis_start + lin_axis_count
	//             axis = joint_axis[axis_idx]
	//             lo_temp = axis * joint_limit_lower[axis_idx]
	//             up_temp = axis * joint_limit_upper[axis_idx]
	//             axis_limits = wp.spatial_vector(vec_min(lo_temp, up_temp), vec_max(lo_temp, up_temp))
	//             ke = joint_target_ke[axis_idx]
	//             kd = joint_target_kd[axis_idx]
	//             target_pos = joint_target_pos[axis_idx]
	//             target_vel = joint_target_vel[axis_idx]
	//             if ke > 0.0:  # has position control
	//                 axis_target_pos_ke = update_joint_axis_weighted_target(axis, target_pos, ke, axis_target_pos_ke)
	//             if kd > 0.0:  # has velocity control
	//                 axis_target_vel_kd = update_joint_axis_weighted_target(axis, target_vel, kd, axis_target_vel_kd)

	//       if ang_axis_count > 1:
	//           axis_idx = axis_start + lin_axis_count + 1
	//           axis = joint_axis[axis_idx]
	//           lower = joint_limit_lower[axis_idx]
	//           upper = joint_limit_upper[axis_idx]
	//           axis_limits = update_joint_axis_limits(axis, lower, upper, axis_limits)
	//           ke = joint_target_ke[axis_idx]
	//           kd = joint_target_kd[axis_idx]
	//           target_pos = joint_target_pos[axis_idx]
	//           target_vel = joint_target_vel[axis_idx]
	//           if ke > 0.0:  # has position control
	//               axis_target_pos_ke = update_joint_axis_weighted_target(axis, target_pos, ke, axis_target_pos_ke)
	//           if kd > 0.0:  # has velocity control
	//               axis_target_vel_kd = update_joint_axis_weighted_target(axis, target_vel, kd, axis_target_vel_kd)
	//       if ang_axis_count > 2:
	//           axis_idx = axis_start + lin_axis_count + 2
	//           axis = joint_axis[axis_idx]
	//           lower = joint_limit_lower[axis_idx]
	//           upper = joint_limit_upper[axis_idx]
	//           axis_limits = update_joint_axis_limits(axis, lower, upper, axis_limits)
	//           ke = joint_target_ke[axis_idx]
	//           kd = joint_target_kd[axis_idx]
	//           target_pos = joint_target_pos[axis_idx]
	//           target_vel = joint_target_vel[axis_idx]
	//           if ke > 0.0:  # has position control
	//               axis_target_pos_ke = update_joint_axis_weighted_target(axis, target_pos, ke, axis_target_pos_ke)
	//           if kd > 0.0:  # has velocity control
	//               axis_target_vel_kd = update_joint_axis_weighted_target(axis, target_vel, kd, axis_target_vel_kd)
	//

	//       axis_target_pos = wp.spatial_top(axis_target_pos_ke)
	//       axis_stiffness = wp.spatial_bottom(axis_target_pos_ke)
	//       axis_target_vel = wp.spatial_top(axis_target_vel_kd)
	//       axis_damping = wp.spatial_bottom(axis_target_vel_kd)
	//       for i in range(3):
	//           if axis_stiffness[i] > 0.0:
	//               axis_target_pos[i] /= axis_stiffness[i]
	//       for i in range(3):
	//           if axis_damping[i] > 0.0:
	//               axis_target_vel[i] /= axis_damping[i]
	//       axis_limits_lower = wp.spatial_top(axis_limits)
	//       axis_limits_upper = wp.spatial_bottom(axis_limits)

	//       # if type == JointType.D6:
	//       #     wp.printf("axis_target: %f %f %f\t axis_stiffness: %f %f %f\t axis_damping: %f %f %f\t axis_limits_lower: %f %f %f \t axis_limits_upper: %f %f %f\n",
	//       #               axis_target[0], axis_target[1], axis_target[2],
	//       #               axis_stiffness[0], axis_stiffness[1], axis_stiffness[2],
	//       #               axis_damping[0], axis_damping[1], axis_damping[2],
	//       #               axis_limits_lower[0], axis_limits_lower[1], axis_limits_lower[2],
	//       #               axis_limits_upper[0], axis_limits_upper[1], axis_limits_upper[2])
	//       #     # wp.printf("wp.sqrt(1.0-qtwist[0]*qtwist[0]) = %f\n", wp.sqrt(1.0-qtwist[0]*qtwist[0]))

	//       for dim in range(3):
	//           e = errs[dim]
	//
	//           # analytic gradients of swing-twist decomposition
	//           grad = wp.quat(grad_x[dim], grad_y[dim], grad_z[dim], grad_w[dim])
	//
	//           quat_c = 0.5 * q_p * grad * wp.quat_inverse(q_c)
	//           angular_c = wp.vec3(quat_c[0], quat_c[1], quat_c[2])
	//           angular_p = -angular_c
	//           # time derivative of the constraint
	//           derr = slmath.Dot3(angular_p, omega_p) + slmath.Dot3(angular_c, omega_c)
	//
	//           err = 0.0
	//           compliance = angular_compliance
	//           damping = 0.0
	//
	//           target_vel = axis_target_vel[dim]
	//           derr_rel = derr - target_vel
	//
	//           # consider joint limits irrespective of mode
	//           lower = axis_limits_lower[dim]
	//           upper = axis_limits_upper[dim]
	//           if e < lower:
	//               err = e - lower
	//           elif e > upper:
	//               err = e - upper
	//           else:
	//               target_pos = axis_target_pos[dim]
	//               target_pos = wp.clamp(target_pos, lower, upper)
	//
	//               if axis_stiffness[dim] > 0.0:
	//                   err = e - target_pos
	//                   compliance = 1.0 / axis_stiffness[dim]
	//                   damping = axis_damping[dim]
	//               elif axis_damping[dim] > 0.0:
	//                   damping = axis_damping[dim]
	//                   compliance = 1.0 / axis_damping[dim]
	//
	//           d_lambda = (
	//               compute_angular_correction(
	//                   err, derr_rel, pose_p, pose_c, I_inv_p, I_inv_c, angular_p, angular_c, 0.0, compliance, damping, dt
	//               )
	//               * angular_relaxation
	//           )
	//
	//           # update deltas
	//           angDelta_p += angular_p * d_lambda
	//           angDelta_c += angular_c * d_lambda

	// These are unique to joint: aggregate into dynamics Next in separate step.
	SetJointPDelta(ji, linDeltaP)
	SetJointPAngDelta(ji, angDeltaP)
	SetJointCDelta(ji, linDeltaC)
	SetJointCAngDelta(ji, angDeltaC)

	// if id_p >= 0:
	//
	//	wp.atomic_add(deltas, id_p, wp.spatial_vector(linDelta_p, angDelta_p))
	//
	// if id_c >= 0:
	//
	//	wp.atomic_add(deltas, id_c, wp.spatial_vector(linDelta_c, angDelta_c))
}

func UpdateJointAxisWeightedTarget(axis math32.Vector3, targ, weight float32, axisTargets, axisWeights *math32.Vector3) {
	weightedAxis := axis.MulScalar(weight)
	*axisTargets = (*axisTargets).Add(weightedAxis.MulScalar(targ)) // weighted target (to be normalized later by sum of weights)
	*axisWeights = (*axisWeights).Add(slmath.Abs3(weightedAxis))
}

func PositionalCorrection(err, derr float32, tfaQ, tfbQ math32.Quat, mInva, mInvb float32, Iinva, Iinvb math32.Matrix3, lineara, linearb, angulara, angularb math32.Vector3, lambdaIn, compliance, damping, dt float32) float32 {
	denom := float32(0.0)
	denom += slmath.LengthSquared3(lineara) * mInva
	denom += slmath.LengthSquared3(linearb) * mInvb

	q1 := tfaQ
	q2 := tfbQ

	// # Eq. 2-3 (make sure to project into the frame of the body)
	rotAngulara := slmath.MulQuatVectorInverse(q1, angulara)
	rotAngularb := slmath.MulQuatVectorInverse(q2, angularb)

	denom += slmath.Dot3(rotAngulara, Iinva.MulVector3(rotAngulara))
	denom += slmath.Dot3(rotAngularb, Iinvb.MulVector3(rotAngularb))

	alpha := compliance
	gamma := compliance * damping

	deltaLambda := -(err + alpha*lambdaIn + gamma*derr)
	if denom+alpha > 0.0 {
		deltaLambda /= (dt+gamma)*denom + alpha/dt
	}

	return deltaLambda
}

//gosl:end
