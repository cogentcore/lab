// Code generated by "goal build"; DO NOT EDIT.
//line step_body.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

import (
	// "fmt"
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// InitDynamics copies Body initial state to dynamic state (cur and next).
func InitDynamics(i uint32) { //gosl:kernel
	params := GetParams(0)
	ii := int32(i)
	if ii >= params.DynamicsN {
		return
	}
	for cni := range 2 {
		bi := DynamicBody(ii)
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosX)), int(ii), int(cni), int(DynPosX))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosY)), int(ii), int(cni), int(DynPosY))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosZ)), int(ii), int(cni), int(DynPosZ))

		Dynamics.Set(Bodies.Value(int(bi), int(BodyQuatX)), int(ii), int(cni), int(DynQuatX))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyQuatY)), int(ii), int(cni), int(DynQuatY))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyQuatZ)), int(ii), int(cni), int(DynQuatZ))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyQuatW)), int(ii), int(cni), int(DynQuatW))

		for v := DynVelX; v < DynamicVarsN; v++ {
			Dynamics.Set(0.0, int(ii), int(cni), int(v))
		}
	}
}

// DynamicsCurToNext copies [Dynamics] state from Cur to Next.
func DynamicsCurToNext(i uint32) { //gosl:kernel
	params := GetParams(0)
	ii := int32(i)
	if ii >= params.DynamicsN {
		return
	}
	for di := DynBody; di < DynamicVarsN; di++ {
		Dynamics.Set(Dynamics.Value(int(ii), int(params.Cur), int(di)), int(ii), int(params.Next), int(di))
	}
}

// ForcesFromJoints gathers forces and torques from joints per dynamic
func ForcesFromJoints(i uint32) { //gosl:kernel
	params := GetParams(0)
	di := int32(i)
	if di >= params.DynamicsN {
		return
	}
	np := BodyJoints.Value(int(di), int(0), int(0))
	nc := BodyJoints.Value(int(di), int(1), int(0))

	tf := math32.Vec3(0, 0, 0)
	tt := math32.Vec3(0, 0, 0)
	for i := int32(1); i <= np; i++ {
		ji := BodyJoints.Value(int(di), int(0), int(i))
		f := JointPForce(ji)
		tf = tf.Add(f)
		t := JointPTorque(ji)
		tt = tt.Add(t)
	}
	for i := int32(1); i <= nc; i++ {
		ji := BodyJoints.Value(int(di), int(1), int(i))
		f := JointCForce(ji)
		tf = tf.Add(f)
		t := JointCTorque(ji)
		tt = tt.Add(t)
	}
	SetDynamicForce(di, params.Next, tf)
	SetDynamicTorque(di, params.Next, tt)
}

// newton: solvers/solver.py: integrate_rigid_body

// StepIntegrateBodies applies forces to update pos and deltas
func StepIntegrateBodies(i uint32) { //gosl:kernel
	params := GetParams(0)
	di := int32(i)
	if di >= params.DynamicsN {
		return
	}
	bi := DynamicBody(di)

	invMass := Bodies.Value(int(bi), int(BodyInvMass))
	inertia := BodyInertia(bi)
	invInertia := BodyInvInertia(bi)
	grav := params.Gravity.V()

	com := BodyCom(bi)

	// current pos
	r0 := DynamicPos(di, params.Cur)
	q0 := DynamicQuat(di, params.Cur)

	// current deltas
	v0 := DynamicDelta(di, params.Cur)
	w0 := DynamicAngDelta(di, params.Cur)

	// new forces integrated from joints
	f0 := DynamicForce(di, params.Next)
	t0 := DynamicTorque(di, params.Next)

	pcom := slmath.MulQuatVector(q0, com).Add(r0)

	// linear part
	v1 := v0.Add(f0.MulScalar(invMass).Add(grav.MulScalar(OneIfNonzero(invMass))).MulScalar(params.Dt))
	p1 := pcom.Add(v1.MulScalar(params.Dt))

	// angular part (compute in body frame)
	wb := slmath.MulQuatVectorInverse(q0, w0)
	tb := slmath.MulQuatVectorInverse(q0, t0).Sub(slmath.Cross3(wb, inertia.MulVector3(wb))) // coriolis forces

	w1 := slmath.MulQuatVector(q0, wb.Add(invInertia.MulVector3(tb).MulScalar(params.Dt)))
	q1 := slmath.QuatAdd(q0, slmath.MulQuats(math32.NewQuat(w1.X, w1.Y, w1.Z, 0), q0).MulScalar(0.5*params.Dt))
	q1 = slmath.QuatNormalize(q1)

	// angular damping
	w1 = w1.MulScalar(1.0 - params.AngularDamping*params.Dt)

	p1a := p1.Sub(slmath.MulQuatVector(q1, com)) // pos corrected to nominal center.

	// fmt.Println(params.Next, "integrate:", v0, v1)

	SetDynamicPos(di, params.Next, p1a)
	SetDynamicQuat(di, params.Next, q1)
	SetDynamicDelta(di, params.Next, v1)
	SetDynamicAngDelta(di, params.Next, w1)
}

// StepBodyJointDeltas gathers raw deltas, angDeltas from joints per dynamic
// and computes updated deltas integrated via StepBodyDeltas.
func StepBodyJointDeltas(i uint32) { //gosl:kernel
	params := GetParams(0)
	di := int32(i)
	if di >= params.DynamicsN {
		return
	}
	bi := DynamicBody(di)
	invMass := Bodies.Value(int(bi), int(BodyInvMass))
	if invMass == 0 {
		return // no updates
	}

	np := BodyJoints.Value(int(di), int(0), int(0))
	nc := BodyJoints.Value(int(di), int(1), int(0))

	linDel := math32.Vec3(0, 0, 0)
	angDel := math32.Vec3(0, 0, 0)
	for i := int32(1); i <= np; i++ {
		ji := BodyJoints.Value(int(di), int(0), int(i))
		d := JointPDelta(ji)
		linDel = linDel.Add(d)
		a := JointPAngDelta(ji)
		angDel = angDel.Add(a)
	}
	for i := int32(1); i <= nc; i++ {
		ji := BodyJoints.Value(int(di), int(1), int(i))
		d := JointCDelta(ji)
		linDel = linDel.Add(d)
		a := JointCAngDelta(ji)
		angDel = angDel.Add(a)
	}
	StepBodyDeltas(di, bi, false, 0, linDel, angDel)
}

// newton: solvers/xpbd/kernels.py: apply_body_deltas

// StepBodyDeltas updates Next position with deltas from joints
// or contacts (if contacts true).
func StepBodyDeltas(di, bi int32, contacts bool, cWt float32, linDel, angDel math32.Vector3) {
	params := GetParams(0)

	invMass := Bodies.Value(int(bi), int(BodyInvMass))
	inertia := BodyInertia(bi)
	invInertia := BodyInvInertia(bi)

	// starting pos (from force integration)
	r0 := DynamicPos(di, params.Next)
	q0 := DynamicQuat(di, params.Next)

	// starting deltas
	v0 := DynamicDelta(di, params.Next)
	w0 := DynamicAngDelta(di, params.Next)

	weight := float32(1.0)
	if contacts && params.ContactWeighting.IsTrue() {
		if cWt > 0 {
			weight = 1.0 / cWt
		}
	}

	// weighted
	dp := linDel.MulScalar(invMass * weight)
	dq := angDel.MulScalar(weight)

	wb := slmath.MulQuatVectorInverse(q0, w0)
	dwb := invInertia.MulVector3(slmath.MulQuatVectorInverse(q0, dq))
	// coriolis forces delta from dwb = (wb + dwb) I (wb + dwb) - wb I wb
	tb := slmath.Cross3(dwb, inertia.MulVector3(wb.Add(dwb))).Add(slmath.Cross3(wb, inertia.MulVector3(dwb)))
	dw1 := slmath.MulQuatVector(q0, dwb.Sub(invInertia.MulVector3(tb).MulScalar(params.Dt)))

	// update orientation
	q1 := q0.Add(slmath.MulQuats(math32.NewQuat(dw1.X, dw1.Y, dw1.Z, 0), q0).MulScalar(0.5 * params.Dt))
	// q1 := q0 + 0.5 * wp.quat(dw1 * dt, 0.0) * q0
	q1 = slmath.QuatNormalize(q1)

	// update position
	com := BodyCom(bi)
	pcom := slmath.MulQuatVector(q0, com).Add(r0)

	p1 := pcom.Add(dp.MulScalar(params.Dt))
	p1 = p1.Sub(slmath.MulQuatVector(q1, com))

	// update linear and angular velocity
	v1 := v0.Add(dp)
	w1 := w0.Add(dw1)

	// this improves gradient stability
	if slmath.Length3(v1) < 1e-4 {
		v1 = math32.Vec3(0, 0, 0)
	}
	if slmath.Length3(w1) < 1e-4 {
		w1 = math32.Vec3(0, 0, 0)
	}

	// fmt.Println(params.Next, "delta:", v0, v1)

	SetDynamicPos(di, params.Next, p1)
	SetDynamicQuat(di, params.Next, q1)
	SetDynamicDelta(di, params.Next, v1)
	SetDynamicAngDelta(di, params.Next, w1)
}

func VelocityAtPoint(lin, ang, r math32.Vector3) math32.Vector3 {
	return lin.Add(slmath.Cross3(ang, r))
}

//gosl:end
