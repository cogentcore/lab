// Code generated by "goal build"; DO NOT EDIT.
//line step_body.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// InitDynamics copies Body initial state to dynamic state (cur and next).
func InitDynamics(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ii := int32(i)
	if ii >= pars.DynamicsN {
		return
	}
	for cni := range 2 {
		bi := DynamicIndex(ii, int32(cni))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosX)), int(ii), int(cni), int(DynPosX))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosY)), int(ii), int(cni), int(DynPosY))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyPosZ)), int(ii), int(cni), int(DynPosZ))

		Dynamics.Set(Bodies.Value(int(bi), int(BodyRotX)), int(ii), int(cni), int(DynRotX))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyRotY)), int(ii), int(cni), int(DynRotY))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyRotZ)), int(ii), int(cni), int(DynRotZ))
		Dynamics.Set(Bodies.Value(int(bi), int(BodyRotW)), int(ii), int(cni), int(DynRotW))

		for v := DynVelX; v < DynamicVarsN; v++ {
			Dynamics.Set(0.0, int(ii), int(cni), int(v))
		}
	}
}

// DynamicsCurToNext copies [Dynamics] state from Cur to Next.
func DynamicsCurToNext(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ii := int32(i)
	if ii >= pars.DynamicsN {
		return
	}
	for di := DynIndex; di < DynamicVarsN; di++ {
		Dynamics.Set(Dynamics.Value(int(ii), int(pars.Cur), int(di)), int(ii), int(pars.Next), int(di))
	}
}

// todo: aggregate forces

// StepIntegrateBodies
func StepIntegrateBodies(i uint32) { //gosl:kernel
	pars := GetParams(0)
	di := int32(i)
	if di >= pars.DynamicsN {
		return
	}
	bi := DynamicIndex(di, pars.Cur)

	invMass := Bodies.Value(int(bi), int(BodyInvMass))
	inertia := BodyInertia(bi)
	invInertia := BodyInvInertia(bi)

	com := BodyCom(bi)

	// unpack transform
	x0 := DynamicPos(di, pars.Cur)
	r0 := DynamicRot(di, pars.Cur)

	// unpack spatial twist
	v0 := DynamicDelta(di, pars.Cur)
	w0 := DynamicAngDelta(di, pars.Cur)

	// unpack spatial wrench
	f0 := DynamicForce(di, pars.Next)
	t0 := DynamicTorque(di, pars.Next)

	xcom := slmath.MulQuatVector(r0, com).Add(x0)

	// linear part
	v1 := v0.Add(f0.MulScalar(invMass).Add(pars.Gravity.V().MulScalar(OneIfNonzero(invMass))).MulScalar(pars.Dt))
	x1 := xcom.Add(v1.MulScalar(pars.Dt))

	// angular part (compute in body frame)
	wb := slmath.MulQuatVectorInverse(r0, w0)
	tb := slmath.MulQuatVectorInverse(r0, t0).Sub(slmath.Cross3(wb, inertia.MulVector3(wb))) // coriolis forces

	w1 := slmath.MulQuatVector(r0, wb.Add(invInertia.MulVector3(tb).MulScalar(pars.Dt)))
	r1 := slmath.MulQuats(math32.NewQuat(w1.X, w1.Y, w1.Z, 0), r0).MulScalar(0.5 * pars.Dt)
	r1 = slmath.QuatNormalize(r1)

	// angular damping
	w1 = w1.MulScalar(1.0 - pars.AngularDamping*pars.Dt)

	x1a := x1.Sub(slmath.MulQuatVector(r1, com)) // pos corrected to nominal center.

	SetDynamicPos(di, pars.Next, x1a)
	SetDynamicRot(di, pars.Next, r1)

	SetDynamicDelta(di, pars.Next, v1)
	SetDynamicAngDelta(di, pars.Next, w1)
}

//gosl:end
