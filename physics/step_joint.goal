// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

import (
	// "fmt"
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

// notation convention:
// spatial transform: R = position, Q = quat rotation
// P = parent, C = child
// x = transform, w = world
// d = moment arm

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// newton: solvers/xpbd/kernels.py: apply_joint_forces

// StepJointForces computes joint forces.
func StepJointForces(i uint32) { //gosl:kernel
	params := GetParams(0)
	ji := int32(i)
	if ji >= params.JointsN {
		return
	}
	zv := math32.Vec3(0, 0, 0)
	SetJointPForce(ji, zv)
	SetJointCForce(ji, zv)
	SetJointPTorque(ji, zv)
	SetJointCTorque(ji, zv)

	jt := GetJointType(ji)
	if !GetJointEnabled(ji) {
		return
	}

	jPi := JointParentIndex(ji)
	jPbi := int32(-1)
	if jPi >= 0 {
		jPbi = DynamicBody(jPi)
	}
	jCi := JointChildIndex(ji)
	jCbi := DynamicBody(jCi)

	jLinearN := GetJointLinearDoFN(ji)
	jAngularN := GetJointAngularDoFN(ji)

	jPR := JointPPos(ji)
	jPQ := JointPQuat(ji)

	// parent world transform
	xwPR := jPR
	xwPQ := jPQ
	posePR := jPR
	posePQ := jPQ
	comP := math32.Vec3(0, 0, 0)

	if jPi >= 0 { // can be fixed
		posePR = DynamicPos(jPi, params.Cur)
		posePQ = DynamicQuat(jPi, params.Cur)
		slmath.MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ)
		comP = BodyCom(jPbi)
	}
	dP := xwPR.Sub(slmath.MulSpatialPoint(posePR, posePQ, comP)) // parent moment arm

	// child world transform
	poseCR := DynamicPos(jCi, params.Cur)
	poseCQ := DynamicQuat(jCi, params.Cur)
	// note: NOT doing this: slmath.MulSpatialTransforms(poseCR, poseCQ, jCR, jCQ, &xwCR, &xwCQ)
	// https://github.com/newton-physics/newton/issues/1261
	comC := BodyCom(jCbi)
	dC := poseCR.Sub(slmath.MulSpatialPoint(poseCR, poseCQ, comC)) // child moment arm

	var f, t math32.Vector3
	switch jt {
	case Free, Distance:
		f = math32.Vec3(JointControl(ji, 0, JointControlForce), JointControl(ji, 1, JointControlForce), JointControl(ji, 2, JointControlForce))
		t = math32.Vec3(JointControl(ji, 3, JointControlForce), JointControl(ji, 4, JointControlForce), JointControl(ji, 5, JointControlForce))
	case Ball:
		// note: assuming the axes are x, y, z
		t = math32.Vec3(JointControl(ji, 0, JointControlForce), JointControl(ji, 1, JointControlForce), JointControl(ji, 2, JointControlForce))
	case Revolute:
		axis := JointAxis(ji, 0)
		t = slmath.MulQuatVector(xwPQ, axis).MulScalar(JointControl(ji, 0, JointControlForce))
	case Prismatic:
		axis := JointAxis(ji, 0)
		f = slmath.MulQuatVector(xwPQ, axis).MulScalar(JointControl(ji, 0, JointControlForce))
	default:
		for dof := range jLinearN {
			axis := JointAxis(ji, int32(dof))
			f = f.Add(slmath.MulQuatVector(xwPQ, axis).MulScalar(JointControl(ji, int32(dof), JointControlForce)))
		}
		for dof := range jAngularN {
			di := int32(jLinearN) + int32(dof)
			axis := JointAxis(ji, di)
			t = t.Add(slmath.MulQuatVector(xwPQ, axis).MulScalar(JointControl(ji, di, JointControlForce)))
		}
	}
	// These are unique to joint: aggregate into dynamics Next in [ForcesFromJoints]
	SetJointPForce(ji, slmath.Negate3(f))
	SetJointCForce(ji, f)
	SetJointPTorque(ji, slmath.Negate3(t.Add(slmath.Cross3(dP, f))))
	SetJointCTorque(ji, t.Add(slmath.Cross3(dC, f)))
}

// newton: solvers/xpbd/kernels.py: solve_body_joints

// StepSolveJoints applies target positions to joints.
// This is per Object because it needs to solve joints in parent -> child order.
func StepSolveJoints(i uint32) { //gosl:kernel
	params := GetParams(0)
	oi := int32(i)
	if oi >= params.ObjectsN {
		return
	}
	n := Objects[oi, 0]
	for i :=int32(1); i < n+1; i++ {
		ji := Objects[oi, i]
		jt := GetJointType(ji)
		if jt == Free || !GetJointEnabled(ji) {
			continue
		}
		StepSolveJoint(ji)
	}
}

// StepSolveJoint applies target positions to linear DoFs.
// Position is updated prior to computing angulars.
func StepSolveJoint(ji int32) {
	params := GetParams(0)

	jt := GetJointType(ji)
	jPi := JointParentIndex(ji)
	jPbi := int32(-1)
	parentFixed := true
	if jPi >= 0 {
		jPbi = DynamicBody(jPi)
		parentFixed = GetJointParentFixed(ji)
	}
	jCi := JointChildIndex(ji)
	jCbi := DynamicBody(jCi)

	jLinearN := GetJointLinearDoFN(ji)
	// jAngularN := GetJointAngularDoFN(ji)

	jPR := JointPPos(ji)
	jPQ := JointPQuat(ji)

	xwPR := jPR // world xform, parent, pos
	xwPQ := jPQ // quat
	mInvP := float32(0.0)
	iInvP := math32.Mat3(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)
	posePR := jPR
	posePQ := jPQ

	var comP, vP, wP math32.Vector3

	// parent transform and moment arm
	if jPi >= 0 {
		posePR = DynamicPos(jPi, params.Next) // now using next
		posePQ = DynamicQuat(jPi, params.Next)
		slmath.MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ)
		comP = BodyCom(jPbi)
		mInvP = Bodies[jPbi, BodyInvMass]
		iInvP = BodyInvInertia(jPbi)
		vP = DynamicDelta(jPi, params.Next)
		wP = DynamicAngDelta(jPi, params.Next)
		if mInvP == 0 {
			parentFixed = true
		}
	}

	// child transform and moment arm
	poseCR := DynamicPos(jCi, params.Next)
	poseCQ := DynamicQuat(jCi, params.Next)
	jCR := JointCPos(ji)
	jCQ := JointCQuat(ji)
	xwCR := jCR
	xwCQ := jCQ
	slmath.MulSpatialTransforms(poseCR, poseCQ, jCR, jCQ, &xwCR, &xwCQ)
	comC := BodyCom(jCbi)
	mInvC := Bodies[jCbi, BodyInvMass]
	iInvC := BodyInvInertia(jCbi)
	vC := DynamicDelta(jCi, params.Next)
	wC := DynamicAngDelta(jCi, params.Next)

	if mInvP == 0.0 && mInvC == 0.0 { // connection between two immovable bodies
		return
	}

	// accumulate constraint deltas
	var linDeltaP, angDeltaP, linDeltaC, angDeltaC math32.Vector3

	relPoseR := xwPR
	relPoseQ := xwPQ
	slmath.SpatialTransformInverse(xwPR, xwPQ, &relPoseR, &relPoseQ)
	slmath.MulSpatialTransforms(relPoseR, relPoseQ, xwCR, xwCQ, &relPoseR, &relPoseQ)

	wComP := slmath.MulSpatialPoint(posePR, posePQ, comP)
	wComC := slmath.MulSpatialPoint(poseCR, poseCQ, comC)

	lambdaPrev := JointLinLambda(ji)
	lambdaNext := math32.Vec3(0,0,0)
	
	// handle positional constraints
	if jt == Distance {
		dP := xwPR.Sub(wComP)
		dC := xwCR.Sub(wComC)
		lo := JointDoF(ji, 0, JointLimitLower) // only first one has constraint
		up := JointDoF(ji, 0, JointLimitUpper)
		if lo < 0 && up < 0 { // not limited
			return
		}
		d := slmath.Length3(relPoseR)
		err := float32(0.0)
		if lo >= 0.0 && d < lo {
			err = d - lo
			// use a more descriptive direction vector for the constraint
			// in case the joint parent and child anchors are very close
			relPoseR = slmath.Normal3(wComC.Sub(wComP)).MulScalar(err)
		} else if up >= 0.0 && d > up {
			err = d - up
		}
		if math32.Abs(err) > 1e-9 {
			//  compute gradients
			linearC := relPoseR
			linearP := slmath.Negate3(linearC)
			dC = xwCR.Sub(wComC)
			angularP := slmath.Negate3(slmath.Cross3(dP, linearC))
			angularC := slmath.Cross3(dC, linearC)
			// constraint time derivative
			derr := slmath.Dot3(linearP, vP) + slmath.Dot3(linearC, vC) + slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)
			lambdaIn := float32(0.0) // note: multiple iter is supposed to increment these
			compliance := params.JointLinearComply
			ke := JointControl(ji, 0, JointTargetStiff)
			kd := JointControl(ji, 0, JointTargetDamp)
			if ke > 0.0 {
				compliance = 1.0 / ke
			}
			dLambda := PositionalCorrection(err, derr, posePQ, poseCQ, mInvP, mInvC,
				iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, kd, params.Dt)
			linDeltaP = linDeltaP.Add(linearP.MulScalar(dLambda * params.JointLinearRelax))
			angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda * params.JointAngularRelax))
			linDeltaC = linDeltaC.Add(linearC.MulScalar(dLambda * params.JointLinearRelax))
			angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda * params.JointAngularRelax))
		}
	} else {
		// all joints impose linear constraints!
		var axisLimitsD, axisLimitsA math32.Vector3
		var axisTargetPosKeD, axisTargetPosKeA math32.Vector3
		var axisTargetVelKdD, axisTargetVelKdA math32.Vector3

		for dof := range jLinearN {
			axis := JointAxis(ji, dof)
			JointAxisLimitsUpdate(dof, axis, JointDoF(ji, dof, JointLimitLower), JointDoF(ji, dof, JointLimitUpper), &axisLimitsD, &axisLimitsA)
			ke := JointControl(ji, dof, JointTargetStiff)
			kd := JointControl(ji, dof, JointTargetDamp)
			targetPos := JointControl(ji, dof, JointTargetPosCur)
			targetVel := JointControl(ji, dof, JointTargetVel)
			if ke > 0.0 { // has position control
				JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA)
			}
			if kd > 0.0 { // has velocity control
				JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA)
			}
		}

		axisStiffness := axisTargetPosKeA
		axisDamping := axisTargetVelKdA
		axisTargetPosKeD = slmath.DivSafe3(axisTargetPosKeD, axisStiffness)
		axisTargetVelKdD = slmath.DivSafe3(axisTargetVelKdD, axisDamping)
		axisLimitsLower := axisLimitsD
		axisLimitsUpper := axisLimitsA
		// note that xwCR appearing in both is correct:
		dP := xwCR.Sub(wComP)
		dC := xwCR.Sub(slmath.MulSpatialPoint(poseCR, poseCQ, comC))

		for dim := range int32(3) {
			e := slmath.Dim3(relPoseR, dim)
			// compute gradients
			// matrix indexing is [row, col] here: dim = col
			// quat_to_matrix cols are q rotations of axis vectors
			dima := slmath.SetDim3(math32.Vec3(0, 0, 0), dim, 1) // axis for dim
			linearC := slmath.MulQuatVector(xwPQ, dima)
			linearP := slmath.Negate3(linearC)
			angularP := slmath.Negate3(slmath.Cross3(dP, linearC))
			angularC := slmath.Cross3(dC, linearC)
			// constraint time derivative
			derr := slmath.Dot3(linearP, vP) + slmath.Dot3(linearC, vC) + slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)

			err := float32(0.0)
			compliance := params.JointLinearComply
			damping := float32(0.0)

			targetVel := slmath.Dim3(axisTargetVelKdD, dim)
			derrRel := derr - targetVel

			//  consider joint limits irrespective of axis mode
			lower := slmath.Dim3(axisLimitsLower, dim)
			upper := slmath.Dim3(axisLimitsUpper, dim)
			if e < lower {
				err = e - lower
			} else if e > upper {
				err = e - upper
			} else {
				targetPos := slmath.Dim3(axisTargetPosKeD, dim)
				targetPos = math32.Clamp(targetPos, lower, upper)

				ke := slmath.Dim3(axisStiffness, dim)
				kd := slmath.Dim3(axisDamping, dim)
				if ke > 0.0 {
					err = e - targetPos
					compliance = 1.0 / ke
					damping = slmath.Dim3(axisDamping, dim)
				} else if kd > 0.0 {
					compliance = 1.0 / kd
					damping = kd
				}
			}
			if math32.Abs(err) > 1e-9 || math32.Abs(derrRel) > 1e-9 {
				lambdaIn := slmath.Dim3(lambdaPrev, dim)
				// lambdaIn := float32(0)
				dLambda := PositionalCorrection(err, derrRel, posePQ, poseCQ, mInvP, mInvC,
					iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, damping, params.Dt)

				linDeltaP = linDeltaP.Add(linearP.MulScalar(dLambda * params.JointLinearRelax))
				linDeltaC = linDeltaC.Add(linearC.MulScalar(dLambda * params.JointLinearRelax))
				angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda * params.JointAngularRelax))
				angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda * params.JointAngularRelax))
				
				lambdaNext = slmath.SetDim3(lambdaNext, dim, dLambda)
				// if angularP.Length() > 0.001 && dLambda > 0.001 {
				// 	fmt.Println("lin:", angularP.Length(), dLambda, angularP, angDeltaP, dP, linearC, angularC.Length())
				// }
			}
		}
	}
	SetJointLinLambda(ji, lambdaNext)

	//////// Angular positions
	
	jAngularN := GetJointAngularDoFN(ji)

	qP := xwPQ
	qC := xwCQ
	// make quats lie in same hemisphere
	if slmath.QuatDot(qP, qC) < 0 {
		qC = slmath.QuatMulScalar(qC, -1.0)
	}
	relQ := slmath.MulQuats(slmath.QuatInverse(qP), qC)
	qtwist := slmath.QuatNormalize(math32.NewQuat(relQ.X, 0.0, 0.0, relQ.W))
	qswing := slmath.MulQuats(relQ, slmath.QuatInverse(qtwist))

	// decompose to a compound rotation each axis
	s := math32.Sqrt(relQ.X*relQ.X + relQ.W*relQ.W)
	if s == 0 {
		// fmt.Println("s = 0", relQ, qP, qC)
		s = 1
	}
	invs := 1.0 / s
	invscube := invs * invs * invs

	// handle axis-angle joints
	// rescale twist from quaternion space to angular
	err0 := 2.0 * math32.Asin(math32.Clamp(qtwist.X, -1.0, 1.0))
	err1 := qswing.Y
	err2 := qswing.Z
	//  analytic gradients of swing-twist decomposition
	grad0 := math32.NewQuat(invs-relQ.X*relQ.X*invscube, 0.0, 0.0, -(relQ.W*relQ.X)*invscube)
	grad1 := math32.NewQuat(
		-relQ.W*(relQ.W*relQ.Z+relQ.X*relQ.Y)*invscube,
		relQ.W*invs,
		-relQ.X*invs,
		relQ.X*(relQ.W*relQ.Z+relQ.X*relQ.Y)*invscube)
	grad2 := math32.NewQuat(
		relQ.W*(relQ.W*relQ.Y-relQ.X*relQ.Z)*invscube,
		relQ.X*invs,
		relQ.W*invs,
		relQ.X*(relQ.Z*relQ.X-relQ.W*relQ.Y)*invscube)
	grad0 = slmath.QuatMulScalar(grad0, 2.0/math32.Abs(qtwist.W))
	//         # grad0 *= 2.0 / wp.sqrt(1.0-qtwist[0]*qtwist[0])	# derivative of asin(x) = 1/sqrt(1-x^2)

	// rescale swing
	swing_sq := qswing.W * qswing.W
	//  if swing axis magnitude close to zero vector, just treat in quaternion space
	angularEps := float32(1.0e-4)
	if swing_sq+angularEps < 1.0 {
		d := math32.Sqrt(1.0 - qswing.W*qswing.W)
		theta := 2.0 * math32.Acos(math32.Clamp(qswing.W, -1.0, 1.0))
		scale := theta / d
		err1 *= scale
		err2 *= scale
		grad1 = slmath.QuatMulScalar(grad1, scale)
		grad2 = slmath.QuatMulScalar(grad2, scale)
	}
	errs := math32.Vec3(err0, err1, err2)
	gradX := math32.Vec3(grad0.X, grad1.X, grad2.X)
	gradY := math32.Vec3(grad0.Y, grad1.Y, grad2.Y)
	gradZ := math32.Vec3(grad0.Z, grad1.Z, grad2.Z)
	gradW := math32.Vec3(grad0.W, grad1.W, grad2.W)

	// compute joint target, stiffness, damping
	var axisLimitsD, axisLimitsA math32.Vector3
	var axisTargetPosKeD, axisTargetPosKeA math32.Vector3
	var axisTargetVelKdD, axisTargetVelKdA math32.Vector3
	lambdaPrev = JointAngLambda(ji)
	lambdaNext = math32.Vec3(0,0,0)

	for dof := range jAngularN {
		di := dof + jLinearN
		axis := JointAxis(ji, di)
		JointAxisLimitsUpdate(dof, axis, JointDoF(ji, di, JointLimitLower), JointDoF(ji, di, JointLimitUpper), &axisLimitsD, &axisLimitsA)
		ke := JointControl(ji, di, JointTargetStiff)
		kd := JointControl(ji, di, JointTargetDamp)
		targetPos := JointControl(ji, di, JointTargetPosCur)
		targetVel := JointControl(ji, di, JointTargetVel)
		if ke > 0.0 { // has position control
			JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA)
		}
		if kd > 0.0 { // has velocity control
			JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA)
		}
	}

	axisStiffness := axisTargetPosKeA
	axisDamping := axisTargetVelKdA
	axisTargetPosKeD = slmath.DivSafe3(axisTargetPosKeD, axisStiffness)
	axisTargetVelKdD = slmath.DivSafe3(axisTargetVelKdD, axisDamping)
	axisLimitsLower := axisLimitsD
	axisLimitsUpper := axisLimitsA

	for dim := range int32(3) {
		e := slmath.Dim3(errs, dim)

		// analytic gradients of swing-twist decomposition
		grad := math32.NewQuat(slmath.Dim3(gradX, dim), slmath.Dim3(gradY, dim), slmath.Dim3(gradZ, dim), slmath.Dim3(gradW, dim))
		// todo: verify -- does the 0.5 go inside??
		// quat_c = 0.5 * q_p * grad * wp.quat_inverse(q_c)
		quatC := slmath.MulQuats(slmath.MulQuats(slmath.QuatMulScalar(qP, 0.5), grad), slmath.QuatInverse(qC))

		angularC := math32.Vec3(quatC.X, quatC.Y, quatC.Z)
		angularP := slmath.Negate3(angularC)
		// constraint time derivative
		derr := slmath.Dot3(angularP, wP) + slmath.Dot3(angularC, wC)

		err := float32(0.0)
		compliance := params.JointLinearComply
		damping := float32(0.0)

		targetVel := slmath.Dim3(axisTargetVelKdD, dim)
		angularClen := slmath.Length3(angularC)
		derrRel := derr - targetVel*angularClen

		//  consider joint limits irrespective of axis mode
		lower := slmath.Dim3(axisLimitsLower, dim)
		upper := slmath.Dim3(axisLimitsUpper, dim)
		if e < lower {
			err = e - lower
		} else if e > upper {
			err = e - upper
		} else {
			targetPos := slmath.Dim3(axisTargetPosKeD, dim)
			targetPos = math32.Clamp(targetPos, lower, upper)

			ke := slmath.Dim3(axisStiffness, dim)
			kd := slmath.Dim3(axisDamping, dim)
			if ke > 0.0 {
				err = slmath.MinAngleDiff(e, targetPos)
				compliance = 1.0 / ke
				damping = slmath.Dim3(axisDamping, dim)
			} else if kd > 0.0 {
				compliance = 1.0 / kd
				damping = kd
			}
			// if ji == 0 && dim == 1 {
			// 	fmt.Println(targetPos, e, err)
			// }
		}
		lambdaIn := slmath.Dim3(lambdaPrev, dim)
		dLambda := AngularCorrection(err, derrRel, posePQ, poseCQ, iInvP, iInvC, angularP, angularC, lambdaIn, compliance, damping, params.Dt)

		// note: no relaxation factors here:
		angDeltaP = angDeltaP.Add(angularP.MulScalar(dLambda))
		angDeltaC = angDeltaC.Add(angularC.MulScalar(dLambda))
		lambdaNext = slmath.SetDim3(lambdaNext, dim, dLambda)
	}
	SetJointAngLambda(ji, lambdaNext)

	if !parentFixed {
		StepBodyDeltas(jPi, jPbi, false, 0, linDeltaP, angDeltaP)
	}
	if mInvC > 0 {
		StepBodyDeltas(jCi, jCbi, false, 0, linDeltaC, angDeltaC)
	}
}

func JointAxisTarget(axis math32.Vector3, targ, weight float32, axisTargets, axisWeights *math32.Vector3) {
	weightedAxis := axis.MulScalar(weight)
	*axisTargets = (*axisTargets).Add(weightedAxis.MulScalar(targ)) // weighted target (to be normalized later by sum of weights)
	*axisWeights = (*axisWeights).Add(slmath.Abs3(weightedAxis))
}

func PositionalCorrection(err, derr float32, tfaQ, tfbQ math32.Quat, mInvA, mInvB float32, iInvA, iInvB math32.Matrix3, linA, linB, angA, angB math32.Vector3, lambdaIn, compliance, damping, dt float32) float32 {
	denom := float32(0.0)
	denom += slmath.LengthSquared3(linA) * mInvA
	denom += slmath.LengthSquared3(linB) * mInvB

	// # Eq. 2-3 (make sure to project into the frame of the body)
	rotAngA := slmath.MulQuatVectorInverse(tfaQ, angA)
	rotAngB := slmath.MulQuatVectorInverse(tfbQ, angB)

	denom += slmath.Dot3(rotAngA, iInvA.MulVector3(rotAngA))
	denom += slmath.Dot3(rotAngB, iInvB.MulVector3(rotAngB))

	alpha := compliance
	gamma := compliance * damping

	lambda := -(err + alpha*lambdaIn + gamma*derr)
	if denom+alpha > 0.0 {
		lambda /= (dt+gamma)*denom + alpha/dt
	}

	return lambda
}

func AngularCorrection(err, derr float32, tfaQ, tfbQ math32.Quat, iInvA, iInvB math32.Matrix3, angA, angB math32.Vector3, lambdaIn, compliance, damping, dt float32) float32 {
	// # Eq. 2-3 (make sure to project into the frame of the body)
	rotAngA := slmath.MulQuatVectorInverse(tfaQ, angA)
	rotAngB := slmath.MulQuatVectorInverse(tfbQ, angB)

	denom := float32(0.0)
	denom += slmath.Dot3(rotAngA, iInvA.MulVector3(rotAngA))
	denom += slmath.Dot3(rotAngB, iInvB.MulVector3(rotAngB))

	alpha := compliance
	gamma := compliance * damping

	deltaLambda := -(err + alpha*lambdaIn + gamma*derr)
	if denom+alpha > 0.0 {
		deltaLambda /= (dt+gamma)*denom + alpha/dt
	}
	return deltaLambda
}

// update the 3D linear/angular limits (spatial_vector [lower, upper])
// given the axis vector and limits
func JointAxisLimitsUpdate(dof int32, axis math32.Vector3, lower, upper float32, axisLimitsD, axisLimitsA *math32.Vector3) {
	loTemp := axis.MulScalar(lower)
	upTemp := axis.MulScalar(upper)
	lo := slmath.Min3(loTemp, upTemp)
	up := slmath.Max3(loTemp, upTemp)
	if dof == 0 {
		*axisLimitsD = lo
		*axisLimitsA = up
	} else {
		*axisLimitsD = slmath.Min3(*axisLimitsD, lo)
		*axisLimitsA = slmath.Max3(*axisLimitsA, up)
	}
}

//gosl:end
