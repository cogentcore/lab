// Code generated by "goal build"; DO NOT EDIT.
//line world.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/tensor"
)

//go:generate core generate -add-types -gosl

// World contains and manages all of the physics elements.
type World struct {
	// GPU determines whether to use GPU (else CPU).
	GPU bool

	// Params are global parameters.
	Params []PhysParams

	// CurrentWorld is the [BodyWorld] value to use when creating new bodies.
	// Set to -1 to create global elements that interact with everything,
	// while 0 and positive numbers only interact amongst themselves.
	CurrentWorld int

	// WorldReplicasStart is the starting body index for replicated world bodies,
	// which is needed for viewers to efficiently select a specific world to view.
	// This is the start of the World=0 first instance.
	WorldReplicasStart int32

	// WorldReplicasN is the number of body elements within each set of
	// replicated world bodies, which is needed for viewers to efficiently select
	// a specific world to view.
	WorldReplicasN int32

	// CurrentObject is the [BodyObject] value to use when creating new bodies.
	// Generally just increment when starting a new object. When using world replicas,
	// the object indexes are copied, so objects are indexed by world and object id.
	CurrentObject int

	// Bodies are the rigid body elements (dynamic and static),
	// specifying the constant, non-dynamic properties,
	// which is initial state for dynamics.
	// [body][BodyVarsN]
	Bodies *tensor.Float32 `display:"no-inline"`

	// Joints is a list of permanent joints connecting bodies,
	// which do not change (no dynamic variables).
	// [joint][JointVarsN]
	Joints *tensor.Float32 `display:"no-inline"`

	// JointDoFs is a list of joint DoF parameters, allocated per joint.
	// [dof][JointDoFVars]
	JointDoFs *tensor.Float32 `display:"no-inline"`

	// BodyJoints is a list of joint indexes for each dynamic body, for aggregating.
	// [dyn body][parent, child][Params.BodyJointsMax]
	BodyJoints *tensor.Int32 `display:"no-inline"`

	// BodyCollidePairs are pairs of Body indexes that could potentially collide
	// based on precomputed collision logic, using World, Group, and Joint indexes.
	// [BodyCollidePairsN][2]
	BodyCollidePairs *tensor.Int32

	// Dynamics are the dynamic rigid body elements: these actually move.
	// The first set of variables are for initial values, and the second current.
	// [body][cur/next][DynamicVarsN]
	Dynamics *tensor.Float32 `display:"no-inline"`

	// BroadContactsN has number of points of broad contact
	// between bodies. [1]
	BroadContactsN *tensor.Int32

	// BroadContacts are the results of broad-phase contact processing,
	// establishing possible points of contact between bodies.
	// [ContactsMax][BroadContactVarsN]
	BroadContacts *tensor.Float32 `display:"no-inline"`

	// ContactsN has number of points of narrow (final) contact
	// between bodies. [1]
	ContactsN *tensor.Int32 `display:"no-inline"`

	// Contacts are the results of narrow-phase contact processing,
	// where only actual contacts with fully-specified values are present.
	// [ContactsMax][ContactVarsN]
	Contacts *tensor.Float32 `display:"no-inline"`

	// JointControls are dynamic joint control inputs, per joint DoF
	// (in correspondence with [JointDoFs]). This can be uploaded to the
	// GPU at every step.
	// [dof][JointControlVarsN]
	JointControls *tensor.Float32 `display:"no-inline"`
}

func NewWorld() *World {
	ph := &World{}
	ph.Init()
	return ph
}

// Init makes initial vars. Called in NewWorld.
// Must call Config once configured.
func (ph *World) Init() {
	ph.GPU = true
	ph.Params = make([]PhysParams, 1)
	ph.Params[0].Defaults()
	ph.Reset()
}

// Reset resets all data to empty: starting over.
func (ph *World) Reset() {
	ph.Bodies = tensor.NewFloat32(0, int(BodyVarsN))
	ph.Joints = tensor.NewFloat32(0, int(JointVarsN))
	ph.JointDoFs = tensor.NewFloat32(0, int(JointDoFVarsN))
	ph.BodyJoints = tensor.NewInt32(0, 2, 2)
	ph.BodyCollidePairs = tensor.NewInt32(0, 2)
	ph.Dynamics = tensor.NewFloat32(0, 2, int(DynamicVarsN))
	ph.BroadContactsN = tensor.NewInt32(1)
	ph.BroadContacts = tensor.NewFloat32(0, int(ContactVarsN))
	ph.ContactsN = tensor.NewInt32(1)
	ph.Contacts = tensor.NewFloat32(0, int(ContactVarsN))
	ph.JointControls = tensor.NewFloat32(0, int(JointControlVarsN))
	ph.SetAsCurrentVars()
}

// NewBody adds a new body with given parameters. Returns the index.
// Use this for Static elements; NewDynamic for dynamic elements.
func (ph *World) NewBody(shape Shapes, size, pos math32.Vector3, rot math32.Quat) int32 {
	sizes := ph.Bodies.ShapeSizes()
	idx := int32(sizes[0])
	ph.Bodies.SetShapeSizes(int(idx+1), int(BodyVarsN))
	ph.Params[0].BodiesN = idx + 1
	SetBodyShape(idx, shape)
	SetBodyDynamic(idx, -1)
	SetBodyHSize(idx, size)
	SetBodyPos(idx, pos)
	SetBodyQuat(idx, rot)
	SetBodyGroup(idx, -1) // assume static
	SetBodyWorld(idx, int32(ph.CurrentWorld))
	SetBodyObject(idx, int32(ph.CurrentObject))
	ph.SetMass(idx, shape, size, 0) // assume static
	return idx
}

// NewDynamic adds a new dynamic body with given parameters. Returns the index.
// Shape cannot be [Plane].
func (ph *World) NewDynamic(shape Shapes, mass float32, size, pos math32.Vector3, rot math32.Quat) (bodyIdx, dynIdx int32) {
	if shape == Plane {
		panic("physics.NewDynamic: shape cannot be Plane")
	}
	bodyIdx = ph.NewBody(shape, size, pos, rot)
	sizes := ph.Dynamics.ShapeSizes()
	dynIdx = int32(sizes[0])
	ph.Dynamics.SetShapeSizes(int(dynIdx+1), 2, int(DynamicVarsN))
	ph.Params[0].DynamicsN = dynIdx + 1
	SetDynamicBody(dynIdx, bodyIdx)
	SetBodyDynamic(bodyIdx, dynIdx)
	SetBodyGroup(bodyIdx, 1) // dynamic
	ph.SetMass(bodyIdx, shape, size, mass)
	return
}

// SetAsCurrent sets these as the current global values that are
// processed in the code (on the GPU). If this was not the setter of
// the current variables, then the parameter variables are copied up
// to the GPU.
func (ph *World) SetAsCurrent() {
	isCur := (Bodies == ph.Bodies)
	ph.SetAsCurrentVars()
	if GPUInitialized && !isCur {
		ph.ToGPUInfra()
	}
}

// SetAsCurrentVars sets these as the current global values that are
// processed in the code (on the GPU).
func (ph *World) SetAsCurrentVars() {
	Params = ph.Params
	Bodies = ph.Bodies
	Joints = ph.Joints
	JointDoFs = ph.JointDoFs
	BodyJoints = ph.BodyJoints
	BodyCollidePairs = ph.BodyCollidePairs
	Dynamics = ph.Dynamics
	BroadContactsN = ph.BroadContactsN
	BroadContacts = ph.BroadContacts
	ContactsN = ph.ContactsN
	Contacts = ph.Contacts
	JointControls = ph.JointControls
}

// GPUInit initializes the GPU and transfers Infra.
// Should have already called SetAsCurrent (needed for CPU and GPU).
func (ph *World) GPUInit() {
	GPUInit()
	UseGPU = ph.GPU
	ph.ToGPUInfra()
}

// ToGPUInfra copies all the infrastructure for these filters up to
// the GPU. This is done in GPUInit, and if current switched.
func (ph *World) ToGPUInfra() {
	ToGPUTensorStrides()
	ToGPU(ParamsVar, BodiesVar, JointsVar, JointDoFsVar, BodyJointsVar, BodyCollidePairsVar, DynamicsVar, BroadContactsNVar, BroadContactsVar, ContactsNVar, ContactsVar, JointControlsVar)
}
