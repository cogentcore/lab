// Code generated by "gosl"; DO NOT EDIT
// kernel: StepBodyContacts

// // Params are global parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read_write> Params: array<PhysParams>;
// // Bodies are the rigid body elements (dynamic and static), // specifying the constant, non-dynamic properties, // which is initial state for dynamics. // [body][BodyVarsN] 
@group(1) @binding(0)
var<storage, read_write> Bodies: array<f32>;
// // Dynamics are the dynamic rigid body elements: these actually move. // Two alternating states are used: Params.Cur and Params.Next. // [dyn body][cur/next][DynamicVarsN] 
@group(2) @binding(0)
var<storage, read_write> Dynamics: array<f32>;
@group(2) @binding(3)
var<storage, read_write> ContactsN: array<i32>;
@group(2) @binding(4)
var<storage, read_write> Contacts: array<f32>;
// // JointControls are dynamic joint control inputs, per joint DoF // (in correspondence with [JointDoFs]). This can be uploaded to the // GPU at every step. // [dof][JointControlVarsN] 

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	StepBodyContacts(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}

fn Index3D(s0: u32, s1: u32, s2: u32, i0: u32, i1: u32, i2: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2;
}

fn Index1D(s0: u32, i0: u32) -> u32 {
	return s0 * i0;
}


//////// import: "vars.go"

//////// import: "body.go"
alias BodyVars = i32; //enums:enum
const  BodyShape: BodyVars = 0;
const  BodyDynamic: BodyVars = 1;
const  BodyWorld: BodyVars = 2;
const  BodyGroup: BodyVars = 3;
const  BodyHSizeX: BodyVars = 4;
const  BodyHSizeY: BodyVars = 5;
const  BodyHSizeZ: BodyVars = 6;
const  BodyThick: BodyVars = 7;
const  BodyMass: BodyVars = 8;
const  BodyInvMass: BodyVars = 9;
const  BodyBounce: BodyVars = 10;
const  BodyFriction: BodyVars = 11;
const  BodyFrictionTortion: BodyVars = 12;
const  BodyFrictionRolling: BodyVars = 13;
const  BodyPosX: BodyVars = 14;
const  BodyPosY: BodyVars = 15;
const  BodyPosZ: BodyVars = 16;
const  BodyQuatX: BodyVars = 17;
const  BodyQuatY: BodyVars = 18;
const  BodyQuatZ: BodyVars = 19;
const  BodyQuatW: BodyVars = 20;
const  BodyComX: BodyVars = 21;
const  BodyComY: BodyVars = 22;
const  BodyComZ: BodyVars = 23;
const  BodyInertiaXX: BodyVars = 24;
const  BodyInertiaYX: BodyVars = 25;
const  BodyInertiaZX: BodyVars = 26;
const  BodyInertiaXY: BodyVars = 27;
const  BodyInertiaYY: BodyVars = 28;
const  BodyInertiaZY: BodyVars = 29;
const  BodyInertiaXZ: BodyVars = 30;
const  BodyInertiaYZ: BodyVars = 31;
const  BodyInertiaZZ: BodyVars = 32;
const  BodyInvInertiaXX: BodyVars = 33;
const  BodyInvInertiaYX: BodyVars = 34;
const  BodyInvInertiaZX: BodyVars = 35;
const  BodyInvInertiaXY: BodyVars = 36;
const  BodyInvInertiaYY: BodyVars = 37;
const  BodyInvInertiaZY: BodyVars = 38;
const  BodyInvInertiaXZ: BodyVars = 39;
const  BodyInvInertiaYZ: BodyVars = 40;
const  BodyInvInertiaZZ: BodyVars = 41;
const  BodyRadius: BodyVars = 42;
fn GetBodyDynamic(idx: i32) -> i32 {
	return i32(bitcast<u32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1],
	u32(idx), u32(BodyDynamic))]));
}
fn BodyPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyPosX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyPosY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyPosZ))]);
}
fn BodyQuat(idx: i32) -> vec4<f32> {
	return vec4<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyQuatX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyQuatY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyQuatZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyQuatW))]);
}
fn BodyDynamicPos(idx: i32,cni: i32) -> vec3<f32> {
	var didx = GetBodyDynamic(idx);
	if (didx < 0) {
		return BodyPos(idx);
	}return DynamicPos(didx, cni);
}
fn BodyDynamicQuat(idx: i32,cni: i32) -> vec4<f32> {
	var didx = GetBodyDynamic(idx);
	if (didx < 0) {
		return BodyQuat(idx);
	}return DynamicQuat(didx, cni);
}
fn BodyCom(idx: i32) -> vec3<f32> {
	return vec3<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComZ))]);
}
fn BodyInvInertia(idx: i32) -> mat3x3f {
	return mat3x3f(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZX))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZY))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZZ))]);
}

//////// import: "contact.go"
alias ContactVars = i32; //enums:enum
const  ContactA: ContactVars = 0;
const  ContactB: ContactVars = 1;
const  ContactPointIdx: ContactVars = 2;
const  ContactAPointX: ContactVars = 3;
const  ContactAPointY: ContactVars = 4;
const  ContactAPointZ: ContactVars = 5;
const  ContactBPointX: ContactVars = 6;
const  ContactBPointY: ContactVars = 7;
const  ContactBPointZ: ContactVars = 8;
const  ContactAOffX: ContactVars = 9;
const  ContactAOffY: ContactVars = 10;
const  ContactAOffZ: ContactVars = 11;
const  ContactBOffX: ContactVars = 12;
const  ContactBOffY: ContactVars = 13;
const  ContactBOffZ: ContactVars = 14;
const  ContactAThick: ContactVars = 15;
const  ContactBThick: ContactVars = 16;
const  ContactNormX: ContactVars = 17;
const  ContactNormY: ContactVars = 18;
const  ContactNormZ: ContactVars = 19;
const  ContactWeight: ContactVars = 20;
const  ContactADeltaX: ContactVars = 21;
const  ContactADeltaY: ContactVars = 22;
const  ContactADeltaZ: ContactVars = 23;
const  ContactAAngDeltaX: ContactVars = 24;
const  ContactAAngDeltaY: ContactVars = 25;
const  ContactAAngDeltaZ: ContactVars = 26;
const  ContactBDeltaX: ContactVars = 27;
const  ContactBDeltaY: ContactVars = 28;
const  ContactBDeltaZ: ContactVars = 29;
const  ContactBAngDeltaX: ContactVars = 30;
const  ContactBAngDeltaY: ContactVars = 31;
const  ContactBAngDeltaZ: ContactVars = 32;
const BroadContactVarsN = ContactAPointX;
fn GetContactA(idx: i32) -> i32 { return i32(bitcast<u32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactA))])); }
fn GetContactB(idx: i32) -> i32 { return i32(bitcast<u32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactB))])); }
fn ContactAPoint(idx: i32) -> vec3<f32> { return vec3<f32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAPointX))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAPointY))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAPointZ))]); }
fn ContactBPoint(idx: i32) -> vec3<f32> { return vec3<f32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBPointX))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBPointY))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBPointZ))]); }
fn ContactAOff(idx: i32) -> vec3<f32> { return vec3<f32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAOffX))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAOffY))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAOffZ))]); }
fn ContactBOff(idx: i32) -> vec3<f32> { return vec3<f32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBOffX))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBOffY))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBOffZ))]); }
fn ContactNorm(idx: i32) -> vec3<f32> { return vec3<f32>(Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactNormX))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactNormY))], Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactNormZ))]); }
fn SetContactADelta(idx: i32, pos: vec3<f32>) { Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactADeltaX))] = pos.x;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactADeltaY))] = pos.y;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactADeltaZ))] = pos.z; }
fn SetContactAAngDelta(idx: i32, pos: vec3<f32>) { Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAAngDeltaX))] = pos.x;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAAngDeltaY))] = pos.y;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactAAngDeltaZ))] = pos.z; }
fn SetContactBDelta(idx: i32, pos: vec3<f32>) { Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBDeltaX))] = pos.x;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBDeltaY))] = pos.y;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBDeltaZ))] = pos.z; }
fn SetContactBAngDelta(idx: i32, pos: vec3<f32>) { Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBAngDeltaX))] = pos.x;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBAngDeltaY))] = pos.y;; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(idx), u32(ContactBAngDeltaZ))] = pos.z; }
fn StepBodyContacts(i: u32) { //gosl:kernel
var params = Params[0];; var ci = i32(i);
; var cmax = ContactsN[0];
; if (ci >= cmax) {
	return;
}; var biA = GetContactA(ci);
; var biB = GetContactB(ci);
; var diA = GetBodyDynamic(biA);
; var diB = GetBodyDynamic(biB);
; var r1A = BodyDynamicPos(biA, params.Next);
; var q1A = BodyDynamicQuat(biA, params.Next);
; var r1B = BodyDynamicPos(biB, params.Next);
; var q1B = BodyDynamicQuat(biB, params.Next);
; var ctA = ContactAPoint(ci);
; var offA = ContactAOff(ci);
; var ctB = ContactBPoint(ci);
; var offB = ContactBOff(ci);
; var ctAw = MulSpatialPoint(r1A, q1A, ctA);
; var ctBw = MulSpatialPoint(r1B, q1B, ctB);
; var thickA = Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(ci), u32(ContactAThick))];
; var thickB = Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(ci), u32(ContactBThick))];
; var thick = thickA + thickB;
; var nnorm = ContactNorm(ci);
; var norm = Negate3(nnorm);
;
var d = Dot3(norm, ctBw-(ctAw)) - thick;
; if (d >= 0.0) { // todo: should this be margin or not?
	Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(ci), u32(ContactWeight))] = 0.0;
	var z = vec3<f32>(0, 0, 0);
	SetContactADelta(ci, z);
	SetContactBDelta(ci, z);
	SetContactAAngDelta(ci, z);
	SetContactBAngDelta(ci, z);return;
}; var comA = BodyCom(biA);
; var mInvA = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biA), u32(BodyInvMass))];
; var iInvA = BodyInvInertia(biA);
; var comB = BodyCom(biB);
; var mInvB = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biB), u32(BodyInvMass))];
; var iInvB = BodyInvInertia(biB);
; var w1A: vec3<f32>;
var w1B: vec3<f32>;; if (diA >= 0) {
	w1A = DynamicAngDelta(diA, params.Next);
}; if (diB >= 0) {
	w1B = DynamicAngDelta(diB, params.Next);
};
var mu = 0.5 * (Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biA), u32(BodyFriction))] + Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biB), u32(BodyFriction))]);
; var frTors = 0.5 * (Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biA), u32(BodyFrictionTortion))] + Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biB), u32(BodyFrictionTortion))]);
; var frRoll = 0.5 * (Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biA), u32(BodyFrictionRolling))] + Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biB), u32(BodyFrictionRolling))]);
; var bounce = 0.5 * (Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(biA), u32(BodyBounce))] + Bodies[Index2D(TensorStrides[0], TensorStrides[1],
u32(biB), u32(BodyBounce))]);
; var dA = ctAw-(MulSpatialPoint(r1A, q1A, comA));
; var dB = ctBw-(MulSpatialPoint(r1B, q1B, comB));
; var angA = Negate3(Cross3(dA, norm));
; var angB = Cross3(dB, norm);
; var lambdaN = ContactConstraint(d, q1A, q1B, mInvA, mInvB, iInvA, iInvB, nnorm, norm, angA, angB, params.ContactRelax, params.Dt);
; var linDeltaA = Negate3(norm)*(lambdaN);
; var linDeltaB = norm*(lambdaN);
; var angDeltaA = angA*(lambdaN);
; var angDeltaB = angB*(lambdaN);
;
if (mu > 0.0) {
	var ctAm = ctAw+(MulQuatVector(q1A, offA));
	var ctBm = ctBw+(MulQuatVector(q1B, offB));
	var delta = ctBm-(ctAm);
	var frDelta = delta-(norm*(Dot3(norm, delta)));
	var perp = Normal3(frDelta);
	var dAm = ctAm-(MulSpatialPoint(r1A, q1A, comA));
	var dBm = ctBm-(MulSpatialPoint(r1B, q1B, comB));
	angA = Negate3(Cross3(dAm, perp));
	angB = Cross3(dBm, perp);
	var err = Length3(frDelta);
	if (err > 0.0) {
		var lambdaFr = ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, Negate3(perp), perp, angA, angB, params.ContactRelax, params.Dt);
		lambdaFr = max(lambdaFr, -lambdaN*mu);
		linDeltaA = linDeltaA-(perp*(lambdaFr));
		linDeltaB = linDeltaB+(perp*(lambdaFr));
		angDeltaA = angDeltaA+(angA*(lambdaFr));
		angDeltaB = angDeltaB+(angB*(lambdaFr));
	}
}; var deltaW = w1B-(w1A);
; if (frTors > 0.0) {
	var err = Dot3(deltaW, norm) * params.Dt;
	if (abs(err) > 0.0) {
		var lin = vec3<f32>(0, 0, 0);
		var lambdaTors = ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, lin, lin, nnorm, norm, params.ContactRelax, params.Dt);
		lambdaTors = clamp(lambdaTors, -lambdaN*frTors, lambdaN*frTors);
		angDeltaA = angDeltaA-(norm*(lambdaTors));
		angDeltaB = angDeltaB+(norm*(lambdaTors));
	}
}; if (frRoll > 0.0) {
	deltaW = deltaW-(norm*(Dot3(norm, deltaW)));
	var err = Length3(deltaW) * params.Dt;
	if (err > 0.0) {
		var lin = vec3<f32>(0, 0, 0);
		var rollN = Normal3(deltaW);
		var lambdaRoll = ContactConstraint(err, q1A, q1B, mInvA, mInvB, iInvA, iInvB, lin, lin, Negate3(rollN), rollN, params.ContactRelax, params.Dt);
		lambdaRoll = max(lambdaRoll, -lambdaN*frRoll);
		angDeltaA = angDeltaA-(rollN*(lambdaRoll));
		angDeltaB = angDeltaB+(rollN*(lambdaRoll));
	}
};
if (params.Restitution == 1 && bounce > 0 && (mInvA > 0 || mInvB > 0)) {
	var vA: vec3<f32>;
	var vB: vec3<f32>;
	var vAnew: vec3<f32>;
	var vBnew: vec3<f32>;
	var dAnew: vec3<f32>;
	var dBnew: vec3<f32>;
	var mInvAr: f32;
	var mInvBr: f32;
	var q0A: vec4<f32>;
	var q0B: vec4<f32>;
	var grav = vec3<f32>(params.Gravity.x,params.Gravity.y,params.Gravity.z)*(params.Dt);
	if (diA >= 0) {
		q0A = DynamicQuat(diA, params.Cur);
		var w0A = DynamicAngDelta(diA, params.Cur);
		var v0A = DynamicDelta(diA, params.Cur);
		var v1A = DynamicDelta(diA, params.Next);
		vA = VelocityAtPoint(v0A, w0A, dA)+(grav);
		vAnew = VelocityAtPoint(v1A, w1A, dA);
		dAnew = MulQuatVectorInverse(q0A, Cross3(dA, nnorm)); // norm is not - here..
		mInvAr = mInvA + Dot3(dAnew, iInvA*(dAnew));
	}
	if (diB >= 0) {
		q0B = DynamicQuat(diB, params.Cur);
		var w0B = DynamicAngDelta(diB, params.Cur);
		var v0B = DynamicDelta(diB, params.Cur);
		var v1B = DynamicDelta(diB, params.Next);
		vB = VelocityAtPoint(v0B, w0B, dB)+(grav);
		vBnew = VelocityAtPoint(v1B, w1B, dB);
		dBnew = MulQuatVectorInverse(q0B, Cross3(dB, norm)); // norm is not - here..
		mInvBr = mInvB + Dot3(dBnew, iInvB*(dBnew));
	}
	var mInv = mInvAr + mInvBr;
	var relVel0 = Dot3(nnorm, vA-(vB));
	var relVel1 = Dot3(nnorm, vAnew-(vBnew));
	if (relVel0 < 0) {
		var dv = -(relVel1 - relVel0*bounce) / mInv;
		if (diA >= 0) {
			var dvA = nnorm*(mInvA * dv);
			var dwA = MulQuatVector(q0A, iInvA*(dAnew)*(dv));
			linDeltaA = linDeltaA+(dvA);
			angDeltaA = angDeltaA+(dwA);
		}
		if (diB >= 0) {
			var dvB = norm*(mInvB * dv);
			var dwB = MulQuatVector(q0B, iInvB*(dBnew)*(dv));
			linDeltaB = linDeltaB+(dvB);
			angDeltaB = angDeltaB+(dwB);
		}
	}
}; Contacts[Index2D(TensorStrides[90], TensorStrides[91], u32(ci), u32(ContactWeight))] = 1.0;; SetContactADelta(ci, linDeltaA);; SetContactBDelta(ci, linDeltaB);; SetContactAAngDelta(ci, angDeltaA);; SetContactBAngDelta(ci, angDeltaB); }
fn ContactConstraint(err: f32, q0A: vec4<f32>,q0B: vec4<f32>, mInvA: f32,mInvB: f32, iInvA: mat3x3f,iInvB: mat3x3f, linA: vec3<f32>,linB: vec3<f32>,angA: vec3<f32>,angB: vec3<f32>, relaxation: f32,dt: f32) -> f32 {
	var denom = f32(0.0);
	denom += LengthSquared3(linA) * mInvA;
	denom += LengthSquared3(linB) * mInvB;
	var rotAngA = MulQuatVectorInverse(q0A, angA);
	var rotAngB = MulQuatVectorInverse(q0B, angB);
	denom += Dot3(rotAngA, iInvA*(rotAngA));
	denom += Dot3(rotAngB, iInvB*(rotAngB));
	var lambda = -err;
	if (denom > 0.0) {
		lambda /= dt * denom;
	}return lambda * relaxation;
}

//////// import: "control.go"
alias JointControlVars = i32; //enums:enum
const  JointControlForce: JointControlVars = 0;
const  JointTargetPos: JointControlVars = 1;
const  JointTargetStiff: JointControlVars = 2;
const  JointTargetVel: JointControlVars = 3;
const  JointTargetDamp: JointControlVars = 4;

//////// import: "dynamics.go"
alias DynamicVars = i32; //enums:enum
const  DynBody: DynamicVars = 0;
const  DynPosX: DynamicVars = 1;
const  DynPosY: DynamicVars = 2;
const  DynPosZ: DynamicVars = 3;
const  DynQuatX: DynamicVars = 4;
const  DynQuatY: DynamicVars = 5;
const  DynQuatZ: DynamicVars = 6;
const  DynQuatW: DynamicVars = 7;
const  DynVelX: DynamicVars = 8;
const  DynVelY: DynamicVars = 9;
const  DynVelZ: DynamicVars = 10;
const  DynAngVelX: DynamicVars = 11;
const  DynAngVelY: DynamicVars = 12;
const  DynAngVelZ: DynamicVars = 13;
const  DynAccX: DynamicVars = 14;
const  DynAccY: DynamicVars = 15;
const  DynAccZ: DynamicVars = 16;
const  DynAngAccX: DynamicVars = 17;
const  DynAngAccY: DynamicVars = 18;
const  DynAngAccZ: DynamicVars = 19;
const  DynForceX: DynamicVars = 20;
const  DynForceY: DynamicVars = 21;
const  DynForceZ: DynamicVars = 22;
const  DynTorqueX: DynamicVars = 23;
const  DynTorqueY: DynamicVars = 24;
const  DynTorqueZ: DynamicVars = 25;
const  DynDeltaX: DynamicVars = 26;
const  DynDeltaY: DynamicVars = 27;
const  DynDeltaZ: DynamicVars = 28;
const  DynAngDeltaX: DynamicVars = 29;
const  DynAngDeltaY: DynamicVars = 30;
const  DynAngDeltaZ: DynamicVars = 31;
const  DynContactWeight: DynamicVars = 32;
fn DynamicPos(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosZ))]);
}
fn DynamicQuat(idx: i32,cni: i32) -> vec4<f32> {
	return vec4<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatZ))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatW))]);
}
fn DynamicDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynDeltaX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynDeltaY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynDeltaZ))]);
}
fn DynamicAngDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynAngDeltaX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynAngDeltaY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynAngDeltaZ))]);
}

//////// import: "enumgen.go"
const BodyVarsN: BodyVars = 43;
const ContactVarsN: ContactVars = 33;
const JointControlVarsN: JointControlVars = 5;
const DynamicVarsN: DynamicVars = 33;
const GPUVarsN: GPUVars = 12;
const JointTypesN: JointTypes = 8;
const JointVarsN: JointVars = 50;
const JointDoFVarsN: JointDoFVars = 5;
const ShapesN: Shapes = 6;

//////// import: "joint.go"
const JointLimitUnlimited = 1e10;
alias JointTypes = i32; //enums:enum
const  Prismatic: JointTypes = 0;
const  Revolute: JointTypes = 1;
const  Ball: JointTypes = 2;
const  Fixed: JointTypes = 3;
const  Free: JointTypes = 4;
const  Distance: JointTypes = 5;
const  D6: JointTypes = 6;
const  PlaneXZ: JointTypes = 7;
alias JointVars = i32; //enums:enum
const  JointType: JointVars = 0;
const  JointEnabled: JointVars = 1;
const  JointParent: JointVars = 2;
const  JointChild: JointVars = 3;
const  JointPPosX: JointVars = 4;
const  JointPPosY: JointVars = 5;
const  JointPPosZ: JointVars = 6;
const  JointPQuatX: JointVars = 7;
const  JointPQuatY: JointVars = 8;
const  JointPQuatZ: JointVars = 9;
const  JointPQuatW: JointVars = 10;
const  JointCPosX: JointVars = 11;
const  JointCPosY: JointVars = 12;
const  JointCPosZ: JointVars = 13;
const  JointCQuatX: JointVars = 14;
const  JointCQuatY: JointVars = 15;
const  JointCQuatZ: JointVars = 16;
const  JointCQuatW: JointVars = 17;
const  JointLinearDoFN: JointVars = 18;
const  JointAngularDoFN: JointVars = 19;
const  JointDoF1: JointVars = 20;
const  JointDoF2: JointVars = 21;
const  JointDoF3: JointVars = 22;
const  JointDoF4: JointVars = 23;
const  JointDoF5: JointVars = 24;
const  JointDoF6: JointVars = 25;
const  JointPForceX: JointVars = 26;
const  JointPForceY: JointVars = 27;
const  JointPForceZ: JointVars = 28;
const  JointPTorqueX: JointVars = 29;
const  JointPTorqueY: JointVars = 30;
const  JointPTorqueZ: JointVars = 31;
const  JointCForceX: JointVars = 32;
const  JointCForceY: JointVars = 33;
const  JointCForceZ: JointVars = 34;
const  JointCTorqueX: JointVars = 35;
const  JointCTorqueY: JointVars = 36;
const  JointCTorqueZ: JointVars = 37;
const  JointPDeltaX: JointVars = 38;
const  JointPDeltaY: JointVars = 39;
const  JointPDeltaZ: JointVars = 40;
const  JointPAngDeltaX: JointVars = 41;
const  JointPAngDeltaY: JointVars = 42;
const  JointPAngDeltaZ: JointVars = 43;
const  JointCDeltaX: JointVars = 44;
const  JointCDeltaY: JointVars = 45;
const  JointCDeltaZ: JointVars = 46;
const  JointCAngDeltaX: JointVars = 47;
const  JointCAngDeltaY: JointVars = 48;
const  JointCAngDeltaZ: JointVars = 49;
alias JointDoFVars = i32; //enums:enum
const  JointAxisX: JointDoFVars = 0;
const  JointAxisY: JointDoFVars = 1;
const  JointAxisZ: JointDoFVars = 2;
const  JointLimitLower: JointDoFVars = 3;
const  JointLimitUpper: JointDoFVars = 4;

//////// import: "params.go"
struct PhysParams {
	Iterations: i32,
	Dt: f32,
	SubSteps: i32,
	ContactMargin: f32,
	ContactRelax: f32, // 0.8 def
	ContactWeighting: i32, // true
	Restitution: i32, // false
	JointLinearRelax: f32, // 0.7 def
	JointAngularRelax: f32, // 0.4 def
	JointLinearComply: f32, // 0 def
	JointAngularComply: f32, // 0 def
	AngularDamping: f32, // 0 def
	SoftRelax: f32,
	MaxForce: f32,
	MaxGeomIter: i32,
	ContactsMax: i32,
	Cur: i32,
	Next: i32,
	BodiesN: i32,
	DynamicsN: i32,
	JointsN: i32,
	JointDoFsN: i32,
	BodyJointsMax: i32,
	BodyCollidePairsN: i32,
	Gravity: vec4<f32>,
}

//////// import: "shapecollide.go"
struct GeomData {
	BodyIdx: i32,
	Shape: Shapes,
	MinSize: f32,
	Thick: f32,
	Radius: f32,
	Size: vec3<f32>,
	WbR: vec3<f32>,
	WbQ: vec4<f32>,
	BwR: vec3<f32>,
	BwQ: vec4<f32>,
}

//////// import: "shapegeom.go"

//////// import: "shapes.go"
alias Shapes = i32; //enums:enum
const  Plane: Shapes = 0;
const  Sphere: Shapes = 1;
const  Capsule: Shapes = 2;
const  Cylinder: Shapes = 3;
const  Box: Shapes = 4;
const  Cone: Shapes = 5;

//////// import: "slmath-matrix3.go"

//////// import: "slmath-quaternion.go"
fn MulQuatVector(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = Cross3(xyz, v)*(2);
return v+(t*(q.w))+(Cross3(xyz, t));
}
fn MulQuatVectorInverse(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = Cross3(xyz, v)*(2);
return v-(t*(q.w))+(Cross3(xyz, t));
}
fn MulSpatialPoint(xP: vec3<f32>, xQ: vec4<f32>, p: vec3<f32>) -> vec3<f32> {
	var dp = MulQuatVector(xQ, p);
return dp+(xP);
}

//////// import: "slmath-vector2.go"

//////// import: "slmath-vector3.go"
fn Negate3(v: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(-v.x, -v.y, -v.z);
}
fn Length3(v: vec3<f32>) -> f32 {
	return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}
fn LengthSquared3(v: vec3<f32>) -> f32 {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
fn Dot3(v: vec3<f32>,o: vec3<f32>) -> f32 {
	return v.x*o.x + v.y*o.y + v.z*o.z;
}
fn Normal3(v: vec3<f32>) -> vec3<f32> {
	return v/(Length3(v));
}
fn Cross3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(v.y*o.z-v.z*o.y, v.z*o.x-v.x*o.z, v.x*o.y-v.y*o.x);
}

//////// import: "step.go"

//////// import: "step_body.go"
fn VelocityAtPoint(lin: vec3<f32>,ang: vec3<f32>,r: vec3<f32>) -> vec3<f32> {
	return lin+(Cross3(ang, r));
}

//////// import: "step_joint.go"