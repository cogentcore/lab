// Code generated by "gosl"; DO NOT EDIT
// kernel: StepJointForces

// // Params are global parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<PhysParams>;
// // Bodies are the rigid body elements (dynamic and static), // specifying the constant, non-dynamic properties, // which is initial state for dynamics. // [body][BodyVarsN] 
@group(1) @binding(0)
var<storage, read_write> Bodies: array<f32>;
@group(1) @binding(1)
var<storage, read_write> Joints: array<f32>;
@group(1) @binding(2)
var<storage, read_write> JointDoFs: array<f32>;
// // Dynamics are the dynamic rigid body elements: these actually move. // Two alternating states are used: Params.Cur and Params.Next. // [dyn body][cur/next][DynamicVarsN] 
@group(2) @binding(0)
var<storage, read_write> Dynamics: array<f32>;
// // JointControls are dynamic joint control inputs, per joint DoF // (in correspondence with [JointDoFs]). This can be uploaded to the // GPU at every step. // [dof][JointControlVarsN] 
@group(3) @binding(0)
var<storage, read_write> JointControls: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	StepJointForces(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}

fn Index3D(s0: u32, s1: u32, s2: u32, i0: u32, i1: u32, i2: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2;
}


//////// import: "vars.go"

//////// import: "body.go"
alias BodyVars = i32; //enums:enum
const  BodyShape: BodyVars = 0;
const  BodyDynamic: BodyVars = 1;
const  BodyWorld: BodyVars = 2;
const  BodyGroup: BodyVars = 3;
const  BodySizeX: BodyVars = 4;
const  BodySizeY: BodyVars = 5;
const  BodySizeZ: BodyVars = 6;
const  BodyMass: BodyVars = 7;
const  BodyInvMass: BodyVars = 8;
const  BodyBounce: BodyVars = 9;
const  BodyFriction: BodyVars = 10;
const  BodyPosX: BodyVars = 11;
const  BodyPosY: BodyVars = 12;
const  BodyPosZ: BodyVars = 13;
const  BodyQuatX: BodyVars = 14;
const  BodyQuatY: BodyVars = 15;
const  BodyQuatZ: BodyVars = 16;
const  BodyQuatW: BodyVars = 17;
const  BodyComX: BodyVars = 18;
const  BodyComY: BodyVars = 19;
const  BodyComZ: BodyVars = 20;
const  BodyInertiaXX: BodyVars = 21;
const  BodyInertiaYX: BodyVars = 22;
const  BodyInertiaZX: BodyVars = 23;
const  BodyInertiaXY: BodyVars = 24;
const  BodyInertiaYY: BodyVars = 25;
const  BodyInertiaZY: BodyVars = 26;
const  BodyInertiaXZ: BodyVars = 27;
const  BodyInertiaYZ: BodyVars = 28;
const  BodyInertiaZZ: BodyVars = 29;
const  BodyInvInertiaXX: BodyVars = 30;
const  BodyInvInertiaYX: BodyVars = 31;
const  BodyInvInertiaZX: BodyVars = 32;
const  BodyInvInertiaXY: BodyVars = 33;
const  BodyInvInertiaYY: BodyVars = 34;
const  BodyInvInertiaZY: BodyVars = 35;
const  BodyInvInertiaXZ: BodyVars = 36;
const  BodyInvInertiaYZ: BodyVars = 37;
const  BodyInvInertiaZZ: BodyVars = 38;
const  BodyRadius: BodyVars = 39;
fn BodyCom(idx: i32) -> vec3<f32> {
	return vec3<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComZ))]);
}

//////// import: "contact.go"
alias ContactVars = i32; //enums:enum
const  ContactA: ContactVars = 0;
const  ContactB: ContactVars = 1;
const  ContactPointIdx: ContactVars = 2;
const  ContactAPointX: ContactVars = 3;
const  ContactAPointY: ContactVars = 4;
const  ContactAPointZ: ContactVars = 5;
const  ContactBPointX: ContactVars = 6;
const  ContactBPointY: ContactVars = 7;
const  ContactBPointZ: ContactVars = 8;
const  ContactADepth: ContactVars = 9;
const  ContactBDepth: ContactVars = 10;
const  ContactNormX: ContactVars = 11;
const  ContactNormY: ContactVars = 12;
const  ContactNormZ: ContactVars = 13;
const  ContactForceX: ContactVars = 14;
const  ContactForceY: ContactVars = 15;
const  ContactForceZ: ContactVars = 16;

//////// import: "control.go"
alias JointControlVars = i32; //enums:enum
const  JointControlForce: JointControlVars = 0;
const  JointTargetPos: JointControlVars    = 1;
const  JointTargetVel: JointControlVars = 2;
fn JointControl(idx: i32,dof: i32, vr: JointControlVars) -> f32 {
	return JointControls[Index2D(TensorStrides[80], TensorStrides[81], u32(JointDoFIndex(idx, dof)), u32(vr))];
}

//////// import: "dynamics.go"
alias DynamicVars = i32; //enums:enum
const  DynBody: DynamicVars = 0;
const  DynPosX: DynamicVars = 1;
const  DynPosY: DynamicVars = 2;
const  DynPosZ: DynamicVars = 3;
const  DynQuatX: DynamicVars = 4;
const  DynQuatY: DynamicVars = 5;
const  DynQuatZ: DynamicVars = 6;
const  DynQuatW: DynamicVars = 7;
const  DynVelX: DynamicVars = 8;
const  DynVelY: DynamicVars = 9;
const  DynVelZ: DynamicVars = 10;
const  DynAngVelX: DynamicVars = 11;
const  DynAngVelY: DynamicVars = 12;
const  DynAngVelZ: DynamicVars = 13;
const  DynAccX: DynamicVars = 14;
const  DynAccY: DynamicVars = 15;
const  DynAccZ: DynamicVars = 16;
const  DynAngAccX: DynamicVars = 17;
const  DynAngAccY: DynamicVars = 18;
const  DynAngAccZ: DynamicVars = 19;
const  DynForceX: DynamicVars = 20;
const  DynForceY: DynamicVars = 21;
const  DynForceZ: DynamicVars = 22;
const  DynTorqueX: DynamicVars = 23;
const  DynTorqueY: DynamicVars = 24;
const  DynTorqueZ: DynamicVars = 25;
const  DynDeltaX: DynamicVars = 26;
const  DynDeltaY: DynamicVars = 27;
const  DynDeltaZ: DynamicVars = 28;
const  DynAngDeltaX: DynamicVars = 29;
const  DynAngDeltaY: DynamicVars = 30;
const  DynAngDeltaZ: DynamicVars = 31;
fn DynamicBody(idx: i32) -> i32 {
	return i32(bitcast<u32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(0), u32(DynBody))]));
}
fn DynamicPos(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynPosZ))]);
}
fn DynamicQuat(idx: i32,cni: i32) -> vec4<f32> {
	return vec4<f32>(Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatX))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatY))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatZ))], Dynamics[Index3D(TensorStrides[50], TensorStrides[51], TensorStrides[52], u32(idx), u32(cni), u32(DynQuatW))]);
}

//////// import: "enumgen.go"
const BodyVarsN: BodyVars = 40;
const ContactVarsN: ContactVars = 17;
const JointControlVarsN: JointControlVars = 3;
const DynamicVarsN: DynamicVars = 32;
const GPUVarsN: GPUVars = 10;
const JointTypesN: JointTypes = 7;
const JointVarsN: JointVars = 50;
const JointDoFVarsN: JointDoFVars = 7;
const ShapesN: Shapes = 5;

//////// import: "joint.go"
const JointLimitUnlimited = 1e10;
alias JointTypes = i32; //enums:enum
const  Prismatic: JointTypes = 0;
const  Revolute: JointTypes = 1;
const  Ball: JointTypes = 2;
const  Fixed: JointTypes = 3;
const  Free: JointTypes = 4;
const  Distance: JointTypes = 5;
const  D6: JointTypes = 6;
alias JointVars = i32; //enums:enum
const  JointType: JointVars = 0;
const  JointEnabled: JointVars = 1;
const  JointParent: JointVars = 2;
const  JointChild: JointVars = 3;
const  JointPPosX: JointVars = 4;
const  JointPPosY: JointVars = 5;
const  JointPPosZ: JointVars = 6;
const  JointPQuatX: JointVars = 7;
const  JointPQuatY: JointVars = 8;
const  JointPQuatZ: JointVars = 9;
const  JointPQuatW: JointVars = 10;
const  JointCPosX: JointVars = 11;
const  JointCPosY: JointVars = 12;
const  JointCPosZ: JointVars = 13;
const  JointCQuatX: JointVars = 14;
const  JointCQuatY: JointVars = 15;
const  JointCQuatZ: JointVars = 16;
const  JointCQuatW: JointVars = 17;
const  JointLinearDoFN: JointVars = 18;
const  JointAngularDoFN: JointVars = 19;
const  JointDoF1: JointVars = 20;
const  JointDoF2: JointVars = 21;
const  JointDoF3: JointVars = 22;
const  JointDoF4: JointVars = 23;
const  JointDoF5: JointVars = 24;
const  JointDoF6: JointVars = 25;
const  JointPForceX: JointVars = 26;
const  JointPForceY: JointVars = 27;
const  JointPForceZ: JointVars = 28;
const  JointPTorqueX: JointVars = 29;
const  JointPTorqueY: JointVars = 30;
const  JointPTorqueZ: JointVars = 31;
const  JointCForceX: JointVars = 32;
const  JointCForceY: JointVars = 33;
const  JointCForceZ: JointVars = 34;
const  JointCTorqueX: JointVars = 35;
const  JointCTorqueY: JointVars = 36;
const  JointCTorqueZ: JointVars = 37;
const  JointPDeltaX: JointVars = 38;
const  JointPDeltaY: JointVars = 39;
const  JointPDeltaZ: JointVars = 40;
const  JointPAngDeltaX: JointVars = 41;
const  JointPAngDeltaY: JointVars = 42;
const  JointPAngDeltaZ: JointVars = 43;
const  JointCDeltaX: JointVars = 44;
const  JointCDeltaY: JointVars = 45;
const  JointCDeltaZ: JointVars = 46;
const  JointCAngDeltaX: JointVars = 47;
const  JointCAngDeltaY: JointVars = 48;
const  JointCAngDeltaZ: JointVars = 49;
fn GetJointType(idx: i32) -> JointTypes {
	return JointTypes(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointType))]));
}
fn GetJointEnabled(idx: i32) -> bool {
	var je = bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointEnabled))]);return je != 0;
}
fn JointParentIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointParent))]));
}
fn JointChildIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointChild))]));
}
fn GetJointLinearDoFN(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointLinearDoFN))]));
}
fn GetJointAngularDoFN(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointAngularDoFN))]));
}
fn JointDoFIndex(idx: i32,dof: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(i32(JointDoF1) + dof))]));
}
fn JointPPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosZ))]);
}
fn JointPQuat(idx: i32) -> vec4<f32> {
	return vec4<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPQuatX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPQuatY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPQuatZ))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPQuatW))]);
}
fn SetJointPForce(idx: i32, f: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPForceX))] = f.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPForceY))] = f.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPForceZ))] = f.z;
}
fn SetJointPTorque(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPTorqueX))] = t.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPTorqueY))] = t.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPTorqueZ))] = t.z;
}
fn SetJointCForce(idx: i32, f: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCForceX))] = f.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCForceY))] = f.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCForceZ))] = f.z;
}
fn SetJointCTorque(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCTorqueX))] = t.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCTorqueY))] = t.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCTorqueZ))] = t.z;
}
alias JointDoFVars = i32; //enums:enum
const  JointAxisX: JointDoFVars = 0;
const  JointAxisY: JointDoFVars = 1;
const  JointAxisZ: JointDoFVars = 2;
const  JointLimitLower: JointDoFVars = 3;
const  JointLimitUpper: JointDoFVars = 4;
const  JointStiff: JointDoFVars = 5;
const  JointDamp: JointDoFVars = 6;
fn JointAxisDoF(didx: i32) -> vec3<f32> {
	return vec3<f32>(JointDoFs[Index2D(TensorStrides[20], TensorStrides[21], u32(didx), u32(JointAxisX))], JointDoFs[Index2D(TensorStrides[20], TensorStrides[21], u32(didx), u32(JointAxisY))], JointDoFs[Index2D(TensorStrides[20], TensorStrides[21], u32(didx), u32(JointAxisZ))]);
}
fn JointAxis(idx: i32,dof: i32) -> vec3<f32> {
	return JointAxisDoF(JointDoFIndex(idx, dof));
}

//////// import: "params.go"
struct PhysParams {
	Iterations: i32,
	Dt: f32,
	SoftRelax: f32,
	JointLinearRelax: f32,
	JointAngularRelax: f32,
	JointLinearComply: f32,
	JointAngularComply: f32,
	ContactRelax: f32,
	AngularDamping: f32,
	ContactWeighting: i32,
	Restitution: i32,
	ContactMargin: f32,
	ContactsMax: i32,
	Cur: i32,
	Next: i32,
	BodiesN: i32,
	DynamicsN: i32,
	JointsN: i32,
	JointDoFsN: i32,
	BodyJointsMax: i32,
	BodyCollidePairsN: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
	Gravity: vec4<f32>,
}

//////// import: "shapecollide.go"
struct GeomData {
	BodyIdx: i32,
	Shape: Shapes,
	MinSize: f32,
	Thickness: f32,
	Radius: f32,
	Size: vec3<f32>,
	WtoBR: vec3<f32>,
	WtoBQ: vec4<f32>,
	BtoWR: vec3<f32>,
	BtoWQ: vec4<f32>,
}

//////// import: "shapes.go"
alias Shapes = i32; //enums:enum
const  Plane: Shapes = 0;
const  Sphere: Shapes = 1;
const  Capsule: Shapes = 2;
const  Cylinder: Shapes = 3;
const  Box: Shapes = 4;

//////// import: "slmath-matrix3.go"

//////// import: "slmath-quaternion.go"
fn MulQuatVector(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = MulScalar3(Cross3(xyz, v), f32(f32(2)));return v+(MulScalar3(t, q.w))+(Cross3(xyz, t));
}
fn MulQuats(a: vec4<f32>,b: vec4<f32>) -> vec4<f32> {
	var q: vec4<f32>;
	q.x = a.x*b.w + a.w*b.x + a.y*b.z - a.z*b.y;
	q.y = a.y*b.w + a.w*b.y + a.z*b.x - a.x*b.z;
	q.z = a.z*b.w + a.w*b.z + a.x*b.y - a.y*b.x;
	q.w = a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z;return q;
}
fn MulSpatialTransforms(aP: vec3<f32>, aQ: vec4<f32>, bP: vec3<f32>, bQ: vec4<f32>, oP: ptr<function,vec3<f32>>, oQ: ptr<function,vec4<f32>>) {
	*oP = MulQuatVector(aQ, bP)+(aP);
	*oQ = MulQuats(aQ, bQ);
}
fn MulSpatialPoint(xP: vec3<f32>, xQ: vec4<f32>, p: vec3<f32>) -> vec3<f32> {
	var dp = MulQuatVector(xQ, p);return dp+(xP);
}

//////// import: "slmath-vector3.go"
fn MulScalar3(v: vec3<f32>, s: f32) -> vec3<f32> {
	return vec3<f32>(v.x*s, v.y*s, v.z*s);
}
fn Cross3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(v.y*o.z-v.z*o.y, v.z*o.x-v.x*o.z, v.x*o.y-v.y*o.x);
}

//////// import: "step.go"

//////// import: "step_body.go"

//////// import: "step_joint.go"
fn StepJointForces(i: u32) { //gosl:kernel
	let params = Params[0];
	var ji = i32(i);
	if (ji >= params.JointsN) {
		return;
	}
	var jt = GetJointType(ji);
	if (!GetJointEnabled(ji)) {
		return;
	}
	var jPi = JointParentIndex(ji);
	var jPbi = i32(-1);
	if (jPi >= 0) {
		jPbi = DynamicBody(jPi);
	}
	var jCi = JointChildIndex(ji);
	var jCbi = DynamicBody(jCi);
	var jLinearN = GetJointLinearDoFN(ji);
	var jAngularN = GetJointAngularDoFN(ji);
	var jPR = JointPPos(ji);
	var jPQ = JointPQuat(ji);
	var xwPR = jPR;
	var xwPQ = jPQ;
	var posePR = jPR;
	var posePQ = jPQ;
	var comP = vec3<f32>(0, 0, 0);
	if (jPi >= 0) { // can be fixed
		posePR = DynamicPos(jPi, params.Cur);
		posePQ = DynamicQuat(jPi, params.Cur);
		MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ);
		comP = BodyCom(jPbi);
	}
	var dP = xwPR-(MulSpatialPoint(posePR, posePQ, comP)); // parent moment arm
	var poseCR = DynamicPos(jCi, params.Cur);
	var poseCQ = DynamicQuat(jCi, params.Cur);
	var comC = BodyCom(jCbi);
	var dC = poseCR-(MulSpatialPoint(poseCR, poseCQ, comC)); // child moment arm
	var f: vec3<f32>;
	var t: vec3<f32>;
	switch (jt) {
	case Free, Distance: {
		f = vec3<f32>(JointControl(ji, i32(i32(0)), JointControlForce), JointControl(ji, i32(i32(1)), JointControlForce), JointControl(ji, i32(i32(2)), JointControlForce));
		t = vec3<f32>(JointControl(ji, i32(i32(3)), JointControlForce), JointControl(ji, i32(i32(4)), JointControlForce), JointControl(ji, i32(i32(5)), JointControlForce));
	}
	case Ball: {
		t = vec3<f32>(JointControl(ji, i32(i32(0)), JointControlForce), JointControl(ji, i32(i32(1)), JointControlForce), JointControl(ji, i32(i32(2)), JointControlForce));
	}
	case Revolute: {
		var axis = JointAxis(ji, i32(i32(0)));
		t = MulScalar3(MulQuatVector(xwPQ, axis), JointControl(ji, i32(i32(0)), JointControlForce));
	}
	case Prismatic: {
		var axis = JointAxis(ji, i32(i32(0)));
		f = MulScalar3(MulQuatVector(xwPQ, axis), JointControl(ji, i32(i32(0)), JointControlForce));
	}
	default: {
		for (var dof=0; dof<jLinearN; dof++) {
			var axis = JointAxis(ji, i32(dof));
			f = f+(MulScalar3(MulQuatVector(xwPQ, axis), JointControl(ji, i32(dof), JointControlForce)));
		}
		for (var dof=0; dof<jAngularN; dof++) {
			var di = i32(jLinearN) + i32(dof);
			var axis = JointAxis(ji, di);
			t = t+(MulScalar3(MulQuatVector(xwPQ, axis), JointControl(ji, di, JointControlForce)));
		}
	}
	}
	SetJointPForce(ji, f);
	SetJointCForce(ji, f);
	SetJointPTorque(ji, t+(Cross3(dP, f)));
	SetJointCTorque(ji, t+(Cross3(dC, f)));
}