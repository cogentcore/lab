// Code generated by "gosl"; DO NOT EDIT
// kernel: StepJoints

// // Params are global parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<PhysParams>;
// // Bodies are the rigid body elements (dynamic and static), // specifying the constant, non-dynamic properties, // which is initial state for dynamics. // [body][BodyVarsN] 
@group(1) @binding(1)
var<storage, read_write> Dynamics: array<f32>;
@group(1) @binding(2)
var<storage, read_write> Joints: array<f32>;
// // Contacts are points of contact between bodies. // [contact][ContactVarsN] 

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	StepJoints(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}


//////// import: "vars.go"

//////// import: "body.go"
alias BodyVars = i32; //enums:enum
const  Shape: BodyVars = 0;
const  SizeX: BodyVars = 1;
const  SizeY: BodyVars = 2;
const  SizeZ: BodyVars = 3;
const  Mass: BodyVars = 4;
const  Bounce: BodyVars = 5;
const  Friction: BodyVars = 6;
const  BodyPosX: BodyVars = 7;
const  BodyPosY: BodyVars = 8;
const  BodyPosZ: BodyVars = 9;
const  BodyRotX: BodyVars = 10;
const  BodyRotY: BodyVars = 11;
const  BodyRotZ: BodyVars = 12;
const  BodyRotW: BodyVars = 13;
alias DynamicVars = i32; //enums:enum
const  Index: DynamicVars = 0;
const  PosX: DynamicVars = 1;
const  PosY: DynamicVars = 2;
const  PosZ: DynamicVars = 3;
const  RotX: DynamicVars = 4;
const  RotY: DynamicVars = 5;
const  RotZ: DynamicVars = 6;
const  RotW: DynamicVars = 7;
const  VelX: DynamicVars = 8;
const  VelY: DynamicVars = 9;
const  VelZ: DynamicVars = 10;
const  AccX: DynamicVars = 11;
const  AccY: DynamicVars = 12;
const  AccZ: DynamicVars = 13;
const  ForceX: DynamicVars = 14;
const  ForceY: DynamicVars = 15;
const  ForceZ: DynamicVars = 16;
const  AngVelX: DynamicVars = 17;
const  AngVelY: DynamicVars = 18;
const  AngVelZ: DynamicVars = 19;
const  AngAccX: DynamicVars = 20;
const  AngAccY: DynamicVars = 21;
const  AngAccZ: DynamicVars = 22;
fn DynamicPos(idx: i32) -> vec3<f32> {
	var pos: vec3<f32>;
	pos.x = Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosX))];
	pos.y = Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosY))];
	pos.z = Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosZ))];return pos;
}
fn SetDynamicPos(idx: i32, pos: vec3<f32>) {
	Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosX))] = pos.x;
	Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosY))] = pos.y;
	Dynamics[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(PosZ))] = pos.z;
}

//////// import: "collide.go"
alias ContactVars = i32; //enums:enum
const  ContactA: ContactVars = 0;
const  ContactB: ContactVars = 1;
const  ContactNormX: ContactVars = 2;
const  ContactNormY: ContactVars = 3;
const  ContactNormZ: ContactVars = 4;
const  ContactPointX: ContactVars = 5;
const  ContactPointY: ContactVars = 6;
const  ContactPointZ: ContactVars = 7;
const  ContactDist: ContactVars = 8;

//////// import: "enumgen.go"
const BodyVarsN: BodyVars = 14;
const DynamicVarsN: DynamicVars = 23;
const ContactVarsN: ContactVars = 9;
const GPUVarsN: GPUVars = 5;
const JointVarsN: JointVars = 8;
const JointTypesN: JointTypes = 2;
const ShapesN: Shapes = 4;

//////// import: "joint.go"
alias JointVars = i32; //enums:enum
const  JointType: JointVars = 0;
const  JointA: JointVars = 1;
const  JointB: JointVars = 2;
const  JointPosX: JointVars = 3;
const  JointPosY: JointVars = 4;
const  JointPosZ: JointVars = 5;
const  JointParamA: JointVars = 6;
const  JointParamB: JointVars = 7;
fn GetJointType(idx: i32) -> JointTypes {
	return JointTypes(bitcast<u32>(Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointType))]));
}
fn JointAIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointA))]));
}
fn JointBIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointB))]));
}
fn JointPos(idx: i32) -> vec3<f32> {
	var pos: vec3<f32>;
	pos.x = Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointPosX))];
	pos.y = Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointPosY))];
	pos.z = Joints[Index2D(TensorStrides[20], TensorStrides[21], u32(idx), u32(JointPosZ))];return pos;
}
alias JointTypes = i32; //enums:enum
const  Glue: JointTypes = 0;
const  Ball: JointTypes = 1;
fn GlueStep(ji: i32,ba: i32,bb: i32) {
	var pos = JointPos(ji);
	var bap = DynamicPos(ba);
	var bbp = pos.Add(bap);
	SetDynamicPos(bb, bbp);
}

//////// import: "params.go"
struct PhysParams {
	DynamicsN: i32,
	JointsN: i32,
	Step: f32,
	Gravity: f32,
	GravityDir: vec4<f32>,
}

//////// import: "shapes.go"
alias Shapes = i32; //enums:enum
const  Box: Shapes = 0;
const  Sphere: Shapes = 1;
const  Cylinder: Shapes = 2;
const  Capsule: Shapes = 3;

//////// import: "step.go"
fn StepJoints(i: u32) { //gosl:kernel
	let pars = Params[0];
	var ji = i32(i);
	if (ji >= pars.JointsN) {
		return;
	}
	var ba = JointAIndex(ji);
	var bb = JointBIndex(ji);
	var jt = GetJointType(ji);
	switch (jt) {
	case Glue: {
		GlueStep(ji, ba, bb);
	}
	}
}