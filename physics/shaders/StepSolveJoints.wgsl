// Code generated by "gosl"; DO NOT EDIT
// kernel: StepSolveJoints

// // Params are global parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Params: array<PhysParams>;
// // Bodies are the rigid body elements (dynamic and static), // specifying the constant, non-dynamic properties, // which is initial state for dynamics. // [body][BodyVarsN] 
@group(1) @binding(0)
var<storage, read_write> Bodies: array<f32>;
@group(1) @binding(1)
var<storage, read_write> Joints: array<f32>;
// // Dynamics are the dynamic rigid body elements: these actually move. // Two alternating states are used: Params.Cur and Params.Next. // [dyn body][cur/next][DynamicVarsN] 
@group(2) @binding(0)
var<storage, read_write> Dynamics: array<f32>;
// // JointControls are dynamic joint control inputs. // [joint][JointControlVarsN] 
@group(3) @binding(0)
var<storage, read_write> JointControls: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	StepSolveJoints(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}

fn Index3D(s0: u32, s1: u32, s2: u32, i0: u32, i1: u32, i2: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2;
}


//////// import: "vars.go"

//////// import: "body.go"
alias BodyVars = i32; //enums:enum
const  BodyShape: BodyVars = 0;
const  BodyWorldIndex: BodyVars = 1;
const  BodySizeX: BodyVars = 2;
const  BodySizeY: BodyVars = 3;
const  BodySizeZ: BodyVars = 4;
const  BodyMass: BodyVars = 5;
const  BodyInvMass: BodyVars = 6;
const  BodyBounce: BodyVars = 7;
const  BodyFriction: BodyVars = 8;
const  BodyPosX: BodyVars = 9;
const  BodyPosY: BodyVars = 10;
const  BodyPosZ: BodyVars = 11;
const  BodyRotX: BodyVars = 12;
const  BodyRotY: BodyVars = 13;
const  BodyRotZ: BodyVars = 14;
const  BodyRotW: BodyVars = 15;
const  BodyComX: BodyVars = 16;
const  BodyComY: BodyVars = 17;
const  BodyComZ: BodyVars = 18;
const  BodyInertiaXX: BodyVars = 19;
const  BodyInertiaYX: BodyVars = 20;
const  BodyInertiaZX: BodyVars = 21;
const  BodyInertiaXY: BodyVars = 22;
const  BodyInertiaYY: BodyVars = 23;
const  BodyInertiaZY: BodyVars = 24;
const  BodyInertiaXZ: BodyVars = 25;
const  BodyInertiaYZ: BodyVars = 26;
const  BodyInertiaZZ: BodyVars = 27;
const  BodyInvInertiaXX: BodyVars = 28;
const  BodyInvInertiaYX: BodyVars = 29;
const  BodyInvInertiaZX: BodyVars = 30;
const  BodyInvInertiaXY: BodyVars = 31;
const  BodyInvInertiaYY: BodyVars = 32;
const  BodyInvInertiaZY: BodyVars = 33;
const  BodyInvInertiaXZ: BodyVars = 34;
const  BodyInvInertiaYZ: BodyVars = 35;
const  BodyInvInertiaZZ: BodyVars = 36;
fn BodyCom(idx: i32) -> vec3<f32> {
	return vec3<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComZ))]);
}
fn BodyInvInertia(idx: i32) -> mat3x3f {
	return mat3x3f(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZX))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZY))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZZ))]);
}

//////// import: "contact.go"
alias ContactVars = i32; //enums:enum
const  ContactA: ContactVars = 0;
const  ContactB: ContactVars = 1;
const  ContactNormX: ContactVars = 2;
const  ContactNormY: ContactVars = 3;
const  ContactNormZ: ContactVars = 4;
const  ContactPointX: ContactVars = 5;
const  ContactPointY: ContactVars = 6;
const  ContactPointZ: ContactVars = 7;
const  ContactDist: ContactVars = 8;

//////// import: "control.go"
alias JointControlVars = i32; //enums:enum
const  JointCtrlForceX: JointControlVars = 0;
const  JointCtrlForceY: JointControlVars = 1;
const  JointCtrlForceZ: JointControlVars = 2;
const  JointCtrlTorqueX: JointControlVars = 3;
const  JointCtrlTorqueY: JointControlVars = 4;
const  JointCtrlTorqueZ: JointControlVars = 5;
const  JointTargetPosX: JointControlVars = 6;
const  JointTargetPosY: JointControlVars = 7;
const  JointTargetPosZ: JointControlVars = 8;
const  JointTargetRotX: JointControlVars = 9;
const  JointTargetRotY: JointControlVars = 10;
const  JointTargetRotZ: JointControlVars = 11;
const  JointTargetRotW: JointControlVars = 12;
const  JointTargetVelX: JointControlVars = 13;
const  JointTargetVelY: JointControlVars = 14;
const  JointTargetVelZ: JointControlVars = 15;
const  JointTargetAngVelX: JointControlVars = 16;
const  JointTargetAngVelY: JointControlVars = 17;
const  JointTargetAngVelZ: JointControlVars = 18;
fn JointTargetPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetPosX))], JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetPosY))], JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetPosZ))]);
}
fn JointTargetVel(idx: i32) -> vec3<f32> {
	return vec3<f32>(JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetVelX))], JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetVelY))], JointControls[Index2D(TensorStrides[50], TensorStrides[51], u32(idx), u32(JointTargetVelZ))]);
}

//////// import: "dynamics.go"
alias DynamicVars = i32; //enums:enum
const  DynIndex: DynamicVars = 0;
const  DynPosX: DynamicVars = 1;
const  DynPosY: DynamicVars = 2;
const  DynPosZ: DynamicVars = 3;
const  DynRotX: DynamicVars = 4;
const  DynRotY: DynamicVars = 5;
const  DynRotZ: DynamicVars = 6;
const  DynRotW: DynamicVars = 7;
const  DynVelX: DynamicVars = 8;
const  DynVelY: DynamicVars = 9;
const  DynVelZ: DynamicVars = 10;
const  DynAngVelX: DynamicVars = 11;
const  DynAngVelY: DynamicVars = 12;
const  DynAngVelZ: DynamicVars = 13;
const  DynAccX: DynamicVars = 14;
const  DynAccY: DynamicVars = 15;
const  DynAccZ: DynamicVars = 16;
const  DynAngAccX: DynamicVars = 17;
const  DynAngAccY: DynamicVars = 18;
const  DynAngAccZ: DynamicVars = 19;
const  DynForceX: DynamicVars = 20;
const  DynForceY: DynamicVars = 21;
const  DynForceZ: DynamicVars = 22;
const  DynTorqueX: DynamicVars = 23;
const  DynTorqueY: DynamicVars = 24;
const  DynTorqueZ: DynamicVars = 25;
const  DynDeltaX: DynamicVars = 26;
const  DynDeltaY: DynamicVars = 27;
const  DynDeltaZ: DynamicVars = 28;
const  DynAngDeltaX: DynamicVars = 29;
const  DynAngDeltaY: DynamicVars = 30;
const  DynAngDeltaZ: DynamicVars = 31;
fn DynamicIndex(idx: i32,cni: i32) -> i32 {
	return i32(bitcast<u32>(Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynIndex))]));
}
fn DynamicPos(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynPosX))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynPosY))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynPosZ))]);
}
fn DynamicRot(idx: i32,cni: i32) -> vec4<f32> {
	return vec4<f32>(Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynRotX))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynRotY))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynRotZ))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynRotW))]);
}
fn DynamicDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynDeltaX))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynDeltaY))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynDeltaZ))]);
}
fn DynamicAngDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynAngDeltaX))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynAngDeltaY))], Dynamics[Index3D(TensorStrides[30], TensorStrides[31], TensorStrides[32], u32(idx), u32(cni), u32(DynAngDeltaZ))]);
}

//////// import: "enumgen.go"
const BodyVarsN: BodyVars = 37;
const ContactVarsN: ContactVars = 9;
const JointControlVarsN: JointControlVars = 19;
const DynamicVarsN: DynamicVars = 32;
const GPUVarsN: GPUVars = 7;
const JointVarsN: JointVars = 53;
const JointTypesN: JointTypes = 7;
const ShapesN: Shapes = 4;

//////// import: "joint.go"
alias JointVars = i32; //enums:enum
const  JointType: JointVars = 0;
const  JointEnabled: JointVars = 1;
const  JointParent: JointVars = 2;
const  JointChild: JointVars = 3;
const  JointPPosX: JointVars = 4;
const  JointPPosY: JointVars = 5;
const  JointPPosZ: JointVars = 6;
const  JointPRotX: JointVars = 7;
const  JointPRotY: JointVars = 8;
const  JointPRotZ: JointVars = 9;
const  JointPRotW: JointVars = 10;
const  JointCPosX: JointVars = 11;
const  JointCPosY: JointVars = 12;
const  JointCPosZ: JointVars = 13;
const  JointCRotX: JointVars = 14;
const  JointCRotY: JointVars = 15;
const  JointCRotZ: JointVars = 16;
const  JointCRotW: JointVars = 17;
const  JointAxisX: JointVars = 18;
const  JointAxisY: JointVars = 19;
const  JointAxisZ: JointVars = 20;
const  JointLimitLower: JointVars = 21;
const  JointLimitUpper: JointVars = 22;
const  JointStiffX: JointVars = 23;
const  JointStiffY: JointVars = 24;
const  JointStiffZ: JointVars = 25;
const  JointDampX: JointVars = 26;
const  JointDampY: JointVars = 27;
const  JointDampZ: JointVars = 28;
const  JointPForceX: JointVars = 29;
const  JointPForceY: JointVars = 30;
const  JointPForceZ: JointVars = 31;
const  JointPTorqueX: JointVars = 32;
const  JointPTorqueY: JointVars = 33;
const  JointPTorqueZ: JointVars = 34;
const  JointCForceX: JointVars = 35;
const  JointCForceY: JointVars = 36;
const  JointCForceZ: JointVars = 37;
const  JointCTorqueX: JointVars = 38;
const  JointCTorqueY: JointVars = 39;
const  JointCTorqueZ: JointVars = 40;
const  JointPDeltaX: JointVars = 41;
const  JointPDeltaY: JointVars = 42;
const  JointPDeltaZ: JointVars = 43;
const  JointPAngDeltaX: JointVars = 44;
const  JointPAngDeltaY: JointVars = 45;
const  JointPAngDeltaZ: JointVars = 46;
const  JointCDeltaX: JointVars = 47;
const  JointCDeltaY: JointVars = 48;
const  JointCDeltaZ: JointVars = 49;
const  JointCAngDeltaX: JointVars = 50;
const  JointCAngDeltaY: JointVars = 51;
const  JointCAngDeltaZ: JointVars = 52;
fn GetJointType(idx: i32) -> JointTypes {
	return JointTypes(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointType))]));
}
fn JointParentIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointParent))]));
}
fn JointChildIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointChild))]));
}
fn JointPPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPPosZ))]);
}
fn JointPRot(idx: i32) -> vec4<f32> {
	return vec4<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPRotX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPRotY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPRotZ))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPRotW))]);
}
fn JointCPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCPosX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCPosY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCPosZ))]);
}
fn JointCRot(idx: i32) -> vec4<f32> {
	return vec4<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCRotX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCRotY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCRotZ))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCRotW))]);
}
fn JointAxis(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointAxisX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointAxisY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointAxisZ))]);
}
fn JointStiff(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointStiffX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointStiffY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointStiffZ))]);
}
fn JointDamp(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointDampX))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointDampY))], Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointDampZ))]);
}
fn SetJointPDelta(idx: i32, f: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPDeltaX))] = f.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPDeltaY))] = f.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPDeltaZ))] = f.z;
}
fn SetJointPAngDelta(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPAngDeltaX))] = t.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPAngDeltaY))] = t.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointPAngDeltaZ))] = t.z;
}
fn SetJointCDelta(idx: i32, f: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCDeltaX))] = f.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCDeltaY))] = f.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCDeltaZ))] = f.z;
}
fn SetJointCAngDelta(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCAngDeltaX))] = t.x;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCAngDeltaY))] = t.y;
	Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(idx), u32(JointCAngDeltaZ))] = t.z;
}
alias JointTypes = i32; //enums:enum
const  Prismatic: JointTypes = 0;
const  Revolute: JointTypes = 1;
const  Ball: JointTypes = 2;
const  Fixed: JointTypes = 3;
const  Free: JointTypes = 4;
const  Distance: JointTypes = 5;
const  D6: JointTypes = 6;

//////// import: "params.go"
struct PhysParams {
	DynamicsN: i32,
	JointsN: i32,
	Cur: i32,
	Next: i32,
	Iters: i32,
	Dt: f32,
	SoftRelax: f32,
	JointLinearRelax: f32,
	JointAngularRelax: f32,
	JointLinearComply: f32,
	JointAngularComply: f32,
	ContactRelax: f32,
	AngularDamping: f32,
	ContactWeighting: i32,
	Restitution: i32,
	pad: f32,
	Gravity: vec4<f32>,
}

//////// import: "shapes.go"
alias Shapes = i32; //enums:enum
const  Box: Shapes = 0;
const  Sphere: Shapes = 1;
const  Cylinder: Shapes = 2;
const  Capsule: Shapes = 3;

//////// import: "slmath-matrix3.go"

//////// import: "slmath-quaternion.go"
fn QuatLength(q: vec4<f32>) -> f32 {
	return sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
}
fn QuatNormalize(q: vec4<f32>) -> vec4<f32> {
	var nq: vec4<f32>;
	var l = QuatLength(q);
	if (l == 0) {
		nq.x = f32(0);
		nq.y = f32(0);
		nq.z = f32(0);
		nq.w = f32(1);
	} else {
		l = 1 / l;
		nq.x *= l;
		nq.y *= l;
		nq.z *= l;
		nq.w *= l;
	}return nq;
}
fn MulQuatVector(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = MulScalar3(Cross3(xyz, v), f32(f32(2)));return v+(MulScalar3(t, q.w))+(Cross3(xyz, t));
}
fn MulQuatVectorInverse(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = MulScalar3(Cross3(xyz, v), f32(f32(2)));return v-(MulScalar3(t, q.w))+(Cross3(xyz, t));
}
fn MulQuats(a: vec4<f32>,b: vec4<f32>) -> vec4<f32> {
	var q: vec4<f32>;
	q.x = a.x*b.w + a.w*b.x + a.y*b.z - a.z*b.y;
	q.y = a.y*b.w + a.w*b.y + a.z*b.x - a.x*b.z;
	q.z = a.z*b.w + a.w*b.z + a.x*b.y - a.y*b.x;
	q.w = a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z;return q;
}
fn MulQPTransforms(aP: vec3<f32>, aQ: vec4<f32>, bP: vec3<f32>, bQ: vec4<f32>, oP: ptr<function,vec3<f32>>, oQ: ptr<function,vec4<f32>>) {
	*oP = MulQuatVector(aQ, bP)+(aP);
	*oQ = MulQuats(aQ, bQ);
}
fn MulQPPoint(xP: vec3<f32>, xQ: vec4<f32>, p: vec3<f32>) -> vec3<f32> {
	var dp = MulQuatVector(xQ, p);return dp+(xP);
}
fn QPTransformInverse(p: vec3<f32>, q: vec4<f32>, oP: ptr<function,vec3<f32>>, oQ: ptr<function,vec4<f32>>) {
	var qi = QuatInverse(q);
	*oP = Negate3(MulQuatVector(qi, p));
	*oQ = qi;
}
fn QuatInverse(q: vec4<f32>) -> vec4<f32> {
	var nq = q;
	nq.x *= f32(-1);
	nq.y *= f32(-1);
	nq.z *= f32(-1);return QuatNormalize(nq);
}

//////// import: "slmath-vector3.go"
fn MulScalar3(v: vec3<f32>, s: f32) -> vec3<f32> {
	return vec3<f32>(v.x*s, v.y*s, v.z*s);
}
fn Negate3(v: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(-v.x, -v.y, -v.z);
}
fn LengthSquared3(v: vec3<f32>) -> f32 {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
fn Dot3(v: vec3<f32>,o: vec3<f32>) -> f32 {
	return v.x*o.x + v.y*o.y + v.z*o.z;
}
fn Max3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(max(v.x, o.x), max(v.y, o.y), max(v.z, o.z));
}
fn Min3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(min(v.x, o.x), min(v.y, o.y), min(v.z, o.z));
}
fn Abs3(v: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(abs(v.x), abs(v.y), abs(v.z));
}
fn Cross3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(v.y*o.z-v.z*o.y, v.z*o.x-v.x*o.z, v.x*o.y-v.y*o.x);
}

//////// import: "step.go"

//////// import: "step_body.go"

//////// import: "step_joint.go"
fn StepSolveJoints(i: u32) { //gosl:kernel
	let pars = Params[0];
	var ji = i32(i);
	if (ji >= pars.JointsN) {
		return;
	}
	var jpi = JointParentIndex(ji);
	var jpbi = DynamicIndex(jpi, pars.Cur);
	var jci = JointChildIndex(ji);
	var jcbi = DynamicIndex(jci, pars.Cur);
	var jt = GetJointType(ji);
	if (jt == Free) {
		return;
	}
	var jpP = JointPPos(ji);
	var jpQ = JointPRot(ji);
	var xwpP = jpP; // world xform, parent, pos
	var xwpQ = jpQ; // quat
	var mInvp = f32(0.0);
	var iInvp = mat3x3f(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	var posepP = jpP;
	var posepQ = jpQ;
	var comp: vec3<f32>;
	var
	velp: vec3<f32>;
	var omegap: vec3<f32>;
	if (jpi >= 0) {
		posepP = DynamicPos(jpi, pars.Next); // now using next
		posepQ = DynamicRot(jpi, pars.Next);
		MulQPTransforms(posepP, posepQ, jpP, jpQ, &xwpP, &xwpQ);
		comp = BodyCom(jpbi);
		mInvp = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(jpbi), u32(BodyInvMass))];
		iInvp = BodyInvInertia(jpbi);
		velp = DynamicDelta(jpi, pars.Next);
		omegap = DynamicAngDelta(jpi, pars.Next);
	}
	var posecP = DynamicPos(jci, pars.Next);
	var posecQ = DynamicRot(jci, pars.Next);
	var jcP = JointCPos(ji);
	var jcQ = JointCRot(ji);
	var xwcP = jcP;
	var xwcQ = jcQ;
	MulQPTransforms(posecP, posecQ, jcP, jcQ, &xwcP, &xwcQ);
	var comc = BodyCom(jcbi);
	var mInvc = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(jcbi), u32(BodyInvMass))];
	var iInvc = BodyInvInertia(jcbi);
	var velc = DynamicDelta(jci, pars.Next);
	var omegac = DynamicAngDelta(jci, pars.Next);
	if (mInvp == 0.0 && mInvc == 0.0) { // connection between two immovable bodies
		return;
	}
	var linDeltaP: vec3<f32>;
	var angDeltaP: vec3<f32>;
	var linDeltaC: vec3<f32>;
	var angDeltaC: vec3<f32>;
	var relPoseP = xwpP;
	var relPoseQ = xwpQ;
	QPTransformInverse(xwpP, xwpQ, &relPoseP, &relPoseQ);
	MulQPTransforms(relPoseP, relPoseQ, xwcP, xwcQ, &relPoseP, &relPoseQ);
	var xc = xwcP;
	var worldComp = MulQPPoint(posepP, posepQ, comp);
	var worldComc = MulQPPoint(posecP, posecQ, comc);
	_ = worldComc;
	if (jt == Distance) {
	} else { // compute joint target, stiffness, damping
		var axisLimitsD: vec3<f32>;
		var axisLimitsA: vec3<f32>;
		var axisTargetPosKeD: vec3<f32>;
		var axisTargetPosKeA: vec3<f32>;
		var axisTargetVelKdD: vec3<f32>;
		var axisTargetVelKdA: vec3<f32>;
		var axis = JointAxis(ji);
		var loTemp = axis*(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(ji), u32(JointLimitLower))]);
		var upTemp = axis*(Joints[Index2D(TensorStrides[10], TensorStrides[11], u32(ji), u32(JointLimitUpper))]);
		axisLimitsD = Min3(loTemp, upTemp);
		axisLimitsA = Max3(loTemp, upTemp);
		var ke = JointStiff(ji);
		var kd = JointDamp(ji);
		var targetPos = JointTargetPos(ji);
		var targetVel = JointTargetVel(ji);
		if (ke.x > 0.0) { // has position control
			UpdateJointAxisWeightedTarget(axis, targetPos.x, ke.x, &axisTargetPosKeD, &axisTargetPosKeA);
		}
		if (kd.x > 0.0) { // has velocity control
			UpdateJointAxisWeightedTarget(axis, targetVel.x, kd.x, &axisTargetVelKdD, &axisTargetVelKdA);
		}
		var axisStiffness = axisTargetPosKeA;
		var axisDamping = axisTargetVelKdA;
		if (axisStiffness.x > 0.0) { // todo: Dim(i) access
			axisTargetPosKeD.x /= axisStiffness.x;
		}
		if (axisDamping.x > 0.0) { // todo Dim
			axisTargetVelKdD.x /= axisDamping.x;
		}
		var axisLimitsLower = axisLimitsD;
		var axisLimitsUpper = axisLimitsA;
		var rp = xc-(worldComp);
		var rc = xc-(MulQPPoint(posecP, posecQ, comc));
		{
			var e = relPoseP.x; // rel_p[dim]
			var linearc = vec3<f32>(0, 0, 0);
			var linearp = Negate3(linearc);
			var angularp = Cross3(rp, linearc);
			var angularc = Cross3(rc, linearc);
			var derr = Dot3(linearp, velp) + Dot3(linearc, velc) + Dot3(angularp, omegap) + Dot3(angularc, omegac);
			var err = f32(0.0);
			var compliance = pars.JointLinearComply;
			var damping = f32(0.0);
			var targetVel = axisTargetVelKdD.x; // [dim]
			var derrRel = derr - targetVel;
			var lower = axisLimitsLower.x; // [dim]
			var upper = axisLimitsUpper.x; // [dim]
			if (e < lower) {
				err = e - lower;
			} else if (e > upper) {
				err = e - upper;
			} else {
				var targetPos = axisTargetPosKeD.x; // [dim]
				targetPos = clamp(targetPos, lower, upper);
				if (axisStiffness.x > 0.0) {
					err = e - targetPos;
					compliance = 1.0 / axisStiffness.x; // [dim]
					damping = axisDamping.x;            // [dim]
				} else if (axisDamping.x > 0.0) {
					compliance = 1.0 / axisDamping.x; // [dim]
					damping = axisDamping.x;          // [dim]
				}
			}
			if (abs(err) > 1e-9 || abs(derrRel) > 1e-9) {
				var lambdaIn = f32(0.0);
				var dLambda = PositionalCorrection(err, derrRel, posepQ, posecQ, mInvp, mInvc,
					iInvp, iInvc, linearp, linearc, angularp, angularc, lambdaIn, compliance, damping, pars.Dt);
				linDeltaP = linDeltaP+(linearp*(dLambda * pars.JointLinearRelax));
				angDeltaP = angDeltaP+(angularp*(dLambda * pars.JointAngularRelax));
				linDeltaC = linDeltaC+(linearc*(dLambda * pars.JointLinearRelax));
				angDeltaC = angDeltaC+(angularc*(dLambda * pars.JointAngularRelax));
			}
		}
	}
	SetJointPDelta(ji, linDeltaP);
	SetJointPAngDelta(ji, angDeltaP);
	SetJointCDelta(ji, linDeltaC);
	SetJointCAngDelta(ji, angDeltaC);
}
fn UpdateJointAxisWeightedTarget(axis: vec3<f32>, targ: f32,weight: f32, axisTargets: ptr<function,vec3<f32>>,axisWeights: ptr<function,vec3<f32>>) {
	var weightedAxis = axis*(weight);
	*axisTargets = (*axisTargets)+(weightedAxis*(targ)); // weighted target (to be normalized later by sum of weights)
	*axisWeights = (*axisWeights)+(Abs3(weightedAxis));
}
fn PositionalCorrection(err: f32,derr: f32, tfaQ: vec4<f32>,tfbQ: vec4<f32>, mInva: f32,mInvb: f32, Iinva: mat3x3f,Iinvb: mat3x3f, lineara: vec3<f32>,linearb: vec3<f32>,angulara: vec3<f32>,angularb: vec3<f32>, lambdaIn: f32,compliance: f32,damping: f32,dt: f32) -> f32 {
	var denom = f32(0.0);
	denom += LengthSquared3(lineara) * mInva;
	denom += LengthSquared3(linearb) * mInvb;
	var q1 = tfaQ;
	var q2 = tfbQ;
	var rotAngulara = MulQuatVectorInverse(q1, angulara);
	var rotAngularb = MulQuatVectorInverse(q2, angularb);
	denom += Dot3(rotAngulara, Iinva*(rotAngulara));
	denom += Dot3(rotAngularb, Iinvb*(rotAngularb));
	var alpha = compliance;
	var gamma = compliance * damping;
	var deltaLambda = -(err + alpha*lambdaIn + gamma*derr);
	if (denom+alpha > 0.0) {
		deltaLambda /= (dt+gamma)*denom + alpha/dt;
	}return deltaLambda;
}