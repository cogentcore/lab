// Code generated by "gosl"; DO NOT EDIT
// kernel: StepSolveJoints

// // Params are global parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read_write> Params: array<PhysicsParams>;
// // Bodies are the rigid body elements (dynamic and static), // specifying the constant, non-dynamic properties, // which is initial state for dynamics. // [body][BodyVarsN] 
@group(1) @binding(0)
var<storage, read_write> Bodies: array<f32>;
@group(1) @binding(1)
var<storage, read_write> Objects: array<i32>;
@group(1) @binding(3)
var<storage, read_write> Joints: array<f32>;
@group(1) @binding(4)
var<storage, read_write> JointDoFs: array<f32>;
// // Dynamics are the dynamic rigid body elements: these actually move. // Two alternating states are used: Params.Cur and Params.Next. // [dyn body][cur/next][DynamicVarsN] 
@group(2) @binding(0)
var<storage, read_write> Dynamics: array<f32>;
// // JointControls are dynamic joint control inputs, per joint DoF // (in correspondence with [JointDoFs]). This can be uploaded to the // GPU at every step. // [dof][JointControlVarsN] 
@group(3) @binding(0)
var<storage, read_write> JointControls: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	StepSolveJoints(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}

fn Index3D(s0: u32, s1: u32, s2: u32, i0: u32, i1: u32, i2: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2;
}


//////// import: "vars.go"

//////// import: "body.go"
alias BodyVars = i32; //enums:enum
const  BodyShape: BodyVars = 0;
const  BodyDynamic: BodyVars = 1;
const  BodyWorld: BodyVars = 2;
const  BodyGroup: BodyVars = 3;
const  BodyHSizeX: BodyVars = 4;
const  BodyHSizeY: BodyVars = 5;
const  BodyHSizeZ: BodyVars = 6;
const  BodyThick: BodyVars = 7;
const  BodyMass: BodyVars = 8;
const  BodyInvMass: BodyVars = 9;
const  BodyBounce: BodyVars = 10;
const  BodyFriction: BodyVars = 11;
const  BodyFrictionTortion: BodyVars = 12;
const  BodyFrictionRolling: BodyVars = 13;
const  BodyPosX: BodyVars = 14;
const  BodyPosY: BodyVars = 15;
const  BodyPosZ: BodyVars = 16;
const  BodyQuatX: BodyVars = 17;
const  BodyQuatY: BodyVars = 18;
const  BodyQuatZ: BodyVars = 19;
const  BodyQuatW: BodyVars = 20;
const  BodyComX: BodyVars = 21;
const  BodyComY: BodyVars = 22;
const  BodyComZ: BodyVars = 23;
const  BodyInertiaXX: BodyVars = 24;
const  BodyInertiaYX: BodyVars = 25;
const  BodyInertiaZX: BodyVars = 26;
const  BodyInertiaXY: BodyVars = 27;
const  BodyInertiaYY: BodyVars = 28;
const  BodyInertiaZY: BodyVars = 29;
const  BodyInertiaXZ: BodyVars = 30;
const  BodyInertiaYZ: BodyVars = 31;
const  BodyInertiaZZ: BodyVars = 32;
const  BodyInvInertiaXX: BodyVars = 33;
const  BodyInvInertiaYX: BodyVars = 34;
const  BodyInvInertiaZX: BodyVars = 35;
const  BodyInvInertiaXY: BodyVars = 36;
const  BodyInvInertiaYY: BodyVars = 37;
const  BodyInvInertiaZY: BodyVars = 38;
const  BodyInvInertiaXZ: BodyVars = 39;
const  BodyInvInertiaYZ: BodyVars = 40;
const  BodyInvInertiaZZ: BodyVars = 41;
const  BodyRadius: BodyVars = 42;
fn BodyCom(idx: i32) -> vec3<f32> {
	return vec3<f32>(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyComZ))]);
}
fn BodyInertia(idx: i32) -> mat3x3f {
	return mat3x3f(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaXX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaYX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaZX))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaXY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaYY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaZY))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaXZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaYZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInertiaZZ))]);
}
fn BodyInvInertia(idx: i32) -> mat3x3f {
	return mat3x3f(Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYX))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZX))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYY))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZY))],
		Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaXZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaYZ))], Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(idx), u32(BodyInvInertiaZZ))]);
}

//////// import: "contact.go"
alias ContactVars = i32; //enums:enum
const  ContactA: ContactVars = 0;
const  ContactB: ContactVars = 1;
const  ContactPointIdx: ContactVars = 2;
const  ContactAPointX: ContactVars = 3;
const  ContactAPointY: ContactVars = 4;
const  ContactAPointZ: ContactVars = 5;
const  ContactBPointX: ContactVars = 6;
const  ContactBPointY: ContactVars = 7;
const  ContactBPointZ: ContactVars = 8;
const  ContactAOffX: ContactVars = 9;
const  ContactAOffY: ContactVars = 10;
const  ContactAOffZ: ContactVars = 11;
const  ContactBOffX: ContactVars = 12;
const  ContactBOffY: ContactVars = 13;
const  ContactBOffZ: ContactVars = 14;
const  ContactAThick: ContactVars = 15;
const  ContactBThick: ContactVars = 16;
const  ContactNormX: ContactVars = 17;
const  ContactNormY: ContactVars = 18;
const  ContactNormZ: ContactVars = 19;
const  ContactWeight: ContactVars = 20;
const  ContactADeltaX: ContactVars = 21;
const  ContactADeltaY: ContactVars = 22;
const  ContactADeltaZ: ContactVars = 23;
const  ContactAAngDeltaX: ContactVars = 24;
const  ContactAAngDeltaY: ContactVars = 25;
const  ContactAAngDeltaZ: ContactVars = 26;
const  ContactBDeltaX: ContactVars = 27;
const  ContactBDeltaY: ContactVars = 28;
const  ContactBDeltaZ: ContactVars = 29;
const  ContactBAngDeltaX: ContactVars = 30;
const  ContactBAngDeltaY: ContactVars = 31;
const  ContactBAngDeltaZ: ContactVars = 32;
const BroadContactVarsN = ContactAPointX;

//////// import: "control.go"
alias JointControlVars = i32; //enums:enum
const  JointControlForce: JointControlVars = 0;
const  JointTargetPos: JointControlVars = 1;
const  JointTargetPosCur: JointControlVars = 2;
const  JointTargetStiff: JointControlVars = 3;
const  JointTargetVel: JointControlVars = 4;
const  JointTargetDamp: JointControlVars = 5;
fn JointControl(idx: i32,dof: i32, vr: JointControlVars) -> f32 {
	return JointControls[Index2D(TensorStrides[110], TensorStrides[111], u32(JointDoFIndex(idx, dof)), u32(vr))];
}

//////// import: "dynamics.go"
alias DynamicVars = i32; //enums:enum
const  DynBody: DynamicVars = 0;
const  DynPosX: DynamicVars = 1;
const  DynPosY: DynamicVars = 2;
const  DynPosZ: DynamicVars = 3;
const  DynQuatX: DynamicVars = 4;
const  DynQuatY: DynamicVars = 5;
const  DynQuatZ: DynamicVars = 6;
const  DynQuatW: DynamicVars = 7;
const  DynVelX: DynamicVars = 8;
const  DynVelY: DynamicVars = 9;
const  DynVelZ: DynamicVars = 10;
const  DynAngVelX: DynamicVars = 11;
const  DynAngVelY: DynamicVars = 12;
const  DynAngVelZ: DynamicVars = 13;
const  DynAccX: DynamicVars = 14;
const  DynAccY: DynamicVars = 15;
const  DynAccZ: DynamicVars = 16;
const  DynAngAccX: DynamicVars = 17;
const  DynAngAccY: DynamicVars = 18;
const  DynAngAccZ: DynamicVars = 19;
const  DynForceX: DynamicVars = 20;
const  DynForceY: DynamicVars = 21;
const  DynForceZ: DynamicVars = 22;
const  DynTorqueX: DynamicVars = 23;
const  DynTorqueY: DynamicVars = 24;
const  DynTorqueZ: DynamicVars = 25;
const  DynDeltaX: DynamicVars = 26;
const  DynDeltaY: DynamicVars = 27;
const  DynDeltaZ: DynamicVars = 28;
const  DynAngDeltaX: DynamicVars = 29;
const  DynAngDeltaY: DynamicVars = 30;
const  DynAngDeltaZ: DynamicVars = 31;
const  DynContactWeight: DynamicVars = 32;
fn DynamicBody(idx: i32) -> i32 { return i32(bitcast<u32>(Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(0), u32(DynBody))])); }
fn DynamicPos(idx: i32,cni: i32) -> vec3<f32> { return vec3<f32>(Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosX))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosY))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosZ))]); }
fn SetDynamicPos(idx: i32,cni: i32, pos: vec3<f32>) { Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosX))] = pos.x;; Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosY))] = pos.y;; Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynPosZ))] = pos.z; }
fn DynamicQuat(idx: i32,cni: i32) -> vec4<f32> { return vec4<f32>(Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatX))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatY))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatZ))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatW))]); }
fn SetDynamicQuat(idx: i32,cni: i32, rot: vec4<f32>) { Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatX))] = rot.x;; Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatY))] = rot.y;; Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatZ))] = rot.z;; Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynQuatW))] = rot.w; }
fn DynamicDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaX))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaY))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaZ))]);
}
fn SetDynamicDelta(idx: i32,cni: i32, delta: vec3<f32>) {
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaX))] = delta.x;
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaY))] = delta.y;
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynDeltaZ))] = delta.z;
}
fn DynamicAngDelta(idx: i32,cni: i32) -> vec3<f32> {
	return vec3<f32>(Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaX))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaY))], Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaZ))]);
}
fn SetDynamicAngDelta(idx: i32,cni: i32, angDelta: vec3<f32>) {
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaX))] = angDelta.x;
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaY))] = angDelta.y;
	Dynamics[Index3D(TensorStrides[60], TensorStrides[61], TensorStrides[62], u32(idx), u32(cni), u32(DynAngDeltaZ))] = angDelta.z;
}

//////// import: "enumgen.go"
const BodyVarsN: BodyVars = 43;
const ContactVarsN: ContactVars = 33;
const JointControlVarsN: JointControlVars = 6;
const DynamicVarsN: DynamicVars = 33;
const GPUVarsN: GPUVars = 13;
const JointTypesN: JointTypes = 8;
const JointVarsN: JointVars = 45;
const JointDoFVarsN: JointDoFVars = 5;
const ShapesN: Shapes = 6;

//////// import: "joint.go"
const JointLimitUnlimited = 1e10;
alias JointTypes = i32; //enums:enum
const  Prismatic: JointTypes = 0;
const  Revolute: JointTypes = 1;
const  Ball: JointTypes = 2;
const  Fixed: JointTypes = 3;
const  Free: JointTypes = 4;
const  Distance: JointTypes = 5;
const  D6: JointTypes = 6;
const  PlaneXZ: JointTypes = 7;
alias JointVars = i32; //enums:enum
const  JointType: JointVars = 0;
const  JointEnabled: JointVars = 1;
const  JointParentFixed: JointVars = 2;
const  JointParent: JointVars = 3;
const  JointChild: JointVars = 4;
const  JointPPosX: JointVars = 5;
const  JointPPosY: JointVars = 6;
const  JointPPosZ: JointVars = 7;
const  JointPQuatX: JointVars = 8;
const  JointPQuatY: JointVars = 9;
const  JointPQuatZ: JointVars = 10;
const  JointPQuatW: JointVars = 11;
const  JointCPosX: JointVars = 12;
const  JointCPosY: JointVars = 13;
const  JointCPosZ: JointVars = 14;
const  JointCQuatX: JointVars = 15;
const  JointCQuatY: JointVars = 16;
const  JointCQuatZ: JointVars = 17;
const  JointCQuatW: JointVars = 18;
const  JointLinearDoFN: JointVars = 19;
const  JointAngularDoFN: JointVars = 20;
const  JointDoF1: JointVars = 21;
const  JointDoF2: JointVars = 22;
const  JointDoF3: JointVars = 23;
const  JointDoF4: JointVars = 24;
const  JointDoF5: JointVars = 25;
const  JointDoF6: JointVars = 26;
const  JointPForceX: JointVars = 27;
const  JointPForceY: JointVars = 28;
const  JointPForceZ: JointVars = 29;
const  JointPTorqueX: JointVars = 30;
const  JointPTorqueY: JointVars = 31;
const  JointPTorqueZ: JointVars = 32;
const  JointCForceX: JointVars = 33;
const  JointCForceY: JointVars = 34;
const  JointCForceZ: JointVars = 35;
const  JointCTorqueX: JointVars = 36;
const  JointCTorqueY: JointVars = 37;
const  JointCTorqueZ: JointVars = 38;
const  JointLinLambdaX: JointVars = 39;
const  JointLinLambdaY: JointVars = 40;
const  JointLinLambdaZ: JointVars = 41;
const  JointAngLambdaX: JointVars = 42;
const  JointAngLambdaY: JointVars = 43;
const  JointAngLambdaZ: JointVars = 44;
fn GetJointType(idx: i32) -> JointTypes {
	return JointTypes(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointType))]));
}
fn GetJointEnabled(idx: i32) -> bool {
	var je = bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointEnabled))]);
return je != 0;
}
fn GetJointParentFixed(idx: i32) -> bool {
	var je = bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointParentFixed))]);
return je != 0;
}
fn JointParentIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointParent))]));
}
fn JointChildIndex(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointChild))]));
}
fn GetJointLinearDoFN(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinearDoFN))]));
}
fn GetJointAngularDoFN(idx: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngularDoFN))]));
}
fn JointDoFIndex(idx: i32,dof: i32) -> i32 {
	return i32(bitcast<u32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(i32(JointDoF1) + dof))]));
}
fn JointPPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPPosX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPPosY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPPosZ))]);
}
fn JointPQuat(idx: i32) -> vec4<f32> {
	return vec4<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPQuatX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPQuatY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPQuatZ))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointPQuatW))]);
}
fn JointCPos(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCPosX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCPosY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCPosZ))]);
}
fn JointCQuat(idx: i32) -> vec4<f32> {
	return vec4<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCQuatX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCQuatY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCQuatZ))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointCQuatW))]);
}
fn JointLinLambda(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaZ))]);
}
fn SetJointLinLambda(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaX))] = t.x;
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaY))] = t.y;
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointLinLambdaZ))] = t.z;
}
fn JointAngLambda(idx: i32) -> vec3<f32> {
	return vec3<f32>(Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaX))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaY))], Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaZ))]);
}
fn SetJointAngLambda(idx: i32, t: vec3<f32>) {
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaX))] = t.x;
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaY))] = t.y;
	Joints[Index2D(TensorStrides[30], TensorStrides[31], u32(idx), u32(JointAngLambdaZ))] = t.z;
}
alias JointDoFVars = i32; //enums:enum
const  JointAxisX: JointDoFVars = 0;
const  JointAxisY: JointDoFVars = 1;
const  JointAxisZ: JointDoFVars = 2;
const  JointLimitLower: JointDoFVars = 3;
const  JointLimitUpper: JointDoFVars = 4;
fn JointAxisDoF(didx: i32) -> vec3<f32> {
	return vec3<f32>(JointDoFs[Index2D(TensorStrides[40], TensorStrides[41], u32(didx), u32(JointAxisX))], JointDoFs[Index2D(TensorStrides[40], TensorStrides[41], u32(didx), u32(JointAxisY))], JointDoFs[Index2D(TensorStrides[40], TensorStrides[41], u32(didx), u32(JointAxisZ))]);
}
fn JointAxis(idx: i32,dof: i32) -> vec3<f32> {
	return JointAxisDoF(JointDoFIndex(idx, dof));
}
fn JointDoF(idx: i32,dof: i32, vr: JointDoFVars) -> f32 {
	return JointDoFs[Index2D(TensorStrides[40], TensorStrides[41], u32(JointDoFIndex(idx, dof)), u32(vr))];
}

//////// import: "params.go"
struct PhysicsParams {
	Iterations: i32,
	Dt: f32,
	SubSteps: i32,
	ControlDt: f32,
	ContactMargin: f32,
	ContactRelax: f32, // 0.8 def
	ContactWeighting: i32, // true
	Restitution: i32, // false
	JointLinearRelax: f32, // 0.7 def
	JointAngularRelax: f32, // 0.4 def
	JointLinearComply: f32, // 0 def
	JointAngularComply: f32, // 0 def
	AngularDamping: f32, // 0 def
	SoftRelax: f32,
	MaxForce: f32,
	MaxDelta: f32,
	MaxGeomIter: i32,
	ContactsMax: i32,
	Cur: i32,
	Next: i32,
	BodiesN: i32,
	DynamicsN: i32,
	ObjectsN: i32,
	MaxObjectJoints: i32,
	JointsN: i32,
	JointDoFsN: i32,
	BodyJointsMax: i32,
	BodyCollidePairsN: i32,
	Gravity: vec4<f32>,
}

//////// import: "shapecollide.go"
struct GeomData {
	BodyIdx: i32,
	Shape: Shapes,
	MinSize: f32,
	Thick: f32,
	Radius: f32,
	Size: vec3<f32>,
	WbR: vec3<f32>,
	WbQ: vec4<f32>,
	BwR: vec3<f32>,
	BwQ: vec4<f32>,
}

//////// import: "shapegeom.go"

//////// import: "shapes.go"
alias Shapes = i32; //enums:enum
const  Plane: Shapes = 0;
const  Sphere: Shapes = 1;
const  Capsule: Shapes = 2;
const  Cylinder: Shapes = 3;
const  Box: Shapes = 4;
const  Cone: Shapes = 5;

//////// import: "slmath-math.go"
const Pi = 3.141592653589793;
fn MinAngleDiff(a: f32,b: f32) -> f32 {
	var d = a - b;
	if (d > Pi) {
		d -= 2 * Pi;
	}
	if (d < -Pi) {
		d += 2 * Pi;
	}return d;
}

//////// import: "slmath-matrix3.go"

//////// import: "slmath-quaternion.go"
fn QuatLength(q: vec4<f32>) -> f32 {
	return sqrt(q.x*q.x + q.y*q.y + q.z*q.z + q.w*q.w);
}
fn QuatNormalize(q: vec4<f32>) -> vec4<f32> {
	var nq = q;
	var l = QuatLength(q);
	if (l == 0) {
		nq.x = f32(0);
		nq.y = f32(0);
		nq.z = f32(0);
		nq.w = f32(1);
	} else {
		l = 1 / l;
		nq.x *= l;
		nq.y *= l;
		nq.z *= l;
		nq.w *= l;
	}return nq;
}
fn MulQuatVector(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = Cross3(xyz, v)*(2);
return v+(t*(q.w))+(Cross3(xyz, t));
}
fn MulQuatVectorInverse(q: vec4<f32>, v: vec3<f32>) -> vec3<f32> {
	var xyz = vec3<f32>(q.x, q.y, q.z);
	var t = Cross3(xyz, v)*(2);
return v-(t*(q.w))+(Cross3(xyz, t));
}
fn MulQuats(a: vec4<f32>,b: vec4<f32>) -> vec4<f32> {
	var q: vec4<f32>;
	q.x = a.x*b.w + a.w*b.x + a.y*b.z - a.z*b.y;
	q.y = a.y*b.w + a.w*b.y + a.z*b.x - a.x*b.z;
	q.z = a.z*b.w + a.w*b.z + a.x*b.y - a.y*b.x;
	q.w = a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z;
return q;
}
fn MulSpatialTransforms(aP: vec3<f32>, aQ: vec4<f32>, bP: vec3<f32>, bQ: vec4<f32>, oP: ptr<function,vec3<f32>>, oQ: ptr<function,vec4<f32>>) {
	*oP = MulQuatVector(aQ, bP)+(aP);
	*oQ = MulQuats(aQ, bQ);
}
fn MulSpatialPoint(xP: vec3<f32>, xQ: vec4<f32>, p: vec3<f32>) -> vec3<f32> {
	var dp = MulQuatVector(xQ, p);
return dp+(xP);
}
fn SpatialTransformInverse(p: vec3<f32>, q: vec4<f32>, oP: ptr<function,vec3<f32>>, oQ: ptr<function,vec4<f32>>) {
	var qi = QuatInverse(q);
	*oP = Negate3(MulQuatVector(qi, p));
	*oQ = qi;
}
fn QuatInverse(q: vec4<f32>) -> vec4<f32> {
	var nq = q;
	nq.x *= f32(-1);
	nq.y *= f32(-1);
	nq.z *= f32(-1);
return QuatNormalize(nq);
}
fn QuatDot(q: vec4<f32>,o: vec4<f32>) -> f32 {
	return q.x*o.x + q.y*o.y + q.z*o.z + q.w*o.w;
}
fn QuatMulScalar(q: vec4<f32>, s: f32) -> vec4<f32> {
	var nq = q;
	nq.x *= s;
	nq.y *= s;
	nq.z *= s;
	nq.w *= s;
return nq;
}

//////// import: "slmath-vector2.go"

//////// import: "slmath-vector3.go"
fn DivSafe3(v: vec3<f32>, o: vec3<f32>) -> vec3<f32> {
	var nv = v;
	if (o.x != 0) {
		nv.x /= o.x;
	}
	if (o.y != 0) {
		nv.y /= o.y;
	}
	if (o.z != 0) {
		nv.z /= o.z;
	}return nv;
}
fn Negate3(v: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(-v.x, -v.y, -v.z);
}
fn Length3(v: vec3<f32>) -> f32 {
	return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}
fn LengthSquared3(v: vec3<f32>) -> f32 {
	return v.x*v.x + v.y*v.y + v.z*v.z;
}
fn Dot3(v: vec3<f32>,o: vec3<f32>) -> f32 {
	return v.x*o.x + v.y*o.y + v.z*o.z;
}
fn Max3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(max(v.x, o.x), max(v.y, o.y), max(v.z, o.z));
}
fn Min3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(min(v.x, o.x), min(v.y, o.y), min(v.z, o.z));
}
fn Abs3(v: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(abs(v.x), abs(v.y), abs(v.z));
}
fn Normal3(v: vec3<f32>) -> vec3<f32> {
	return v/(Length3(v));
}
fn Cross3(v: vec3<f32>,o: vec3<f32>) -> vec3<f32> {
	return vec3<f32>(v.y*o.z-v.z*o.y, v.z*o.x-v.x*o.z, v.x*o.y-v.y*o.x);
}
fn Dim3(v: vec3<f32>, dim: i32) -> f32 {
	if (dim == 0) {
		return v.x;
	}
	if (dim == 1) {
		return v.y;
	}return v.z;
}
fn SetDim3(v: vec3<f32>, dim: i32, val: f32) -> vec3<f32> {
	var nv = v;
	if (dim == 0) {
		nv.x = val;
	}
	if (dim == 1) {
		nv.y = val;
	}
	if (dim == 2) {
		nv.z = val;
	}return nv;
}

//////// import: "step.go"

//////// import: "step_body.go"
fn StepBodyDeltas(di: i32,bi: i32, contacts: bool, cWt: f32, linDel: vec3<f32>,angDel: vec3<f32>) {
	var params = Params[0];
	var invMass = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(bi), u32(BodyInvMass))];
	var inertia = BodyInertia(bi);
	var invInertia = BodyInvInertia(bi);
	var r0 = DynamicPos(di, params.Next);
	var q0 = DynamicQuat(di, params.Next);
	var v0 = DynamicDelta(di, params.Next);
	var w0 = DynamicAngDelta(di, params.Next);
	var weight = f32(1.0);
	if (contacts && params.ContactWeighting == 1) {
		if (cWt > 0) {
			weight = 1.0 / cWt;
		}
	}
	var dp = linDel*(invMass * weight);
	var dq = angDel*(weight);
	dp = LimitDelta(dp, params.MaxDelta);
	dq = LimitDelta(dq, params.MaxDelta);
	var wb = MulQuatVectorInverse(q0, w0);
	var dwb = invInertia*(MulQuatVectorInverse(q0, dq));
	var tb = Cross3(dwb, inertia*(wb+(dwb)))+(Cross3(wb, inertia*(dwb)));
	var dw1 = MulQuatVector(q0, dwb-(invInertia*(tb)*(params.Dt)));
	var q1 = q0+(MulQuats(vec4<f32>(dw1.x, dw1.y, dw1.z, 0), q0)*(0.5 * params.Dt));
	q1 = QuatNormalize(q1);
	var com = BodyCom(bi);
	var pcom = MulQuatVector(q0, com)+(r0);
	var p1 = pcom+(dp*(params.Dt));
	p1 = p1-(MulQuatVector(q1, com));
	var v1 = v0+(dp);
	var w1 = w0+(dw1);
	if (Length3(v1) < 1e-4) {
		v1 = vec3<f32>(0, 0, 0);
	}
	if (Length3(w1) < 1e-4) {
		w1 = vec3<f32>(0, 0, 0);
	}
	SetDynamicPos(di, params.Next, p1);
	SetDynamicQuat(di, params.Next, q1);
	SetDynamicDelta(di, params.Next, v1);
	SetDynamicAngDelta(di, params.Next, w1);
	Params[0] = params;
}
fn LimitDelta(v: vec3<f32>, lim: f32) -> vec3<f32> {
	var l = Length3(v);
	if (l < lim) {
		return v;
	}return v*((lim / l));
}

//////// import: "step_joint.go"
fn StepSolveJoints(i: u32) { //gosl:kernel
	var params = Params[0];
	var oi = i32(i);
	if (oi >= params.ObjectsN) {
		return;
	}
	var n = Objects[Index2D(TensorStrides[10], TensorStrides[11], u32(oi), u32(0))];
	for (var i = i32(1);
	 i < n+1; i++) {
		var ji = Objects[Index2D(TensorStrides[10], TensorStrides[11], u32(oi), u32(i))];
		var jt = GetJointType(ji);
		if (jt == Free || !GetJointEnabled(ji)) {
			continue;
		}
		StepSolveJoint(ji);
	}
	Params[0] = params;
}
fn StepSolveJoint(ji: i32) {
	var params = Params[0];
	var jt = GetJointType(ji);
	var jPi = JointParentIndex(ji);
	var jPbi = i32(-1);
	var parentFixed = true;
	if (jPi >= 0) {
		jPbi = DynamicBody(jPi);
		parentFixed = GetJointParentFixed(ji);
	}
	var jCi = JointChildIndex(ji);
	var jCbi = DynamicBody(jCi);
	var jLinearN = GetJointLinearDoFN(ji);
	var jPR = JointPPos(ji);
	var jPQ = JointPQuat(ji);
	var xwPR = jPR; // world xform, parent, pos
	var xwPQ = jPQ; // quat
	var mInvP = f32(0.0);
	var iInvP = mat3x3f(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
	var posePR = jPR;
	var posePQ = jPQ;
	var comP: vec3<f32>;
	var
	vP: vec3<f32>;
	var wP: vec3<f32>;
	if (jPi >= 0) {
		posePR = DynamicPos(jPi, params.Next); // now using next
		posePQ = DynamicQuat(jPi, params.Next);
		MulSpatialTransforms(posePR, posePQ, jPR, jPQ, &xwPR, &xwPQ);
		comP = BodyCom(jPbi);
		mInvP = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(jPbi), u32(BodyInvMass))];
		iInvP = BodyInvInertia(jPbi);
		vP = DynamicDelta(jPi, params.Next);
		wP = DynamicAngDelta(jPi, params.Next);
		if (mInvP == 0) {
			parentFixed = true;
		}
	}
	var poseCR = DynamicPos(jCi, params.Next);
	var poseCQ = DynamicQuat(jCi, params.Next);
	var jCR = JointCPos(ji);
	var jCQ = JointCQuat(ji);
	var xwCR = jCR;
	var xwCQ = jCQ;
	MulSpatialTransforms(poseCR, poseCQ, jCR, jCQ, &xwCR, &xwCQ);
	var comC = BodyCom(jCbi);
	var mInvC = Bodies[Index2D(TensorStrides[0], TensorStrides[1], u32(jCbi), u32(BodyInvMass))];
	var iInvC = BodyInvInertia(jCbi);
	var vC = DynamicDelta(jCi, params.Next);
	var wC = DynamicAngDelta(jCi, params.Next);
	if (mInvP == 0.0 && mInvC == 0.0) { // connection between two immovable bodies
		return;
	}
	var linDeltaP: vec3<f32>;
	var angDeltaP: vec3<f32>;
	var linDeltaC: vec3<f32>;
	var angDeltaC: vec3<f32>;
	var relPoseR = xwPR;
	var relPoseQ = xwPQ;
	SpatialTransformInverse(xwPR, xwPQ, &relPoseR, &relPoseQ);
	MulSpatialTransforms(relPoseR, relPoseQ, xwCR, xwCQ, &relPoseR, &relPoseQ);
	var wComP = MulSpatialPoint(posePR, posePQ, comP);
	var wComC = MulSpatialPoint(poseCR, poseCQ, comC);
	var lambdaPrev = JointLinLambda(ji);
	var lambdaNext = vec3<f32>(0, 0, 0);
	if (jt == Distance) {
		var dP = xwPR-(wComP);
		var dC = xwCR-(wComC);
		var lo = JointDoF(ji, i32(i32(0)), JointLimitLower); // only first one has constraint
		var up = JointDoF(ji, i32(i32(0)), JointLimitUpper);
		if (lo < 0 && up < 0) { // not limited
			return;
		}
		var d = Length3(relPoseR);
		var err = f32(0.0);
		if (lo >= 0.0 && d < lo) {
			err = d - lo;
			relPoseR = Normal3(wComC-(wComP))*(err);
		} else if (up >= 0.0 && d > up) {
			err = d - up;
		}
		if (abs(err) > 1e-9) {
			var linearC = relPoseR;
			var linearP = Negate3(linearC);
			dC = xwCR-(wComC);
			var angularP = Negate3(Cross3(dP, linearC));
			var angularC = Cross3(dC, linearC);
			var derr = Dot3(linearP, vP) + Dot3(linearC, vC) + Dot3(angularP, wP) + Dot3(angularC, wC);
			var lambdaIn = f32(0.0); // note: multiple iter is supposed to increment these
			var compliance = params.JointLinearComply;
			var ke = JointControl(ji, i32(i32(0)), JointTargetStiff);
			var kd = JointControl(ji, i32(i32(0)), JointTargetDamp);
			if (ke > 0.0) {
				compliance = 1.0 / ke;
			}
			var dLambda = PositionalCorrection(err, derr, posePQ, poseCQ, mInvP, mInvC,
				iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, kd, params.Dt);
			linDeltaP = linDeltaP+(linearP*(dLambda * params.JointLinearRelax));
			angDeltaP = angDeltaP+(angularP*(dLambda * params.JointAngularRelax));
			linDeltaC = linDeltaC+(linearC*(dLambda * params.JointLinearRelax));
			angDeltaC = angDeltaC+(angularC*(dLambda * params.JointAngularRelax));
		}
	} else {
		var axisLimitsD: vec3<f32>;
		var axisLimitsA: vec3<f32>;
		var axisTargetPosKeD: vec3<f32>;
		var axisTargetPosKeA: vec3<f32>;
		var axisTargetVelKdD: vec3<f32>;
		var axisTargetVelKdA: vec3<f32>;
		for (var dof=0; dof<jLinearN; dof++) {
			var axis = JointAxis(ji, dof);
			JointAxisLimitsUpdate(dof, axis, JointDoF(ji, dof, JointLimitLower), JointDoF(ji, dof, JointLimitUpper), &axisLimitsD, &axisLimitsA);
			var ke = JointControl(ji, dof, JointTargetStiff);
			var kd = JointControl(ji, dof, JointTargetDamp);
			var targetPos = JointControl(ji, dof, JointTargetPosCur);
			var targetVel = JointControl(ji, dof, JointTargetVel);
			if (ke > 0.0) { // has position control
				JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA);
			}
			if (kd > 0.0) { // has velocity control
				JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA);
			}
		}
		var axisStiffness = axisTargetPosKeA;
		var axisDamping = axisTargetVelKdA;
		axisTargetPosKeD = DivSafe3(axisTargetPosKeD, axisStiffness);
		axisTargetVelKdD = DivSafe3(axisTargetVelKdD, axisDamping);
		var axisLimitsLower = axisLimitsD;
		var axisLimitsUpper = axisLimitsA;
		var dP = xwCR-(wComP);
		var dC = xwCR-(MulSpatialPoint(poseCR, poseCQ, comC));
		for (var dim=0; dim<i32(3); dim++) {
			var e = Dim3(relPoseR, dim);
			var dima = SetDim3(vec3<f32>(0, 0, 0), dim, f32(f32(1))); // axis for dim
			var linearC = MulQuatVector(xwPQ, dima);
			var linearP = Negate3(linearC);
			var angularP = Negate3(Cross3(dP, linearC));
			var angularC = Cross3(dC, linearC);
			var derr = Dot3(linearP, vP) + Dot3(linearC, vC) + Dot3(angularP, wP) + Dot3(angularC, wC);
			var err = f32(0.0);
			var compliance = params.JointLinearComply;
			var damping = f32(0.0);
			var targetVel = Dim3(axisTargetVelKdD, dim);
			var derrRel = derr - targetVel;
			var lower = Dim3(axisLimitsLower, dim);
			var upper = Dim3(axisLimitsUpper, dim);
			if (e < lower) {
				err = e - lower;
			} else if (e > upper) {
				err = e - upper;
			} else {
				var targetPos = Dim3(axisTargetPosKeD, dim);
				targetPos = clamp(targetPos, lower, upper);
				var ke = Dim3(axisStiffness, dim);
				var kd = Dim3(axisDamping, dim);
				if (ke > 0.0) {
					err = e - targetPos;
					compliance = 1.0 / ke;
					damping = Dim3(axisDamping, dim);
				} else if (kd > 0.0) {
					compliance = 1.0 / kd;
					damping = kd;
				}
			}
			if (abs(err) > 1e-9 || abs(derrRel) > 1e-9) {
				var lambdaIn = Dim3(lambdaPrev, dim);
				var dLambda = PositionalCorrection(err, derrRel, posePQ, poseCQ, mInvP, mInvC,
					iInvP, iInvC, linearP, linearC, angularP, angularC, lambdaIn, compliance, damping, params.Dt);
				linDeltaP = linDeltaP+(linearP*(dLambda * params.JointLinearRelax));
				linDeltaC = linDeltaC+(linearC*(dLambda * params.JointLinearRelax));
				angDeltaP = angDeltaP+(angularP*(dLambda * params.JointAngularRelax));
				angDeltaC = angDeltaC+(angularC*(dLambda * params.JointAngularRelax));
				lambdaNext = SetDim3(lambdaNext, dim, dLambda);
			}
		}
	}
	SetJointLinLambda(ji, lambdaNext);
	var jAngularN = GetJointAngularDoFN(ji);
	var qP = xwPQ;
	var qC = xwCQ;
	if (QuatDot(qP, qC) < 0) {
		qC = QuatMulScalar(qC, -1.0);
	}
	var relQ = MulQuats(QuatInverse(qP), qC);
	var qtwist = QuatNormalize(vec4<f32>(relQ.x, 0.0, 0.0, relQ.w));
	var qswing = MulQuats(relQ, QuatInverse(qtwist));
	var s = sqrt(relQ.x*relQ.x + relQ.w*relQ.w);
	if (s == 0) {
		s = f32(1);
	}
	var invs = 1.0 / s;
	var invscube = invs * invs * invs;
	var err0 = 2.0 * asin(clamp(qtwist.x, -1.0, 1.0));
	var err1 = qswing.y;
	var err2 = qswing.z;
	var grad0 = vec4<f32>(invs-relQ.x*relQ.x*invscube, 0.0, 0.0, -(relQ.w*relQ.x)*invscube);
	var grad1 = vec4<f32>(
		-relQ.w*(relQ.w*relQ.z+relQ.x*relQ.y)*invscube,
		relQ.w*invs,
		-relQ.x*invs,
		relQ.x*(relQ.w*relQ.z+relQ.x*relQ.y)*invscube);
	var grad2 = vec4<f32>(
		relQ.w*(relQ.w*relQ.y-relQ.x*relQ.z)*invscube,
		relQ.x*invs,
		relQ.w*invs,
		relQ.x*(relQ.z*relQ.x-relQ.w*relQ.y)*invscube);
	grad0 = QuatMulScalar(grad0, 2.0/abs(qtwist.w));
	var swing_sq = qswing.w * qswing.w;
	var angularEps = f32(1.0e-4);
	if (swing_sq+angularEps < 1.0) {
		var d = sqrt(1.0 - qswing.w*qswing.w);
		var theta = 2.0 * acos(clamp(qswing.w, -1.0, 1.0));
		var scale = theta / d;
		err1 *= scale;
		err2 *= scale;
		grad1 = QuatMulScalar(grad1, scale);
		grad2 = QuatMulScalar(grad2, scale);
	}
	var errs = vec3<f32>(err0, err1, err2);
	var gradX = vec3<f32>(grad0.x, grad1.x, grad2.x);
	var gradY = vec3<f32>(grad0.y, grad1.y, grad2.y);
	var gradZ = vec3<f32>(grad0.z, grad1.z, grad2.z);
	var gradW = vec3<f32>(grad0.w, grad1.w, grad2.w);
	var axisLimitsD: vec3<f32>;
	var axisLimitsA: vec3<f32>;
	var axisTargetPosKeD: vec3<f32>;
	var axisTargetPosKeA: vec3<f32>;
	var axisTargetVelKdD: vec3<f32>;
	var axisTargetVelKdA: vec3<f32>;
	lambdaPrev = JointAngLambda(ji);
	lambdaNext = vec3<f32>(0, 0, 0);
	for (var dof=0; dof<jAngularN; dof++) {
		var di = dof + jLinearN;
		var axis = JointAxis(ji, di);
		JointAxisLimitsUpdate(dof, axis, JointDoF(ji, di, JointLimitLower), JointDoF(ji, di, JointLimitUpper), &axisLimitsD, &axisLimitsA);
		var ke = JointControl(ji, di, JointTargetStiff);
		var kd = JointControl(ji, di, JointTargetDamp);
		var targetPos = JointControl(ji, di, JointTargetPosCur);
		var targetVel = JointControl(ji, di, JointTargetVel);
		if (ke > 0.0) { // has position control
			JointAxisTarget(axis, targetPos, ke, &axisTargetPosKeD, &axisTargetPosKeA);
		}
		if (kd > 0.0) { // has velocity control
			JointAxisTarget(axis, targetVel, kd, &axisTargetVelKdD, &axisTargetVelKdA);
		}
	}
	var axisStiffness = axisTargetPosKeA;
	var axisDamping = axisTargetVelKdA;
	axisTargetPosKeD = DivSafe3(axisTargetPosKeD, axisStiffness);
	axisTargetVelKdD = DivSafe3(axisTargetVelKdD, axisDamping);
	var axisLimitsLower = axisLimitsD;
	var axisLimitsUpper = axisLimitsA;
	for (var dim=0; dim<i32(3); dim++) {
		var e = Dim3(errs, dim);
		var grad = vec4<f32>(Dim3(gradX, dim), Dim3(gradY, dim), Dim3(gradZ, dim), Dim3(gradW, dim));
		var quatC = MulQuats(MulQuats(QuatMulScalar(qP, f32(0.5)), grad), QuatInverse(qC));
		var angularC = vec3<f32>(quatC.x, quatC.y, quatC.z);
		var angularP = Negate3(angularC);
		var derr = Dot3(angularP, wP) + Dot3(angularC, wC);
		var err = f32(0.0);
		var compliance = params.JointLinearComply;
		var damping = f32(0.0);
		var targetVel = Dim3(axisTargetVelKdD, dim);
		var angularClen = Length3(angularC);
		var derrRel = derr - targetVel*angularClen;
		var lower = Dim3(axisLimitsLower, dim);
		var upper = Dim3(axisLimitsUpper, dim);
		if (e < lower) {
			err = e - lower;
		} else if (e > upper) {
			err = e - upper;
		} else {
			var targetPos = Dim3(axisTargetPosKeD, dim);
			targetPos = clamp(targetPos, lower, upper);
			var ke = Dim3(axisStiffness, dim);
			var kd = Dim3(axisDamping, dim);
			if (ke > 0.0) {
				err = MinAngleDiff(e, targetPos);
				compliance = 1.0 / ke;
				damping = Dim3(axisDamping, dim);
			} else if (kd > 0.0) {
				compliance = 1.0 / kd;
				damping = kd;
			}
		}
		var lambdaIn = Dim3(lambdaPrev, dim);
		var dLambda = AngularCorrection(err, derrRel, posePQ, poseCQ, iInvP, iInvC, angularP, angularC, lambdaIn, compliance, damping, params.Dt);
		angDeltaP = angDeltaP+(angularP*(dLambda));
		angDeltaC = angDeltaC+(angularC*(dLambda));
		lambdaNext = SetDim3(lambdaNext, dim, dLambda);
	}
	SetJointAngLambda(ji, lambdaNext);
	if (!parentFixed) {
		StepBodyDeltas(jPi, jPbi, false, f32(f32(0)), linDeltaP, angDeltaP);
	}
	if (mInvC > 0) {
		StepBodyDeltas(jCi, jCbi, false, f32(f32(0)), linDeltaC, angDeltaC);
	}
	Params[0] = params;
}
fn JointAxisTarget(axis: vec3<f32>, targ: f32,weight: f32, axisTargets: ptr<function,vec3<f32>>,axisWeights: ptr<function,vec3<f32>>) {
	var weightedAxis = axis*(weight);
	*axisTargets = (*axisTargets)+(weightedAxis*(targ)); // weighted target (to be normalized later by sum of weights)
	*axisWeights = (*axisWeights)+(Abs3(weightedAxis));
}
fn PositionalCorrection(err: f32,derr: f32, tfaQ: vec4<f32>,tfbQ: vec4<f32>, mInvA: f32,mInvB: f32, iInvA: mat3x3f,iInvB: mat3x3f, linA: vec3<f32>,linB: vec3<f32>,angA: vec3<f32>,angB: vec3<f32>, lambdaIn: f32,compliance: f32,damping: f32,dt: f32) -> f32 {
	var denom = f32(0.0);
	denom += LengthSquared3(linA) * mInvA;
	denom += LengthSquared3(linB) * mInvB;
	var rotAngA = MulQuatVectorInverse(tfaQ, angA);
	var rotAngB = MulQuatVectorInverse(tfbQ, angB);
	denom += Dot3(rotAngA, iInvA*(rotAngA));
	denom += Dot3(rotAngB, iInvB*(rotAngB));
	var alpha = compliance;
	var gamma = compliance * damping;
	var lambda = -(err + alpha*lambdaIn + gamma*derr);
	if (denom+alpha > 0.0) {
		lambda /= (dt+gamma)*denom + alpha/dt;
	}return lambda;
}
fn AngularCorrection(err: f32,derr: f32, tfaQ: vec4<f32>,tfbQ: vec4<f32>, iInvA: mat3x3f,iInvB: mat3x3f, angA: vec3<f32>,angB: vec3<f32>, lambdaIn: f32,compliance: f32,damping: f32,dt: f32) -> f32 {
	var rotAngA = MulQuatVectorInverse(tfaQ, angA);
	var rotAngB = MulQuatVectorInverse(tfbQ, angB);
	var denom = f32(0.0);
	denom += Dot3(rotAngA, iInvA*(rotAngA));
	denom += Dot3(rotAngB, iInvB*(rotAngB));
	var alpha = compliance;
	var gamma = compliance * damping;
	var deltaLambda = -(err + alpha*lambdaIn + gamma*derr);
	if (denom+alpha > 0.0) {
		deltaLambda /= (dt+gamma)*denom + alpha/dt;
	}return deltaLambda;
}
fn JointAxisLimitsUpdate(dof: i32, axis: vec3<f32>, lower: f32,upper: f32, axisLimitsD: ptr<function,vec3<f32>>,axisLimitsA: ptr<function,vec3<f32>>) {
	var loTemp = axis*(lower);
	var upTemp = axis*(upper);
	var lo = Min3(loTemp, upTemp);
	var up = Max3(loTemp, upTemp);
	if (dof == 0) {
		*axisLimitsD = lo;
		*axisLimitsA = up;
	} else {
		*axisLimitsD = Min3(*axisLimitsD, lo);
		*axisLimitsA = Max3(*axisLimitsA, up);
	}
}