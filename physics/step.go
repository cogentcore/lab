// Code generated by "goal build"; DO NOT EDIT.
//line step.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

func OneIfNonzero(f float32) float32 {
	if f != 0.0 {
		return 1.0
	}
	return 0.0
}

// step does the following:
// if self.compute_body_velocity_from_position_delta or self.enable_restitution:
// 	body_q_init = wp.clone(state_in.body_q)
// 	body_qd_init = wp.clone(state_in.body_qd)
// body_deltas = wp.empty_like(state_out.body_qd)
// kernel=apply_joint_forces,
// self.integrate_bodies(model, state_in, state_out, dt, self.angular_damping)
// for i in range(self.iterations):
// 	kernel=solve_body_joints,
//      body_q, body_qd = self.apply_body_deltas(model, state_in, state_out, body_deltas, dt)
// 	kernel=solve_body_contact_positions,
//	if self.enable_restitution and i == 0:
//        # remember contact constraint weighting from the first iteration
//        if self.rigid_contact_con_weighting:
//            rigid_contact_inv_weight_init = wp.clone(rigid_contact_inv_weight)
//        else:
//            rigid_contact_inv_weight_init = None
//	body_q, body_qd = self.apply_body_deltas(
//		model, state_in, state_out, body_deltas, dt, rigid_contact_inv_weight
//	)
//	# update body velocities from position changes
//      if self.compute_body_velocity_from_position_delta and model.body_count and not requires_grad:
// 		kernel=update_body_velocities,
// 		kernel=apply_rigid_restitution,
//		kernel=apply_body_delta_velocities,

//gosl:end

func (wl *World) StepJointForces() {
	params := GetParams(0)
	RunStepJointForces(int(params.JointsN))
}
