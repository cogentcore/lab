// Code generated by "goal build"; DO NOT EDIT.
//line step.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

//gosl:start

// InitDynamics copies Body initial state to dynamic state.
func InitDynamics(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ii := int32(i)
	if ii >= pars.DynamicsN {
		return
	}
	bi := DynamicIndex(ii)
	Dynamics.Set(Bodies.Value(int(bi), int(BodyPosX)), int(ii), int(PosX))
	Dynamics.Set(Bodies.Value(int(bi), int(BodyPosY)), int(ii), int(PosY))
	Dynamics.Set(Bodies.Value(int(bi), int(BodyPosZ)), int(ii), int(PosZ))

	Dynamics.Set(Bodies.Value(int(bi), int(BodyRotX)), int(ii), int(RotX))
	Dynamics.Set(Bodies.Value(int(bi), int(BodyRotY)), int(ii), int(RotY))
	Dynamics.Set(Bodies.Value(int(bi), int(BodyRotZ)), int(ii), int(RotZ))
	Dynamics.Set(Bodies.Value(int(bi), int(BodyRotW)), int(ii), int(RotW))

	for v := VelX; v < DynamicVarsN; v++ {
		Dynamics.Set(0.0, int(ii), int(v))
	}
}

// StepJoints does joint-based update.
func StepJoints(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ji := int32(i)
	if ji >= pars.JointsN {
		return
	}
	ba := JointAIndex(ji)
	bb := JointBIndex(ji)
	jt := GetJointType(ji)
	switch jt {
	case Glue:
		GlueStep(ji, ba, bb)
	}
}

// Step is dynamic update step kernel. i = body
func Step(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ii := int32(i)
	if ii >= pars.DynamicsN {
		return
	}
	Dynamics.SetAdd(pars.Step*Dynamics.Value(int(ii), int(VelX)), int(ii), int(PosX))
	Dynamics.SetAdd(pars.Step*Dynamics.Value(int(ii), int(VelY)), int(ii), int(PosY))
	Dynamics.SetAdd(pars.Step*Dynamics.Value(int(ii), int(VelZ)), int(ii), int(PosZ))

	// todo: force, integrated etc.
}

//gosl:end

func (wl *World) Step() {
	pars := GetParams(0)
	RunStep(int(pars.DynamicsN))
}
