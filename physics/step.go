// Code generated by "goal build"; DO NOT EDIT.
//line step.goal:1
// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

func OneIfNonzero(f float32) float32 {
	if f != 0.0 {
		return 1.0
	}
	return 0.0
}

// step does the following:
// if self.compute_body_velocity_from_position_delta or self.enable_restitution:
// 	// save initial state:
// 	body_q_init = wp.clone(state_in.body_q)
// 	body_qd_init = wp.clone(state_in.body_qd)
// body_deltas = wp.empty_like(state_out.body_qd)
// kernel=apply_joint_forces,
// self.integrate_bodies(model, state_in, state_out, dt, self.angular_damping)
// for i in range(self.iterations):
// 	kernel=solve_body_joints,
//      body_q, body_qd = self.apply_body_deltas(model, state_in, state_out, body_deltas, dt)
// 	kernel=solve_body_contact_positions,
//	if self.enable_restitution and i == 0:
//        # remember contact constraint weighting from the first iteration
//        if self.rigid_contact_con_weighting:
//            rigid_contact_inv_weight_init = wp.clone(rigid_contact_inv_weight)
//        else:
//            rigid_contact_inv_weight_init = None
//	body_q, body_qd = self.apply_body_deltas(
//		model, state_in, state_out, body_deltas, dt, rigid_contact_inv_weight
//	)
//	# update body velocities from position changes
//      if self.compute_body_velocity_from_position_delta and model.body_count and not requires_grad:
// 		kernel=update_body_velocities,
// 		kernel=apply_rigid_restitution,
//		kernel=apply_body_delta_velocities,

//gosl:end

func (wl *World) Step() {
	params := GetParams(0)
	if params.Cur == 0 {
		params.Cur = 1
		params.Next = 0
	} else {
		params.Cur = 0
		params.Next = 1
	}
	ToGPU(ParamsVar, JointControlsVar)
	wl.StepCollision()
	wl.StepJointForces()
	wl.StepIntegrateBodies()

	for range params.Iterations {
		wl.StepSolveJoints()
		wl.StepBodyContacts()
	}
	RunDone(DynamicsVar)
}

func (wl *World) StepCollision() {
	params := GetParams(0)
	RunCollisionInit(1) // could also just copy up
	RunCollisionBroad(int(params.BodyCollidePairsN))
	// note: time getting BroadContactsN back down and using that vs. running full
	RunCollisionNarrow(int(params.ContactsMax))
	RunDone(ContactsNVar) // we do multiple iterations so useful to have this
	// fmt.Println("contacts:", ContactsN.Value(0), "max:", params.ContactsMax)
}

func (wl *World) StepJointForces() {
	params := GetParams(0)
	RunStepJointForces(int(params.JointsN))
	RunForcesFromJoints(int(params.DynamicsN))
}

func (wl *World) StepIntegrateBodies() {
	params := GetParams(0)
	RunStepIntegrateBodies(int(params.DynamicsN))
}

func (wl *World) StepSolveJoints() {
	params := GetParams(0)
	RunStepSolveJoints(int(params.JointsN))
	RunDeltasFromJoints(int(params.DynamicsN))
}

func (wl *World) StepBodyContacts() {
	params := GetParams(0)
	cmax := int(ContactsN.Values[0])
	if cmax > 0 {
		RunStepBodyContacts(cmax)
		RunDeltasFromContacts(int(params.DynamicsN))
	}
}
