// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package physics

import (
	"cogentcore.org/core/math32"
	"cogentcore.org/lab/gosl/slmath"
)

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

// MulTransforms computes the equivalent of matrix multiplication for
// two quat-based transforms, o = a * b
func MulTransforms(aP math32.Vector3, aQ math32.Quat, bP math32.Vector3, bQ math32.Quat, oP *math32.Vector3, oQ *math32.Quat) {
	// rotate b by a and add a
	br := slmath.MulQuat(bP, aQ)
	*oP = br.Add(aP)
	*oQ = slmath.MulQuats(aQ, bQ)
}

// TransformPoint applies quat-based transform to given point.
func TransformPoint(xP math32.Vector3, xQ math32.Quat, p math32.Vector3) math32.Vector3 {
	dp := slmath.MulQuat(p, xQ)
	return dp.Add(xP)
}

// InitDynamics copies Body initial state to dynamic state.
func InitDynamics(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ii := int32(i)
	if ii >= pars.DynamicsN {
		return
	}
	bi := DynamicIndex(ii)
	Dynamics[ii, PosX] = Bodies[bi, BodyPosX]
	Dynamics[ii, PosY] = Bodies[bi, BodyPosY]
	Dynamics[ii, PosZ] = Bodies[bi, BodyPosZ]

	Dynamics[ii, RotX] = Bodies[bi, BodyRotX]
	Dynamics[ii, RotY] = Bodies[bi, BodyRotY]
	Dynamics[ii, RotZ] = Bodies[bi, BodyRotZ]
	Dynamics[ii, RotW] = Bodies[bi, BodyRotW]

	for v := VelX; v < DynamicVarsN; v++ {
		Dynamics[ii, v] = 0.0
	}
}

// StepJoints does joint-based update.
func StepJoints(i uint32) { //gosl:kernel
	pars := GetParams(0)
	ji := int32(i)
	if ji >= pars.JointsN {
		return
	}
	// todo: enabled
	jpi := JointParentIndex(ji)
	jpbi := DynamicIndex(jpi)
	jci := JointChildIndex(ji)
	jcbi := DynamicIndex(jci)
	jt := GetJointType(ji)

	jpP := JointPPos(ji)
	jpQ := JointPRot(ji)

	// parent world transform
	xwpP := jpP
	xwpQ := jpQ
	posepP := jpP
	posepQ := jpQ
	var comp math32.Vector3

	if jpi >= 0 { // can be fixed
		posepP = DynamicPos(jpi)
		posepQ = DynamicRot(jpi)
		MulTransforms(posepP, posepQ, jpP, jpQ, &xwpP, &xwpQ)
		comp = BodyCom(jpbi)
	}
	rp := xwpP.Sub(TransformPoint(posepP, posepQ, comp)) // parent moment arm

	// child world transform
	posecP := DynamicPos(jci)
	posecQ := DynamicRot(jci)
	xwcP := posecP
	// xwcQ := posecQ
	comc := BodyCom(jcbi)
	rc := xwcP.Sub(TransformPoint(posecP, posecQ, comc)) // child moment arm

	// from controls:
	jf := JointForce(ji)
	jtq := JointTorque(ji)

	var f, t math32.Vector3
	switch jt {
	case Free, Distance:
		// todo: distance doesn't seem to be supported here?
		f = jf
		t = jtq
	case Ball:
		t = jtq
	case Revolute, Prismatic:
		axis := JointAxis(ji)
		ap := slmath.MulQuat(axis, xwpQ)
		f = f.Add(slmath.MulScalar3(ap, jf.X))
	default:
		// todo: D6 requires more iteration!
	}
	SetJointPForce(ji, f)
	SetJointCForce(ji, f)
	SetJointPTorque(ji, t.Add(slmath.Cross3(rp, f)))
	SetJointCTorque(ji, t.Add(slmath.Cross3(rc, f)))
}

//gosl:end

func (wl *World) StepJoints() {
	pars := GetParams(0)
	RunStepJoints(int(pars.JointsN))
}
