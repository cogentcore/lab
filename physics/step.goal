// Copyright (c) 2025, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This code is adapted directly from https://github.com/newton-physics/newton
// Copyright (c) 2025 The Newton Developers, Released under an Apache-2.0 license

package physics

//gosl:start
//gosl:import "cogentcore.org/lab/gosl/slmath"

func OneIfNonzero(f float32) float32 {
	if f != 0.0 {
		return 1.0
	}
	return 0.0
}

// StepInit performs initialization at start of Step.
func StepInit(i uint32) { //gosl:kernel read-write:Params
	if i > 0 {
		return
	}
	params := GetParams(0)
	BroadContactsN.Values[0] = 0
	ContactsN.Values[0] = 0
	if params.Cur == 0 {
		params.Cur = 1
		params.Next = 0
	} else {
		params.Cur = 0
		params.Next = 1
	}
}

// step does the following:
// if self.compute_body_velocity_from_position_delta or self.enable_restitution:
// 	// save initial state:
// 	body_q_init = wp.clone(state_in.body_q)
// 	body_qd_init = wp.clone(state_in.body_qd)
// body_deltas = wp.empty_like(state_out.body_qd)
// kernel=apply_joint_forces,
// self.integrate_bodies(model, state_in, state_out, dt, self.angular_damping)
// for i in range(self.iterations):
// 	kernel=solve_body_joints,
//      body_q, body_qd = self.apply_body_deltas(model, state_in, state_out, body_deltas, dt)
// 	kernel=solve_body_contact_positions,
//	if self.enable_restitution and i == 0:
//        # remember contact constraint weighting from the first iteration
//        if self.rigid_contact_con_weighting:
//            rigid_contact_inv_weight_init = wp.clone(rigid_contact_inv_weight)
//        else:
//            rigid_contact_inv_weight_init = None
//	body_q, body_qd = self.apply_body_deltas(
//		model, state_in, state_out, body_deltas, dt, rigid_contact_inv_weight
//	)
//	# update body velocities from position changes
//      if self.compute_body_velocity_from_position_delta and model.body_count and not requires_grad:
// 		kernel=update_body_velocities,
// 		kernel=apply_rigid_restitution,
//		kernel=apply_body_delta_velocities,

//gosl:end

// Step runs one physics step, sending Params and JointControls
// to the GPU, and getting the Dynamics state vars back.
// Each step has SubSteps integration sub-steps.
func (wl *World) Step() {
	params := GetParams(0)
	ToGPU(ParamsVar, JointControlsVar)
	if params.SubSteps > 1 {
		for range params.SubSteps - 1 {
			wl.StepGet()
		}
	}
	wl.StepGet(ParamsVar, DynamicsVar)
	// wl.StepGet(ParamsVar, DynamicsVar, ContactsNVar)
	// fmt.Println("contacts:", ContactsN.Value(0), "max:", params.ContactsMax)
}

// StepGet runs one physics step and gets the given vars back
// from the GPU.
func (wl *World) StepGet(vars ...GPUVars) {
	params := GetParams(0)
	RunStepInit(1)
	wl.StepCollision()
	wl.StepJointForces()
	wl.StepIntegrateBodies()

	for range params.Iterations {
		wl.StepSolveJoints()
		wl.StepBodyContacts()
	}
	RunDone(vars...)
}

func (wl *World) StepCollision() {
	params := GetParams(0)
	RunCollisionBroad(int(params.BodyCollidePairsN))
	// note: time getting BroadContactsN back down and using that vs. running full
	RunCollisionNarrow(int(params.ContactsMax))
	// note: too slow to get this back, so just using ContactsMax always.
	// RunDone(ContactsNVar) // we do multiple iterations so useful to have this
	// fmt.Println("contacts:", ContactsN.Value(0), "max:", params.ContactsMax)
}

func (wl *World) StepJointForces() {
	params := GetParams(0)
	RunStepJointForces(int(params.JointsN))
	RunForcesFromJoints(int(params.DynamicsN))
}

func (wl *World) StepIntegrateBodies() {
	params := GetParams(0)
	RunStepIntegrateBodies(int(params.DynamicsN))
}

func (wl *World) StepSolveJoints() {
	params := GetParams(0)
	RunStepSolveJoints(int(params.JointsN))
	RunStepBodyJointDeltas(int(params.DynamicsN))
}

func (wl *World) StepBodyContacts() {
	params := GetParams(0)
	if !wl.GPU {
		cmax := int(ContactsN.Values[0])
		if cmax > 0 {
			RunStepBodyContacts(cmax)
			RunStepBodyContactDeltas(int(params.DynamicsN))
		}
	} else {
		RunStepBodyContacts(int(params.ContactsMax)) // just do max and let the routines bail
		RunStepBodyContactDeltas(int(params.DynamicsN))
	}
}
