// Copyright (c) 2024, Cogent Core. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"path/filepath"
	"reflect"
	"strings"

	"cogentcore.org/core/base/fsx"
	"cogentcore.org/core/core"
	"cogentcore.org/core/styles"
	"cogentcore.org/lab/lab"
	"cogentcore.org/lab/plot"
	"cogentcore.org/lab/stats/stats"
	"cogentcore.org/lab/table"
	"cogentcore.org/lab/tensor"
	"cogentcore.org/lab/tensorfs"
)

// FindResult finds an existing result record for given job id and path,
// returning index and result record if found.
func (sr *Simmer) FindResult(jid, path string) (int, *Result) {
	for i, r := range sr.ResultsList {
		if r.JobID == jid && r.Path == path {
			return i, r
		}
	}
	return -1, nil
}

// OpenResultFiles opens the given result files.
func (sr *Simmer) OpenResultFiles(jobs []string, filter FilterResults) {
	ts := sr.Tabs.AsLab()
	for _, jid := range jobs {
		jpath := sr.JobPath(jid)
		message := sr.ValueForJob(jid, "Message")
		label := sr.ValueForJob(jid, "Label")
		args := sr.ValueForJob(jid, "Args")
		fls := fsx.Filenames(jpath, filter.Ext)
		for _, fn := range fls {
			if filter.FileContains != "" && !strings.Contains(fn, filter.FileContains) {
				continue
			}
			dt := table.New()
			fpath := filepath.Join(jpath, fn)
			err := dt.OpenCSV(core.Filename(fpath), tensor.Tab)
			if err != nil {
				fmt.Println(err.Error())
			}
			// rpath := strings.TrimPrefix(fpath, sr.DataRoot)
			rpath := fn // actually visible in table
			if ri, _ := sr.FindResult(jid, rpath); ri >= 0 {
				sr.ResultsList[ri] = &Result{JobID: jid, Label: label, Message: message, Args: args, Path: rpath, Table: dt}
			} else {
				sr.ResultsList = append(sr.ResultsList, &Result{JobID: jid, Label: label, Message: message, Args: args, Path: rpath, Table: dt})
			}
		}
	}
	if len(sr.ResultsList) == 0 {
		core.MessageSnackbar(sr, "No files containing: "+filter.FileContains+" with extension: "+filter.Ext)
		return
	}
	tv := ts.SliceTable("Results", &sr.ResultsList)
	if sr.ResultsTableView != tv {
		sr.ResultsTableView = tv
		sr.styleResults()
	}
	sr.ResultsTableView.Update()
	sr.UpdateSims()
}

// Results loads specific .tsv data files from the jobs selected
// in the Jobs table, into the Results table.  There are often
// multiple result files per job, so this step is necessary to
// choose which such files to select for plotting.
func (sr *Simmer) Results() { //types:add
	tv := sr.JobsTableView
	jobs := tv.SelectedColumnStrings("JobID")
	if len(jobs) == 0 {
		fmt.Println("No Jobs rows selected")
		return
	}
	// fmt.Println(jobs)
	if sr.Config.Filter.Ext == "" {
		sr.Config.Filter.Ext = ".tsv"
	}
	lab.PromptStruct(sr, &sr.Config.Filter, "Open results data for files", func() {
		sr.OpenResultFiles(jobs, sr.Config.Filter)
	})
}

// Diff shows the differences between two selected jobs, or if only
// one job is selected, between that job and the current source directory.
func (sr *Simmer) Diff() { //types:add
	@0
	tv := sr.JobsTableView
	jobs := tv.SelectedColumnStrings("JobID")
	nj := len(jobs)
	if nj == 0 || nj > 2 {
		core.MessageSnackbar(sr, "Diff requires two Job rows to be selected")
		return
	}
	if nj == 1 {
		ja := sr.JobPath(jobs[0])
		lab.NewDiffBrowserDirs(ja, sr.StartDir)
		return
	}	
	ja := sr.JobPath(jobs[0])
	jb := sr.JobPath(jobs[1])
	lab.NewDiffBrowserDirs(ja, jb)
}

// Plot concatenates selected Results data files and generates a plot
// of the resulting data.
func (sr *Simmer) Plot() { //types:add
	ts := sr.Tabs.AsLab()
	tv := sr.ResultsTableView
	jis := tv.SelectedIndexesList(false)
	if len(jis) == 0 {
		fmt.Println("No Results rows selected")
		return
	}
	var AggTable *table.Table
	for _, i := range jis {
		res := sr.ResultsList[i]
		jid := res.JobID
		label := res.Label
		dt := res.Table.InsertKeyColumns("JobID", jid, "JobLabel", label) // this clones the table
		if AggTable == nil {
			AggTable = dt
			plot.SetFirstStyler(dt.Columns.Values[0], func(s *plot.Style) {
				s.Role = plot.Split
				s.On = true
			})
		} else {
			AggTable.AppendRows(dt)
		}
	}
	ts.PlotTable("Plot", AggTable)
}

// PlotMean concatenates selected Results data files and generates a plot
// of the resulting data, computing the mean of each run.
func (sr *Simmer) PlotMean() { //types:add
	ts := sr.Tabs.AsLab()
	tv := sr.ResultsTableView
	jis := tv.SelectedIndexesList(false)
	if len(jis) == 0 {
		fmt.Println("No Results rows selected")
		return
	}
	nc := len(sr.Config.GroupColumns)
	rdir := "Stats/" + sr.Config.GroupColumns[nc-1] // results dir
	var AggTable *table.Table
	for _, i := range jis {
		res := sr.ResultsList[i]
		jid := res.JobID
		label := res.Label
		dir, _ := tensorfs.NewDir("root")
		rdt := res.Table
		stats.TableGroups(dir, rdt, sr.Config.GroupColumns...)
		var fcols []string
		for ci, cl := range rdt.Columns.Values {
			if cl.DataType() != reflect.Float32 && cl.DataType() != reflect.Float64 {
				continue
			}
			fcols = append(fcols, rdt.Columns.Keys[ci])
		}
		stats.TableGroupStats(dir, stats.StatMean, rdt, fcols...)
		edir := dir.Dir(rdir)
		sdt := tensorfs.DirTable(edir, nil)
		dt := sdt.InsertKeyColumns("JobID", jid, "JobLabel", label) // this clones the table
		if AggTable == nil {
			AggTable = dt
			plot.SetFirstStyler(dt.Columns.Values[0], func(s *plot.Style) {
				s.Role = plot.Split
				s.On = true
			})
		} else {
			AggTable.AppendRows(dt)
		}
	}
	ts.PlotTable("Plot", AggTable)
}

func (sr *Simmer) styleResults() {
	tv := sr.ResultsTableView
	tv.ShowIndexes = true
	tv.ReadOnlyMultiSelect = true
	tv.Styler(func(s *styles.Style) {
		s.SetReadOnly(true)
	})
}

// Reset resets the Results table
func (sr *Simmer) Reset() { //types:add
	ts := sr.Tabs.AsLab()
	sr.ResultsList = []*Result{}
	tv := ts.SliceTable("Results", &sr.ResultsList)
	if sr.ResultsTableView != tv {
		sr.ResultsTableView = tv
		sr.styleResults()
	}
	sr.UpdateSims()
}

