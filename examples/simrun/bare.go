// Code generated by "goal build"; DO NOT EDIT.
//line bare.goal:1
// Copyright (c) 2024, Cogent Lab. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"strconv"

	"cogentcore.org/core/base/errors"
	"cogentcore.org/core/core"
	"cogentcore.org/lab/examples/baremetal"
	"cogentcore.org/lab/goal/goalib"
)

// bare supports the baremetal platform without slurm or other job management infra.

// SubmitBare submits a bare metal run job, returning the pid of the resulting process.
func (sr *SimRun) SubmitBare(jid, args string) string {
	goalrun.Run("@0")
	script := "job.sbatch"
	f, _ := os.Create(script)
	sr.WriteBare(f, jid, args)
	f.Close()
	goalrun.Run("chmod", "+x", script)

	files, err := baremetal.AllFiles("./", ".*")
	if errors.Log(err) != nil {
		return ""
	}
	// fmt.Println("files:", files)
	var b bytes.Buffer
	err = baremetal.TarFiles(&b, "./", true, files...)
	if errors.Log(err) != nil {
		return ""
	}
	bm := sr.BareMetal

	spath := sr.ServerJobPath(jid)
	job := bm.Submit(sr.Config.Project, spath, script, "*.tsv", b.Bytes())
	goalrun.Output("@0")
	bid := strconv.Itoa(job.ID)
	goalib.WriteFile("job.job", bid)
	bm.RunPendingJobs()
	return bid
}

// WriteBare writes the bash script to run a "bare metal" run.
func (sr *SimRun) WriteBare(w io.Writer, jid, args string) {
	fmt.Fprintf(w, "#!/bin/bash -l\n") //  -l = login session, sources your .bash_profile

	fmt.Fprintf(w, "\n\n")
	// fmt.Fprintf(w, "go build -mod=mod -tags mpi\n")
	fmt.Fprintf(w, "go build -mod=mod\n")
	fmt.Fprintln(w, "date '+%Y-%m-%d %T %Z' > job.start")

	fmt.Fprintf(w, "./%s -nogui -cfg config_job.toml -gpu-device $BARE_GPU %s >& job.out & echo $! > job.pid", sr.Config.Project, args)
}

func (sr *SimRun) QueueBare() {
	nrun := errors.Log1(sr.BareMetal.RunPendingJobs())
	nfin := errors.Log1(sr.BareMetal.PollJobs())
	sr.BareMetal.SaveState()
	core.MessageSnackbar(sr, fmt.Sprintf("BareMetal jobs run: %d finished: %d", nrun, nfin))
}

func (sr *SimRun) CancelJobsBare(jobs []string) {
	jnos := make([]int, 0, len(jobs))
	for _, jid := range jobs {
		sjob := sr.ValueForJob(jid, "ServerJob")
		if sjob != "" {
			jno := errors.Log1(strconv.Atoi(sjob))
			jnos = append(jnos, jno)
		}
	}
	sr.BareMetal.CancelJobs(jnos...)
}
