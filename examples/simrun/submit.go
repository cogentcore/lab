// Code generated by "goal build"; DO NOT EDIT.
//line submit.goal:1
// Copyright (c) 2024, Cogent Lab. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"cogentcore.org/core/base/fsx"
	"cogentcore.org/core/core"
	"cogentcore.org/lab/goal/goalib"
	"cogentcore.org/lab/lab"
)

// WriteSBatchHeader writes the header of a SLURM SBatch script
// that is common across all three scripts.
// IMPORTANT: set the job parameters here!
func (br *SimRun) WriteSBatchHeader(w io.Writer, jid string) {
	fmt.Fprintf(w, "#SBATCH --job-name=%s_%s\n", br.Config.Project, jid)
	fmt.Fprintf(w, "#SBATCH --mem-per-cpu=%dG\n", br.Config.Job.Memory)
	fmt.Fprintf(w, "#SBATCH --time=%d:00:00\n", br.Config.Job.Hours)
	fmt.Fprintf(w, "#SBATCH --ntasks=%d\n", br.Config.Job.Tasks)
	fmt.Fprintf(w, "#SBATCH --cpus-per-task=%d\n", br.Config.Job.CPUsPerTask)
	fmt.Fprintf(w, "#SBATCH --ntasks-per-node=%d\n", br.Config.Job.TasksPerNode)
	if br.Config.ExcludeNodes != "" {
		fmt.Fprintf(w, "#SBATCH --exclude=%s\n", br.Config.ExcludeNodes)
	}
	// fmt.Fprint(w, "#SBATCH --nodelist=agate-[2,19]\n")
	// fmt.Fprintf(w, "#SBATCH --qos=%s\n", qos)
	// fmt.Fprintf(w, "#SBATCH --partition=%s\n", qosShort)
	fmt.Fprintf(w, "#SBATCH --mail-type=FAIL\n")
	fmt.Fprintf(w, "#SBATCH --mail-user=%s\n", br.Config.User)
	// these might be needed depending on environment in head node vs. compute nodes
	// fmt.Fprintf(w, "#SBATCH --export=NONE\n")
	// fmt.Fprintf(w, "unset SLURM_EXPORT_ENV\n")
}

func (br *SimRun) WriteSBatchSetup(w io.Writer, jid string) {
	fmt.Fprintf(w, "#!/bin/bash -l\n") //  -l = login session, sources your .bash_profile
	fmt.Fprint(w, "#SBATCH --output=job.setup.out\n")
	fmt.Fprint(w, "#SBATCH --error=job.setup.err\n")
	br.WriteSBatchHeader(w, jid)

	//////////////////////////////////////////////////////////
	// now we do all the setup, like building the executable

	fmt.Fprintf(w, "\n\n")
	// fmt.Fprintf(w, "go build -mod=mod -tags mpi\n")
	fmt.Fprintf(w, "go build -mod=mod\n")
	// fmt.Fprintf(w, "/bin/rm images\n")
	// fmt.Fprintf(w, "ln -s $HOME/ccn_images/CU3D100_20obj8inst_8tick4sac images\n")
	fmt.Fprintln(w, "date '+%Y-%m-%d %T %Z' > job.start")
}

func (br *SimRun) WriteSBatchArray(w io.Writer, jid, setup_id, args string) {
	fmt.Fprintf(w, "#!/bin/bash -l\n") //  -l = login session, sources your .bash_profile
	fmt.Fprintf(w, "#SBATCH --array=0-%d\n", br.Config.Job.NRuns-1)
	fmt.Fprint(w, "#SBATCH --output=job.%A_%a.out\n")
	// fmt.Fprint(w, "#SBATCH --error=job.%A_%a.err\n")
	fmt.Fprintf(w, "#SBATCH --dependency=afterany:%s\n", setup_id)
	br.WriteSBatchHeader(w, jid)

	//////////////////////////////////////////////////////////
	// now we run the job

	fmt.Fprintf(w, "echo $SLURM_ARRAY_JOB_ID\n")
	fmt.Fprintf(w, "\n\n")
	// note: could use srun to run job; -nruns = 1 is number to run from run start
	fmt.Fprintf(w, "./%s -nogui -run $SLURM_ARRAY_TASK_ID -nruns 1 %s\n", br.Config.Project, args)
}

func (br *SimRun) WriteSBatchCleanup(w io.Writer, jid, array_id string) {
	fmt.Fprintf(w, "#!/bin/bash -l\n") //  -l = login session, sources your .bash_profile
	fmt.Fprint(w, "#SBATCH --output=job.cleanup.out\n")
	// fmt.Fprint(w, "#SBATCH --error=job.cleanup.err")
	fmt.Fprintf(w, "#SBATCH --dependency=afterany:%s\n", array_id)
	br.WriteSBatchHeader(w, jid)
	fmt.Fprintf(w, "\n\n")

	//////////////////////////////////////////////////////////
	// now we cleanup after all the jobs have run
	//	can cat results files etc.

	fmt.Fprintf(w, "cat job.*.out > job.out\n")
	fmt.Fprintf(w, "/bin/rm job.*.out\n")

	fmt.Fprintf(w, "cat *_[0-9][0-9][0-9]_run.tsv > all_run.tsv\n")
	fmt.Fprintf(w, "/bin/rm *_[0-9][0-9][0-9]_run.tsv\n")

	fmt.Fprintf(w, "cat *_[0-9][0-9][0-9]_epc.tsv > all_epc.tsv\n")
	fmt.Fprintf(w, "/bin/rm *_[0-9][0-9][0-9]_epc.tsv\n")

	fmt.Fprintln(w, "date '+%Y-%m-%d %T %Z' > job.end")
}

func (br *SimRun) SubmitSBatch(jid, args string) string {
	goalrun.Run("@0")
	f, _ := os.Create("job.setup.sbatch")
	br.WriteSBatchSetup(f, jid)
	f.Close()
	goalrun.Run("scp", "job.setup.sbatch", "@1:job.setup.sbatch")
	sid := br.RunSBatch("job.setup.sbatch")

	f, _ = os.Create("job.sbatch")
	br.WriteSBatchArray(f, jid, sid, args)
	f.Close()
	goalrun.Run("scp", "job.sbatch", "@1:job.sbatch")
	aid := br.RunSBatch("job.sbatch")

	f, _ = os.Create("job.cleanup.sbatch")
	br.WriteSBatchCleanup(f, jid, aid)
	f.Close()
	goalrun.Run("scp", "job.cleanup.sbatch", "@1:job.cleanup.sbatch")
	br.RunSBatch("job.cleanup.sbatch")

	return aid
}

// RunSBatch runs sbatch on the given sbatch file,
// returning the resulting job id.
func (br *SimRun) RunSBatch(sbatch string) string {
	goalrun.Run("@1")
	goalrun.Run("sbatch", sbatch, ">", "job.slurm")
	goalrun.Run("@0")
	ss := goalrun.Output("@1", "cat", "job.slurm")
	if ss == "" {
		fmt.Println("JobStatus ERROR: no server job.slurm file to get server job id from")
		goalrun.Run("@1", "cd")
		goalrun.Run("@0")
		return ""
	}
	ssf := strings.Fields(ss)
	sj := ssf[len(ssf)-1]
	return sj
}

// NextJobNumber returns the next sequential job number to use,
// incrementing value saved in last_job.number file
func (br *SimRun) NextJobNumber() int {
	jf := "last_job.number"
	jnf := goalib.ReadFile(jf)
	jn := 0
	if jnf != "" {
		jn, _ = strconv.Atoi(strings.TrimSpace(jnf))
	}
	jn++
	goalib.WriteFile(jf, strconv.Itoa(jn))
	return jn
}

func (br *SimRun) NextJobID() string {
	jn := br.NextJobNumber()
	jstr := fmt.Sprintf("%s%05d", br.Config.UserShort, jn)
	return jstr
}

// FindGoMod finds the go.mod file starting from the given directory
func (br *SimRun) FindGoMod(dir string) string {
	for {
		if goalib.FileExists(filepath.Join(dir, "go.mod")) {
			return dir
		}
		dir = filepath.Dir(dir)
		if dir == "" {
			return ""
		}
	}
	return ""
}

// GoModulePath returns the overall module path for project
// in given directory, and the full module path to the current
// project, which is a subdirectory within the module.
func (br *SimRun) GoModulePath(dir string) (modpath, fullpath string) {
	goalrun.Run("@0")
	os.Chdir(dir)
	goalrun.Run("cd", dir)
	gg := goalib.SplitLines(`go mod graph`)
	gg = strings.Fields(gg[0])
	modpath = gg[0]

	// strategy: go up the dir until the dir name matches the last element of modpath
	dirsp := strings.Split(dir, "/")
	n := len(dirsp)
	for i := n - 1; i >= 0; i-- {
		d := dirsp[i]
		if strings.HasSuffix(modpath, d) {
			fullpath = filepath.Join(modpath, strings.Join(dirsp[i+1:], "/"))
			break
		}
	}
	return
}

// CopyFilesToJob copies files with given extensions (none for all),
// from localSrc to localJob and remote hostJob (@1).
// Ensures directories are made in the job locations
func (br *SimRun) CopyFilesToJob(localSrc, localJob, hostJob string, exts ...string) {
	goalrun.Run("@0")
	goalrun.Run("mkdir", "-p", localJob)
	goalrun.Run("cd", localJob)
	goalrun.Run("@1")
	goalrun.Run("cd")
	goalrun.Run("mkdir", "-p", hostJob)
	goalrun.Run("cd", hostJob)
	goalrun.Run("@0")
	efls := fsx.Filenames(localSrc, exts...)
	for _, f := range efls {
		sfn := filepath.Join(localSrc, f)
		goalrun.Run("/bin/cp", sfn, f)
		goalrun.Run("scp", sfn, "@1:"+f)
	}
}

func (br *SimRun) NewJob(message, args, label string) {
	os.Chdir(br.DataRoot)
	jid := br.NextJobID()
	spath := br.ServerJobPath(jid)
	jpath := br.JobPath(jid)
	core.MessageSnackbar(br, "Submitting Job: "+jid)

	gomodDir := br.FindGoMod(br.StartDir)
	_, fullPath := br.GoModulePath(br.StartDir)
	projPath := filepath.Join("emer", br.Config.Project)

	// fmt.Println("go.mod:", gomodDir, "\nmodule:", modulePath, "\nfull path:", fullPath, "\njob proj:", projPath)

	goalrun.Run("@0")
	// fmt.Println(jpath)
	os.MkdirAll(jpath, 0750)
	os.Chdir(jpath)
	goalib.WriteFile("job.message", message)
	goalib.WriteFile("job.args", args)
	goalib.WriteFile("job.label", label)
	goalib.WriteFile("job.submit", time.Now().Format(br.Config.TimeFormat))
	goalib.WriteFile("job.status", "Submitted")

	// need to do sub-code first and update paths in copied files
	codepaths := make([]string, len(br.Config.CodeDirs))
	for i, ed := range br.Config.CodeDirs {
		goalrun.Run("@0")
		loce := filepath.Join(br.StartDir, ed)
		codepaths[i] = filepath.Join(fullPath, ed)
		jpathe := filepath.Join(jpath, ed)
		spathe := filepath.Join(spath, ed)
		br.CopyFilesToJob(loce, jpathe, spathe, ".go")
	}
	// copy local files:
	goalrun.Run("@1")
	goalrun.Run("cd")
	goalrun.Run("mkdir", "-p", spath)
	goalrun.Run("cd", spath)
	goalrun.Run("@0")
	goalrun.Run("cd", jpath)
	fls := fsx.Filenames(br.StartDir, ".go")
	for _, f := range fls {
		sfn := filepath.Join(br.StartDir, f)
		goalrun.Run("/bin/cp", sfn, f)
		for i, ed := range br.Config.CodeDirs {
			subpath := filepath.Join(projPath, ed)
			// fmt.Println("replace in:", f, codepaths[i], "->", subpath)
			goalib.ReplaceInFile(f, codepaths[i], subpath)
		}
		goalrun.Run("scp", f, "@1:"+f)
	}
	for _, f := range br.Config.ExtraFiles {
		sfn := filepath.Join(br.StartDir, f)
		goalrun.Run("/bin/cp", sfn, f)
		goalrun.Run("scp", sfn, "@1:"+f)
	}
	for _, ed := range br.Config.ExtraDirs {
		jpathe := filepath.Join(jpath, ed)
		spathe := filepath.Join(spath, ed)
		loce := filepath.Join(br.StartDir, ed)
		br.CopyFilesToJob(loce, jpathe, spathe)
	}
	goalrun.Run("@1")
	goalrun.Run("cd")
	goalrun.Run("cd", spath)
	goalrun.Run("@0")
	goalrun.Run("cd", jpath)

	core.MessageSnackbar(br, "Job: "+jid+" files copied")
	if gomodDir != "" {
		sfn := filepath.Join(gomodDir, "go.mod")
		// fmt.Println("go.mod dir:", gomodDir, sfn)
		goalrun.Run("scp", sfn, "@1:go.mod")
		sfn = filepath.Join(gomodDir, "go.sum")
		goalrun.Run("scp", sfn, "@1:go.sum")
		goalrun.Run("@1")
		goalrun.Run("go", "mod", "edit", "-module", projPath)
		if br.Config.ExtraGoGet != "" {
			goalrun.Run("go", "get", br.Config.ExtraGoGet)
		}
		goalrun.Run("go", "mod", "tidy")
		goalrun.Run("@0")
		goalrun.Run("scp", "@1:go.mod", "go.mod")
		goalrun.Run("scp", "@1:go.sum", "go.sum")
	} else {
		fmt.Println("go.mod file not found!")
	}

	sid := br.SubmitSBatch(jid, args)

	goalib.WriteFile("job.job", sid)
	fmt.Println("server job id:", sid)
	goalrun.Run("scp", "job.job", "@1:job.job")
	core.MessageSnackbar(br, "Job: "+jid+" server job: "+sid+" successfully submitted")
	goalrun.Run("@1", "cd")
	goalrun.Run("@0")
	br.UpdateSims()
}

// Submit submits a job to SLURM on the server, using an array
// structure, with an outer startup job that calls the main array
// jobs and a final cleanup job.  Creates a new job dir based on
// incrementing counter, synchronizing the job files.
func (br *SimRun) Submit() { //types:add
	lab.PromptStruct(br, &br.Config.Submit, "Submit a new job", func() {
		go br.NewJob(br.Config.Submit.Message, br.Config.Submit.Args, br.Config.Submit.Label)
	})
}
